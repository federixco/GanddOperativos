
...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\generar_sistema_txt.py

...-------------------...

import os

def generar_documento_txt(ruta_base: str, archivo_salida: str):
    """
    Recorre recursivamente la ruta base y, para cada archivo con extensión .py o .json,
    escribe su contenido en el archivo de salida, separando cada módulo con un separador.

    Args:
        ruta_base (str): Directorio base desde donde comenzar la búsqueda.
        archivo_salida (str): Nombre del archivo TXT a generar.
    """
    separador = "\n...-------------------...\n"
    with open(archivo_salida, "w", encoding="utf-8") as out_file:
        for root, dirs, files in os.walk(ruta_base):
            for archivo in files:
                if archivo.endswith(".py") or archivo.endswith(".json"):
                    ruta_archivo = os.path.join(root, archivo)
                    # Escribe el encabezado del archivo
                    out_file.write(separador)
                    out_file.write(f"Archivo: {ruta_archivo}\n")
                    out_file.write(separador)
                    try:
                        with open(ruta_archivo, "r", encoding="utf-8") as in_file:
                            contenido = in_file.read()
                        out_file.write(contenido)
                    except Exception as e:
                        out_file.write(f"Error al leer el archivo: {e}")
                    out_file.write("\n")
        out_file.write(separador)
    print(f"Documento generado en: {archivo_salida}")

if __name__ == "__main__":
    # Si el script se encuentra al mismo nivel que main.py,
    # establecemos la ruta base como el directorio actual.
    ruta_base = os.path.dirname(os.path.realpath(__file__))
    generar_documento_txt(ruta_base, "sistema_completo.txt")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\main.py

...-------------------...
import customtkinter as ctk
from GUI.start_screen import StartScreen
from GUI.name_input_screen import NameInputScreen
from GUI.data_input_screen import DataInputScreen
from GUI.algorithm_screen import AlgorithmScreen

# --- Funciones de navegación entre pantallas ---

def ir_a_nombres(cantidad):
    limpiar_ventana()
    name_screen = NameInputScreen(root, cantidad, ir_a_tiempos)
    name_screen.pack(fill="both", expand=True)

def ir_a_tiempos(nombres):
    limpiar_ventana()
    data_screen = DataInputScreen(root, nombres, ir_a_algoritmo)
    data_screen.pack(fill="both", expand=True)

def ir_a_algoritmo(procesos_data):
    limpiar_ventana()
    algo_screen = AlgorithmScreen(root, procesos_data, volver_inicio)
    algo_screen.pack(fill="both", expand=True)

def volver_inicio():
    limpiar_ventana()
    start_screen = StartScreen(root, ir_a_nombres)
    start_screen.pack(fill="both", expand=True)

def limpiar_ventana():
    """Elimina todos los widgets de la ventana principal."""
    for widget in root.winfo_children():
        widget.destroy()

# --- Configuración inicial de la app ---
if __name__ == "__main__":
    ctk.set_appearance_mode("dark")  # Modo oscuro
    ctk.set_default_color_theme("blue")  # Tema azul

    root = ctk.CTk()
    root.title("TimeSlice - Simulador de Planificación de CPU")
    root.geometry("800x600")

    # Pantalla inicial
    start_screen = StartScreen(root, ir_a_nombres)
    start_screen.pack(fill="both", expand=True)

    root.mainloop()


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\fifo.py

...-------------------...
from copy import deepcopy

def fifo(process_list):
    """
    FIFO no expulsivo sin bloqueos.
    Usa Process con bursts=[CPU] y remaining_time inicializado.
    Devuelve gantt en 3-tuplas: (pid, start, end).
    """
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    time = 0  # Reloj del sistema
    gantt = []  # Lista para almacenar el diagrama de Gantt
    ready = []  # Cola de procesos listos para ejecutar
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos

    # Ordenar por llegada para consistencia (no obligatorio)
    processes.sort(key=lambda p: p.arrival_time)

    while completed < n:  # Mientras no se completen todos los procesos
        # Encolar llegadas al tiempo actual
        for p in processes:
            # Verificar si el proceso:
            # - No ha empezado a ejecutarse (start_time is None)
            # - Ya llegó al sistema (arrival_time <= time)
            # - No está ya en la cola de listos
            # - No ha terminado (completion_time is None)
            if p.start_time is None and p.arrival_time <= time and p not in ready and p.completion_time is None:
                ready.append(p)  # Agregar a la cola de listos

        if ready:  # Si hay procesos listos para ejecutar
            current = ready.pop(0)  # Tomar el primero de la cola (FIFO)
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # Marcar tiempo de inicio

            start = time  # Guardar tiempo de inicio de esta ejecución
            cpu = current.remaining_time  # Tiempo de CPU restante (equivale a bursts[0])
            time += cpu  # Avanzar el reloj del sistema
            gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

            current.completion_time = time  # Marcar tiempo de finalización
            current.calculate_metrics()  # Calcular métricas del proceso
            completed += 1  # Incrementar contador de completados
        else:
            # No hay procesos listos: avanzar 1 unidad de tiempo y reintentar
            time += 1

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\fifo_blocking.py

...-------------------...
# NO TOCAR MAS YA FUNCIONA BIEN 
from copy import deepcopy

def fifo_blocking(process_list):
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    time = 0  # Reloj del sistema
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt
    ready_queue = []  # Cola de procesos listos para ejecutar
    blocked_queue = []  # Cola de procesos bloqueados: (proceso, unblock_time)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos

    current = None  # Proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    # Buffers de encolado para respetar la prioridad:
    # primero entran los que terminan CPU (CPU_FINISH), luego los que salen de BLOQ (UNBLOCK)
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    while completed < n:  # Mientras no se completen todos los procesos
        # 1) Llegadas - Procesar procesos que llegan en este momento
        for p in processes:
            # Verificar si el proceso:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No ha terminado (completion_time is None)
            # - No está ya en la cola de listos
            # - No está bloqueado
            # - No es el proceso actual en ejecución
            # - No está ya en los buffers de encolado
            if (
                p.arrival_time == time
                and p.completion_time is None
                and p not in ready_queue
                and all(bp is not p for bp, _ in blocked_queue)
                and p is not current
                and p not in enq_cpu  # evitar duplicado si llega y ya está en buffer
                and p not in enq_unblock
            ):
                if p.is_cpu_burst():  # Si la primera ráfaga es de CPU
                    enq_cpu.append(p)  # PRIORIDAD: llegan a ready como CPU_FINISH
                else:  # Si la primera ráfaga es de bloqueo
                    dur = p.bursts[p.current_burst_index]  # Duración del bloqueo
                    if dur > 0:  # Si el bloqueo tiene duración
                        gantt_chart.append((p.pid, time, time + dur, "BLOCK"))  # Registrar bloqueo
                        blocked_queue.append((p, time + dur))  # Agregar a cola de bloqueados
                    else:  # Si el bloqueo es de duración 0
                        p.advance_burst()  # Avanzar a la siguiente ráfaga
                        if p.current_burst_index >= len(p.bursts):  # Si terminó el proceso
                            p.completion_time = time
                            completed += 1
                        elif p.is_cpu_burst():  # Si la siguiente es CPU
                            enq_cpu.append(p)  # entra por CPU
                        else:  # Si la siguiente es otro bloqueo
                            dur2 = p.bursts[p.current_burst_index]
                            if dur2 > 0:  # Si tiene duración
                                gantt_chart.append((p.pid, time, time + dur2, "BLOCK"))
                                blocked_queue.append((p, time + dur2))
                            else:  # Si es de duración 0
                                p.advance_burst()
                                if p.current_burst_index < len(p.bursts) and p.is_cpu_burst():
                                    enq_cpu.append(p)

        # 2) Desbloqueos que vencen ahora - Procesar procesos que terminan su bloqueo
        for (bp, unblock_time) in blocked_queue[:]:  # Iterar sobre una copia de la lista
            if unblock_time == time:  # Si el bloqueo termina en este momento
                blocked_queue.remove((bp, unblock_time))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                if bp.current_burst_index >= len(bp.bursts):  # Si terminó el proceso
                    bp.completion_time = time
                    completed += 1
                else:
                    if bp.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        enq_unblock.append(bp)  # SALIDA DE BLOQ va detrás de CPU_FINISH
                    else:  # Si la siguiente ráfaga es de bloqueo
                        dur2 = bp.bursts[bp.current_burst_index]
                        if dur2 > 0:  # Si tiene duración
                            gantt_chart.append((bp.pid, time, time + dur2, "BLOCK"))
                            blocked_queue.append((bp, time + dur2))
                        else:  # Si es de duración 0
                            bp.advance_burst()
                            if bp.current_burst_index >= len(bp.bursts):  # Si terminó
                                bp.completion_time = time
                                completed += 1
                            elif bp.is_cpu_burst():  # Si la siguiente es CPU
                                enq_unblock.append(bp)

        # Mezclar en ready con la prioridad requerida: primero enq_cpu, luego enq_unblock
        if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
            ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero
            ready_queue.extend(enq_unblock)  # Luego los de desbloqueo
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # 3) Selección FIFO - Elegir proceso para ejecutar
        if current is None and ready_queue:  # Si no hay proceso ejecutando y hay listos
            current = ready_queue.pop(0)  # Tomar el primero de la cola (FIFO)
            start_time = time  # Marcar inicio del bloque
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # solo la primera vez que toca CPU

        # 4) Ejecutar 1 tick de CPU o avanzar tiempo si no hay listos
        if current:  # Si hay un proceso ejecutando
            current.remaining_time -= 1  # Reducir tiempo restante
            time += 1  # Avanzar el reloj del sistema

            # ¿Terminó esta ráfaga de CPU?
            if current.remaining_time == 0:  # Si terminó la ráfaga de CPU
                # Cerrar tramo de CPU
                gantt_chart.append((current.pid, start_time, time, "CPU"))

                # Avanzar a la siguiente ráfaga
                current.advance_burst()

                # ¿Proceso terminado?
                if current.current_burst_index >= len(current.bursts):  # Si terminó el proceso
                    current.completion_time = time
                    completed += 1
                    current = None  # Liberar CPU
                else:
                    # ¿Siguiente es CPU?
                    if current.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        # Entra a ready como "CPU_FINISH" (prioridad sobre UNBLOCK si coincide el instante)
                        enq_cpu.append(current)
                        current = None  # Liberar CPU
                    else:  # Si la siguiente ráfaga es de bloqueo
                        # Siguiente es BLOQUEO
                        dur = current.bursts[current.current_burst_index]
                        if dur > 0:  # Si tiene duración
                            gantt_chart.append((current.pid, time, time + dur, "BLOCK"))
                            blocked_queue.append((current, time + dur))
                            current = None  # Liberar CPU
                        else:  # Si es de duración 0
                            # Bloqueo de 0 → saltar
                            current.advance_burst()
                            if current.current_burst_index >= len(current.bursts):  # Si terminó
                                current.completion_time = time
                                completed += 1
                                current = None
                            elif current.is_cpu_burst():  # Si la siguiente es CPU
                                enq_cpu.append(current)
                                current = None

            # Tras terminar el tick, antes de próxima selección, volcamos buffers con prioridad
            if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
                ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready_queue.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
        else:  # No hay proceso ejecutando
            # No hay proceso ejecutando ni listo: avanzar tiempo "vacío" (no pintamos IDLE)
            time += 1

    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\roundrobin.py

...-------------------...
from copy import deepcopy
from collections import deque

def round_robin(process_list, quantum):
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    n = len(processes)  # Total de procesos
    time = 0  # Reloj del sistema
    completed = 0  # Contador de procesos completados
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt

    ready_queue = deque()  # Cola de procesos listos (FIFO con deque)
    # Ordenar por tiempo de llegada, luego por PID para consistencia
    procesos_pendientes = sorted(processes, key=lambda p: (p.arrival_time, p.pid))

    current_pid = None  # PID del proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    while completed < n:  # Mientras no se completen todos los procesos
        # Agregar procesos que llegan en este instante
        # Ordenar por PID para mantener consistencia
        procesos_que_llegan = []
        for p in procesos_pendientes:
            # Verificar si el proceso:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No está ya en la cola de listos
            # - Aún tiene tiempo restante para ejecutar
            if p.arrival_time == time and p not in ready_queue and p.remaining_time > 0:
                procesos_que_llegan.append(p)
        
        # Ordenar por PID y agregar al final de la cola
        procesos_que_llegan.sort(key=lambda p: p.pid)
        for p in procesos_que_llegan:
            ready_queue.append(p)  # Agregar al final de la cola

        if ready_queue:  # Si hay procesos listos para ejecutar
            current = ready_queue.popleft()  # Tomar el primero de la cola

            # Cambio de proceso en ejecución
            if current_pid != current.pid:  # Si cambió el proceso
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = current.pid  # Actualizar PID actual
                start_time = time  # Marcar inicio del nuevo bloque
                if current.start_time is None:  # Si es la primera vez que se ejecuta
                    current.start_time = time  # Marcar tiempo de inicio del proceso

            # Ejecutar hasta quantum o hasta que termine
            exec_time = min(quantum, current.remaining_time)  # Tiempo a ejecutar
            current.remaining_time -= exec_time  # Reducir tiempo restante
            time += exec_time  # Avanzar el reloj del sistema

            # Agregar procesos que llegaron durante la ejecución
            procesos_nuevos = []
            for p in procesos_pendientes:
                # Verificar si llegó durante la ejecución del proceso actual
                if time - exec_time < p.arrival_time <= time and p.remaining_time > 0 and p not in ready_queue:
                    procesos_nuevos.append(p)
            
            # Ordenar por PID y agregar al final
            procesos_nuevos.sort(key=lambda p: p.pid)
            for p in procesos_nuevos:
                ready_queue.append(p)  # Agregar al final de la cola

            if current.remaining_time > 0:  # Si el proceso no terminó
                # Agregar el proceso actual al final si no terminó (Round Robin)
                ready_queue.append(current)
            else:  # Si el proceso terminó
                current.completion_time = time  # Marcar tiempo de finalización
                current.calculate_metrics()  # Calcular métricas del proceso
                completed += 1  # Incrementar contador de completados
        else:  # No hay procesos listos
            # CPU ociosa
            if current_pid != "IDLE":  # Si no está marcado como IDLE
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = "IDLE"  # Marcar como IDLE
                start_time = time  # Marcar inicio del período IDLE
            time += 1  # Avanzar tiempo sin ejecutar nada

    # Cerrar el último bloque
    if current_pid is not None:
        gantt_chart.append((current_pid, start_time, time))

    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\round_robin_blocking.py

...-------------------...
from copy import deepcopy
from collections import deque

def round_robin_blocking(process_list, quantum):
    """Round Robin con bloqueos, ejecución por tramos (no tick a tick)."""

    def collapse_zeros(proc, t):
        """Salta ráfagas 0 encadenadas; si termina, marca completion_time."""
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t
            return True
        return False

    def handle_post(proc, t, enq_cpu, enq_unblock, blocked, gantt):
        """
        Decide qué hacer tras cambiar de ráfaga:
        - Si terminó → True
        - Si CPU → enq_cpu
        - Si BLOQ>0 → programa (BLOCK + blocked)
        - Si BLOQ=0 → encadena recursivamente
        """
        if collapse_zeros(proc, t):
            return True
        if proc.is_cpu_burst():
            enq_cpu.append(proc)
        else:
            dur = proc.bursts[proc.current_burst_index]
            if dur > 0:
                gantt.append((proc.pid, t, t + dur, "BLOCK"))
                blocked.append((proc, t + dur))
            else:
                proc.advance_burst()
                return handle_post(proc, t, enq_cpu, enq_unblock, blocked, gantt)
        return False

    processes = deepcopy(process_list)

    # Init: conservar remaining_time como duración de la ráfaga CPU actual (lo setea Process)
    for idx, p in enumerate(processes):
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        p._seq = idx
        p.ready_since = None
        p.start_time = None
        p.completion_time = None
        if not p.bursts:
            p.current_burst_index = 0
            p.remaining_time = 0
            p.completion_time = 0

    time = 0
    gantt = []
    ready = deque()
    blocked = []                # [(proc, unblock_time)]
    completed = sum(1 for p in processes if p.completion_time is not None)
    n = len(processes)
    arrived = set()

    # Buffers con prioridad: CPU_FINISH/llegada > UNBLOCK
    enq_cpu = []
    enq_unblock = []

    def enqueue_arrivals_leq_t(t):
        """Encola llegadas hasta t (incluido)."""
        nonlocal completed
        for p in processes:
            if p.pid in arrived:
                continue
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)
                if handle_post(p, t, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

    # Llegadas iniciales
    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu); ready.extend(enq_unblock)
        enq_cpu.clear(); enq_unblock.clear()

    while completed < n:
        # Si no hay listos, saltar al siguiente evento
        if not ready:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                # Salvaguarda: marcar terminados sin completion_time
                for p in processes:
                    if p.completion_time is None and p.current_burst_index >= len(p.bursts):
                        p.completion_time = time
                        completed += 1
                break
            next_event = min(future_arrivals + future_unblocks)
            if next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            # Procesar todos los eventos en 'time'
            # Desbloqueos exactamente en 'time'
            for (bp, unb) in blocked[:]:
                if unb == time:
                    blocked.remove((bp, unb))
                    bp.advance_burst()
                    if handle_post(bp, time, enq_cpu, enq_unblock, blocked, gantt):
                        completed += 1
            # Llegadas en 'time'
            enqueue_arrivals_leq_t(time)
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu); ready.extend(enq_unblock)
                enq_cpu.clear(); enq_unblock.clear()
            if not ready:
                continue

        # Selección RR
        current = ready.popleft()
        # Sólo CPU en ready; blindaje por si acaso
        if not current.is_cpu_burst():
            if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                completed += 1
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu); ready.extend(enq_unblock)
                enq_cpu.clear(); enq_unblock.clear()
            continue

        if current.start_time is None:
            current.start_time = time
        # Sync si hiciera falta
        if current.remaining_time <= 0:
            current.remaining_time = current.bursts[current.current_burst_index]

        # Tramo a ejecutar
        exec_time = min(quantum, current.remaining_time)
        start = time
        end = time + exec_time

        # Registrar ejecuciones de otros eventos que ocurren en (time, end]
        # - Desbloqueos
        for (bp, unb) in sorted(blocked[:], key=lambda x: x[1]):
            if time < unb <= end:
                blocked.remove((bp, unb))
                # Avanza ráfaga al instante unb
                bp.advance_burst()
                # Resolver en unb (no preempra al actual, solo prepara ready)
                if handle_post(bp, unb, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
        # - Llegadas
        for p in processes:
            if p.pid in arrived:
                continue
            if time < p.arrival_time <= end and p.completion_time is None:
                arrived.add(p.pid)
                if handle_post(p, p.arrival_time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

        # Consumir CPU del actual y avanzar tiempo
        current.remaining_time -= exec_time
        time = end
        gantt.append((current.pid, start, end, "CPU"))

        # ¿Terminó ráfaga o agotó quantum?
        if current.remaining_time == 0:
            current.advance_burst()
            # Si terminó el proceso
            if current.current_burst_index >= len(current.bursts):
                current.completion_time = time
                completed += 1
            else:
                # Resolver lo que sigue en el mismo tick
                if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
        else:
            # Ráfaga no terminó → reencolar al final
            current.ready_since = time
            enq_cpu.append(current)

        # Volcar buffers con prioridad
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu); ready.extend(enq_unblock)
            enq_cpu.clear(); enq_unblock.clear()

    # Salvaguarda final
    for p in processes:
        if p.completion_time is None and p.current_burst_index >= len(p.bursts):
            p.completion_time = time

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\sjf.py

...-------------------...
from copy import deepcopy

def sjf(process_list):
    """
    SJF no expulsivo sin bloqueos.
    Usa Process con bursts=[CPU] y remaining_time inicializado.
    Devuelve gantt en 3-tuplas: (pid, start, end).
    """
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    time = 0  # Reloj del sistema
    gantt = []  # Lista para almacenar el diagrama de Gantt
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos

    # Para evitar reuso accidental
    for p in processes:
        # remaining_time ya viene de Process(bursts=[cpu])
        pass

    while completed < n:  # Mientras no se completen todos los procesos
        # Elegibles: llegaron y no completados
        elegibles = [p for p in processes if p.arrival_time <= time and p.completion_time is None]

        if not elegibles:  # Si no hay procesos elegibles
            time += 1  # Avanzar tiempo y continuar
            continue

        # Elegir el de menor remaining_time (única ráfaga de CPU)
        # SJF: Shortest Job First - el trabajo más corto primero
        current = min(elegibles, key=lambda p: p.remaining_time)

        if current.start_time is None:  # Si es la primera vez que se ejecuta
            current.start_time = time  # Marcar tiempo de inicio

        start = time  # Guardar tiempo de inicio de esta ejecución
        cpu = current.remaining_time  # Tiempo de CPU restante
        time += cpu  # Avanzar el reloj del sistema
        gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

        current.completion_time = time  # Marcar tiempo de finalización
        current.calculate_metrics()  # Calcular métricas del proceso
        completed += 1  # Incrementar contador de completados

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\sjf_blocking.py

...-------------------...
﻿# algoritmo/sjf_blocking.py
from copy import deepcopy

def sjf_blocking(process_list):
    processes = deepcopy(process_list)

    # --- Helper: total de CPU restante desde la posición actual ---
    def cpu_total_restante(p):
        idx = p.current_burst_index
        if idx >= len(p.bursts):
            return 0
        # si está parado en bloqueo (índice impar), la próxima CPU es idx+1
        start = idx if idx % 2 == 0 else idx + 1
        total = 0
        for i in range(start, len(p.bursts), 2):  # sólo posiciones de CPU
            # si es la CPU actual y ya se consumió parcialmente, el burst refleja lo que queda
            total += p.bursts[i]
        return total

    # Init por proceso
    for idx, p in enumerate(processes):
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        p._seq = idx
        # 'remaining_time' queda como métrica informativa; NO se usa para priorizar
        p.remaining_time = sum(b for i, b in enumerate(p.bursts) if i % 2 == 0)
        p.ready_since = None
        p.start_time = None
        p.completion_time = None

    time = 0
    gantt = []
    ready = []
    blocked = []      # [(proc, unblock_time)]
    completed = 0
    n = len(processes)
    arrived = set()   # PIDs ya encolados por llegada

    # Buffers de encolado con prioridad
    enq_cpu = []      # procesos que entran por llegada o fin de CPU
    enq_unblock = []  # procesos que entran por fin de bloqueo

    def collapse_zeros(proc, t):
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t
            return True
        return False

    def enqueue_arrivals_leq_t(t):
        nonlocal completed
        for p in processes:
            if p.pid in arrived:
                continue
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)
                if collapse_zeros(p, t):
                    completed += 1
                    continue
                if p.is_cpu_burst():
                    p.ready_since = p.arrival_time
                    enq_cpu.append(p)  # llegada → prioridad CPU_FINISH
                else:
                    dur = p.bursts[p.current_burst_index]
                    if dur > 0:
                        gantt.append((p.pid, t, t + dur, "BLOCK"))
                        blocked.append((p, t + dur))
                    else:
                        p.advance_burst()
                        if collapse_zeros(p, t):
                            completed += 1
                        elif p.is_cpu_burst():
                            p.ready_since = p.arrival_time
                            enq_cpu.append(p)

    # Inicializar con todos los procesos que llegan en tiempo 0 o antes
    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)
        ready.extend(enq_unblock)
        enq_cpu.clear()
        enq_unblock.clear()

    while completed < n:
        # 1) Procesar TODOS los desbloqueos que vencieron hasta t
        if blocked:
            blocked.sort(key=lambda x: x[1])
        for (bp, unb) in blocked[:]:
            if unb <= time:
                blocked.remove((bp, unb))
                bp.advance_burst()
                if collapse_zeros(bp, time):
                    completed += 1
                    continue
                if bp.is_cpu_burst():
                    bp.ready_since = time
                    enq_unblock.append(bp)  # fin de BLOQ → va detrás de CPU_FINISH
                else:
                    dur = bp.bursts[bp.current_burst_index]
                    if dur > 0:
                        gantt.append((bp.pid, time, time + dur, "BLOCK"))
                        blocked.append((bp, time + dur))
                    else:
                        bp.advance_burst()
                        if collapse_zeros(bp, time):
                            completed += 1
                        elif bp.is_cpu_burst():
                            bp.ready_since = time
                            enq_unblock.append(bp)

        # 2) Encolar llegadas que hayan llegado hasta este momento
        enqueue_arrivals_leq_t(time)

        # 2.1) Volcar buffers a ready con prioridad CPU_FINISH > UNBLOCK
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

        # 3) Si no hay listos, saltar al siguiente evento
        if not ready:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                break
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else None
            if next_event is None:
                time += 1
            elif next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            continue

        # 4) Selección SJF **por total de CPU restante**
        ready = [p for p in ready if p.current_burst_index < len(p.bursts)]
        ready.sort(key=lambda x: (
            cpu_total_restante(x),                 # menor CPU total restante
            (x.ready_since if x.ready_since is not None else x.arrival_time),
            x.pid
        ))

        current = ready.pop(0)
        if current.start_time is None:
            current.start_time = time

        # 5) Ejecutar ráfaga completa
        start = time
        cpu_dur = current.bursts[current.current_burst_index]
        if cpu_dur <= 0:
            if collapse_zeros(current, time):
                completed += 1
            else:
                if current.is_cpu_burst():
                    current.ready_since = time
                    enq_cpu.append(current)
            continue

        time += cpu_dur
        # 'remaining_time' se ajusta solo como dato; no afecta prioridad
        if hasattr(current, "remaining_time") and current.remaining_time is not None:
            current.remaining_time -= cpu_dur
            if current.remaining_time < 0:
                current.remaining_time = 0
        gantt.append((current.pid, start, time, "CPU"))

        # 6) Avanzar bursts y re-encolar según corresponda
        current.advance_burst()
        if collapse_zeros(current, time):
            completed += 1
            continue

        if current.is_cpu_burst():
            current.ready_since = time
            enq_cpu.append(current)
        else:
            dur = current.bursts[current.current_burst_index]
            if dur > 0:
                gantt.append((current.pid, time, time + dur, "BLOCK"))
                blocked.append((current, time + dur))
            else:
                current.advance_burst()
                if collapse_zeros(current, time):
                    completed += 1
                elif current.is_cpu_burst():
                    current.ready_since = time
                    enq_cpu.append(current)

        # 6.1) Volcar buffers a ready con prioridad
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\srtf.py

...-------------------...
from copy import deepcopy

def srtf(process_list):
    """
    Simula la planificación SRTF (Shortest Remaining Time First, expulsivo).

    :param process_list: lista de objetos Process
    :return: (gantt_chart, procesos_con_metricas)
    """
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    n = len(processes)  # Total de procesos
    completed = 0  # Contador de procesos completados
    time = 0  # Reloj del sistema
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt

    # Para controlar cambios de proceso
    current_pid = None  # PID del proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    while completed < n:  # Mientras no se completen todos los procesos
        # Filtrar procesos listos y no completados
        ready_queue = [p for p in processes if p.arrival_time <= time and p.remaining_time > 0]

        if ready_queue:  # Si hay procesos listos para ejecutar
            # Elegir el de menor tiempo restante, con desempate por FIFO
            ready_queue.sort(key=lambda x: (
                x.remaining_time,  # SRTF: menor tiempo restante (prioridad principal)
                x.arrival_time,    # FIFO en empates (desempate por llegada)
                x.pid             # estabilidad (desempate por PID)
            ))
            current = ready_queue[0]  # Tomar el proceso con menor tiempo restante

            # Si cambia el proceso en ejecución, cerramos el bloque anterior
            if current_pid != current.pid:  # Si cambió el proceso
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = current.pid  # Actualizar PID actual
                start_time = time  # Marcar inicio del nuevo bloque
                if current.start_time is None:  # Si es la primera vez que se ejecuta
                    current.start_time = time  # Marcar tiempo de inicio del proceso

            # Ejecutar 1 unidad de tiempo (SRTF es expulsivo)
            current.remaining_time -= 1  # Reducir tiempo restante
            time += 1  # Avanzar el reloj del sistema

            # Si termina
            if current.remaining_time == 0:  # Si el proceso terminó
                current.completion_time = time  # Marcar tiempo de finalización
                current.calculate_metrics()  # Calcular métricas del proceso
                completed += 1  # Incrementar contador de completados
        else:  # No hay procesos listos
            # CPU ociosa
            if current_pid != "IDLE":  # Si no está marcado como IDLE
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = "IDLE"  # Marcar como IDLE
                start_time = time  # Marcar inicio del período IDLE
            time += 1  # Avanzar tiempo sin ejecutar nada

    # Cerrar el último bloque
    if current_pid is not None:
        gantt_chart.append((current_pid, start_time, time))

    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\srtf_blocking.py

...-------------------...
from copy import deepcopy

def srtf_blocking(process_list):
    """SRTF expulsivo con soporte para bloqueos, usando get_total_cpu_remaining()."""

    def collapse_zeros(proc, t):
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t
            return True
        return False

    def handle_post(proc, t, destino_cpu, destino_unblock, destino_blocked, gantt):
        if collapse_zeros(proc, t):
            return True
        if proc.is_cpu_burst():
            destino_cpu.append(proc)
        else:
            dur = proc.bursts[proc.current_burst_index]
            if dur > 0:
                gantt.append((proc.pid, t, t + dur, "BLOCK"))
                destino_blocked.append((proc, t + dur))
            else:
                proc.advance_burst()
                return handle_post(proc, t, destino_cpu, destino_unblock, destino_blocked, gantt)
        return False

    processes = deepcopy(process_list)
    for idx, p in enumerate(processes):
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        p._seq = idx
        p.ready_since = None
        p.start_time = None
        p.completion_time = None

    time = 0
    gantt = []
    ready = []
    blocked = []
    completed = 0
    n = len(processes)
    arrived = set()

    enq_cpu = []
    enq_unblock = []

    def enqueue_arrivals_leq_t(t):
        nonlocal completed
        for p in processes:
            if p.pid in arrived:
                continue
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)
                if handle_post(p, t, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

    def process_unblocks_leq_t(t):
        nonlocal completed
        for (bp, unb) in blocked[:]:
            if unb <= t:
                blocked.remove((bp, unb))
                bp.advance_burst()
                if handle_post(bp, t, enq_unblock, enq_unblock, blocked, gantt):
                    completed += 1

    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)
        ready.extend(enq_unblock)
        enq_cpu.clear()
        enq_unblock.clear()

    current = None
    seg_start = None

    while completed < n:
        process_unblocks_leq_t(time)
        enqueue_arrivals_leq_t(time)

        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

        eligibles = [p for p in ready if p.is_cpu_burst() and not p.is_finished()]
        if not eligibles:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                break
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else None
            if next_event is None:
                time += 1
            elif next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            current = None
            seg_start = None
            continue

        eligibles.sort(key=lambda x: (x.get_total_cpu_remaining(), x.ready_since or x.arrival_time, x.pid))
        candidate = eligibles[0]

        if current is not candidate:
            if current is not None and seg_start is not None and time > seg_start:
                gantt.append((current.pid, seg_start, time, "CPU"))
            current = candidate
            seg_start = time
            if current.start_time is None:
                current.start_time = time

        # Ejecutar 1 tick
        current.bursts[current.current_burst_index] -= 1
        current.remaining_time = current.get_total_cpu_remaining()
        time += 1

        # Fin de ráfaga
        if current.bursts[current.current_burst_index] == 0:
            gantt.append((current.pid, seg_start, time, "CPU"))
            current.advance_burst()
            if current.is_finished():
                current.completion_time = time
                completed += 1
                current = None
                seg_start = None
            else:
                if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
                current = None
                seg_start = None
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu)
                ready.extend(enq_unblock)
                enq_cpu.clear()
                enq_unblock.clear()
            continue

        # Preempción
        process_unblocks_leq_t(time)
        enqueue_arrivals_leq_t(time)
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

        eligibles = [p for p in ready if p.is_cpu_burst() and not p.is_finished()]
        if eligibles:
            eligibles.sort(key=lambda x: (x.get_total_cpu_remaining(), x.ready_since or x.arrival_time, x.pid))
            best = eligibles[0]
            if best is not current and best.get_total_cpu_remaining() < current.get_total_cpu_remaining():
                gantt.append((current.pid, seg_start, time, "CPU"))
                current.ready_since = time
                enq_cpu.append(current)
                current = None
                seg_start = None
                ready.extend(enq_cpu)
                ready.extend(enq_unblock)
                enq_cpu.clear()
                enq_unblock.clear()

    if current is not None and seg_start is not None and time > seg_start:
        gantt.append((current.pid, seg_start, time, "CPU"))

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\algorithm_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox, ttk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt

from utils import historial

from models.process import Process
# Algoritmos sin bloqueos
from algoritmos.fifo import fifo
from algoritmos.sjf import sjf
from algoritmos.srtf import srtf
from algoritmos.roundrobin import round_robin
# Algoritmos con bloqueos
from algoritmos.fifo_blocking import fifo_blocking
from algoritmos.sjf_blocking import sjf_blocking
from algoritmos.srtf_blocking import srtf_blocking
from algoritmos.round_robin_blocking import round_robin_blocking

from utils.metricas import calcular_metricas
from utils.excel_export import exportar_a_excel


class AlgorithmScreen(ctk.CTkFrame):
    def __init__(self, master, procesos_data, volver_inicio):
        super().__init__(master)
        self.procesos_data = procesos_data
        self.volver_inicio = volver_inicio
        
        # Variables para almacenar el gráfico actual
        self.current_gantt = None
        self.current_algorithm = None
        self.current_fig = None
        self.current_metricas = None
        self.current_trm = None
        self.current_tem = None
        self.current_quantum = None
        
        # Variables para el zoom
        self.zoom_level = 1.0
        self.original_xlim = None
        self.original_ylim = None
        self.current_ax = None
        self.current_canvas = None
        
        # Variables para el pan (arrastrar)
        self.pan_start_x = None
        self.pan_start_y = None
        self.is_panning = False

        # --- Selección de algoritmo ---
        self.label_title = ctk.CTkLabel(self, text="Seleccionar algoritmo", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=10)

        self.algoritmos = ["FIFO", "SJF", "SRTF", "Round Robin"]
        self.selected_algo = ctk.StringVar(value=self.algoritmos[0])
        self.option_menu = ctk.CTkOptionMenu(
            self, values=self.algoritmos, variable=self.selected_algo, command=self._on_algo_change
        )
        self.option_menu.pack(pady=5)

        # --- Botones de control ---
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)
        self.btn_run = ctk.CTkButton(btn_frame, text="Ejecutar", command=self._run_algorithm)
        self.btn_run.pack(side="left", padx=5)
        self.btn_export = ctk.CTkButton(btn_frame, text="Exportar PNG", command=self._export_png, 
                                      fg_color="green", hover_color="#006600")
        self.btn_export.pack(side="left", padx=5)
        self.btn_export_excel = ctk.CTkButton(btn_frame, text="Exportar Excel", command=self._export_excel, 
                                            fg_color="purple", hover_color="#660066")
        self.btn_export_excel.pack(side="left", padx=5)
        self.btn_new = ctk.CTkButton(btn_frame, text="Nuevo ejercicio", command=self.volver_inicio)
        self.btn_new.pack(side="left", padx=5)
        self.btn_exit = ctk.CTkButton(
            btn_frame, text="Salir", fg_color="red", hover_color="#aa0000", command=self._salir
        )
        self.btn_exit.pack(side="left", padx=5)

        # --- Controles de zoom ---
        zoom_frame = ctk.CTkFrame(self)
        zoom_frame.pack(pady=5)
        
        self.label_zoom = ctk.CTkLabel(zoom_frame, text="Zoom:", font=("Arial", 12, "bold"))
        self.label_zoom.pack(side="left", padx=5)
        
        self.btn_zoom_out = ctk.CTkButton(zoom_frame, text="−", command=self._zoom_out, 
                                        width=30, height=30, font=("Arial", 16, "bold"))
        self.btn_zoom_out.pack(side="left", padx=2)
        
        self.label_zoom_level = ctk.CTkLabel(zoom_frame, text="100%", font=("Arial", 12))
        self.label_zoom_level.pack(side="left", padx=5)
        
        self.btn_zoom_in = ctk.CTkButton(zoom_frame, text="+", command=self._zoom_in, 
                                       width=30, height=30, font=("Arial", 16, "bold"))
        self.btn_zoom_in.pack(side="left", padx=2)
        
        self.btn_zoom_reset = ctk.CTkButton(zoom_frame, text="Reset", command=self._zoom_reset, 
                                          width=50, height=30, fg_color="orange", hover_color="#cc6600")
        self.btn_zoom_reset.pack(side="left", padx=5)
        
        self.btn_open_window = ctk.CTkButton(zoom_frame, text="Abrir en Ventana", 
                                           command=self._open_in_window, 
                                           width=120, height=30, 
                                           fg_color="purple", hover_color="#660066")
        self.btn_open_window.pack(side="left", padx=5)
        
        # Etiqueta informativa
        self.label_zoom_info = ctk.CTkLabel(zoom_frame, 
                                          text="💡 Rueda: Zoom | Click+Arrastrar: Mover", 
                                          font=("Arial", 10), text_color="gray")
        self.label_zoom_info.pack(side="left", padx=10)

        # --- Campo quantum (solo si RR) ---
        self.frame_quantum = ctk.CTkFrame(self)
        self.label_quantum = ctk.CTkLabel(self.frame_quantum, text="Quantum:")
        self.label_quantum.pack(side="left", padx=5)
        self.entry_quantum = ctk.CTkEntry(self.frame_quantum, placeholder_text="Ej: 2", width=60)
        self.entry_quantum.pack(side="left", padx=5)

        # --- Tabla BCP ---
        self.tree = ttk.Treeview(self, columns=("PID", "Llegada", "CPU", "TR", "TE"), show="headings", height=8)
        for col in ("PID", "Llegada", "CPU", "TR", "TE"):
            self.tree.heading(col, text=col)
            self.tree.column(col, width=80, anchor="center")
        self.tree.pack(pady=10, fill="x")

        # --- Label promedios ---
        self.label_promedios = ctk.CTkLabel(self, text="TRM: -    |    TEM: -", font=("Arial", 14))
        self.label_promedios.pack(pady=5)

        # --- Frame gráfico ---
        self.frame_gantt = ctk.CTkFrame(self)
        self.frame_gantt.pack(pady=10, fill="both", expand=True)

    def _on_algo_change(self, value):
        if value == "Round Robin":
            self.frame_quantum.pack(before=self.tree, pady=5)
        else:
            self.frame_quantum.pack_forget()

    def _run_algorithm(self):
        # Crear copias de los procesos para no modificar los originales
        from copy import deepcopy
        procesos = [Process(p["pid"], p["arrival_time"], p["bursts"]) for p in self.procesos_data]
        algo = self.selected_algo.get()

        try:
            if algo == "FIFO":
                gantt, result = fifo_blocking(procesos)
            elif algo == "SJF":
                gantt, result = sjf_blocking(procesos)
            elif algo == "SRTF":
                gantt, result = srtf_blocking(procesos)
            elif algo == "Round Robin":
                quantum = self._get_quantum()
                if quantum is None:
                    return
                # Detectar si los procesos tienen bloqueos
                tiene_bloqueos = any(len(p["bursts"]) > 1 for p in self.procesos_data)
                if tiene_bloqueos:
                    gantt, result = round_robin_blocking(procesos, quantum)
                else:
                    gantt, result = round_robin(procesos, quantum)
        except Exception as e:
            messagebox.showerror("Error", f"Ocurrió un error al ejecutar: {e}")
            return

        # Calcular métricas
        metricas, trm, tem = calcular_metricas(result)

        # Actualizar tabla
        for row in self.tree.get_children():
            self.tree.delete(row)
        for m in metricas:
            self.tree.insert("", "end", values=(m["PID"], m["Llegada"], m["CPU"], m["TR"], m["TE"]))

        # Actualizar promedios
        self.label_promedios.configure(
            text=f"TRM (Tiempo de Respuesta Medio): {trm:.2f}    |    TEM (Tiempo de Espera Medio): {tem:.2f}"
        )

        # Almacenar datos del gráfico para exportación
        self.current_gantt = gantt
        self.current_algorithm = algo
        self.current_metricas = metricas
        self.current_trm = trm
        self.current_tem = tem
        
        # Obtener quantum si es Round Robin
        if algo == "Round Robin":
            self.current_quantum = self._get_quantum()
        else:
            self.current_quantum = None
        
        # Mostrar gráfico
        self._mostrar_gantt_embebido(gantt, algo)

    def _get_quantum(self):
        try:
            quantum = int(self.entry_quantum.get())
            if quantum <= 0:
                raise ValueError
            return quantum
        except ValueError:
            messagebox.showerror("Error", "Ingrese un quantum válido (> 0)")
            return None

    def _mostrar_gantt_embebido(self, gantt_chart, algo):
        for widget in self.frame_gantt.winfo_children():
            widget.destroy()

        norm = []
        for seg in gantt_chart:
            if len(seg) == 3:
                pid, start, end = seg
                tipo = "CPU" if pid != "IDLE" else "IDLE"
                norm.append((pid, start, end, tipo))
            elif len(seg) == 4:
                norm.append(seg)

        # Ajustar el tamaño del gráfico según el número de procesos y duración total
        num_procesos = len(set(pid for pid, _, _, tipo in norm if pid != "IDLE"))
        max_time = max(end for _, _, end, _ in norm) if norm else 1
        
        # Calcular dimensiones adaptativas - más ancho para mostrar todos los ticks
        fig_width = max(15, max_time * 0.25)  # Ancho basado en duración total, más generoso
        fig_height = max(4, num_procesos * 0.8)  # Altura basada en número de procesos
        
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))
        
        procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
        procesos_unicos = list(dict.fromkeys(procesos_unicos))
        y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

        colors = {}
        color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

        for pid, start, end, tipo in norm:
            if tipo == "IDLE":
                color = "lightgray"
                hatch = None
                y = -1
                alpha = 0.7
            elif tipo == "BLOCK":
                color = "darkred"
                hatch = "///"
                y = y_positions.get(pid, 0)
                alpha = 0.8
            else:  # CPU
                if pid not in colors:
                    colors[pid] = color_palette(len(colors))
                color = colors[pid]
                hatch = None
                y = y_positions.get(pid, 0)
                alpha = 1.0

            ax.barh(y, end - start, left=start, height=0.6, color=color, 
                   edgecolor='black', hatch=hatch, alpha=alpha)
            
            if tipo != "IDLE":
                # Mostrar el PID y el tipo de ráfaga
                text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
                ax.text((start + end) / 2, y, text, ha='center', va='center',
                        fontsize=7, color="white" if tipo == "BLOCK" else "black",
                        weight="bold" if tipo == "BLOCK" else "normal")

        if procesos_unicos:
            ax.set_yticks(list(y_positions.values()))
            ax.set_yticklabels(list(y_positions.keys()))
        else:
            ax.set_yticks([])

        if norm:
            max_time = max(end for _, _, end, _ in norm)
            
            # Mostrar TODOS los ticks del 0 al tiempo máximo
            ax.set_xticks(range(0, max_time + 1))
            ax.set_xlim(0, max_time)
        ax.set_xlabel("Tiempo")
        ax.set_ylabel("Procesos")
        ax.set_title(f"Diagrama de Gantt - {algo}")
        ax.grid(True, axis='x', linestyle='--', alpha=0.6)
        
        # Agregar leyenda explicativa
        legend_elements = [
            plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
            plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
            plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
        ]
        ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))

        # Ajustar el layout para mejor uso del espacio
        plt.tight_layout()
        
        # Crear canvas directamente en el frame
        canvas = FigureCanvasTkAgg(fig, master=self.frame_gantt)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Almacenar la figura y canvas para zoom
        self.current_fig = fig
        self.current_ax = ax
        self.current_canvas = canvas
        
        # Guardar los límites originales para el zoom
        self.original_xlim = ax.get_xlim()
        self.original_ylim = ax.get_ylim()
        
        # Resetear el nivel de zoom
        self.zoom_level = 1.0
        self._update_zoom_label()
        
        # Variables para el pan (arrastrar)
        self.pan_start_x = None
        self.pan_start_y = None
        self.is_panning = False
        
        # Configurar eventos de mouse
        canvas.mpl_connect("scroll_event", self._on_mouse_wheel)
        canvas.mpl_connect("button_press_event", self._on_mouse_press)
        canvas.mpl_connect("button_release_event", self._on_mouse_release)
        canvas.mpl_connect("motion_notify_event", self._on_mouse_motion)

    def _export_png(self):
        """Exporta el gráfico actual como PNG."""
        if self.current_fig is None:
            messagebox.showwarning("Advertencia", "No hay gráfico para exportar. Ejecute un algoritmo primero.")
            return
        
        try:
            from tkinter import filedialog
            import os
            from datetime import datetime
            
            # Generar nombre de archivo con timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"gantt_{self.current_algorithm}_{timestamp}.png"
            
            # Abrir diálogo para seleccionar ubicación
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("All files", "*.*")],
                initialfile=default_filename,
                title="Guardar gráfico como PNG"
            )
            
            if file_path:
                # Exportar con alta resolución
                self.current_fig.savefig(file_path, dpi=300, bbox_inches='tight', 
                                       facecolor='white', edgecolor='none')
                messagebox.showinfo("Éxito", f"Gráfico exportado exitosamente:\n{file_path}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar el gráfico:\n{str(e)}")

    def _export_excel(self):
        """Exporta los resultados actuales a un archivo Excel."""
        if (self.current_gantt is None or self.current_algorithm is None or 
            self.current_metricas is None):
            messagebox.showwarning("Advertencia", "No hay datos para exportar. Ejecute un algoritmo primero.")
            return
        
        try:
            from tkinter import filedialog
            import os
            from datetime import datetime
            
            # Generar nombre de archivo con timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"resultados_{self.current_algorithm}_{timestamp}.xlsx"
            
            # Abrir diálogo para seleccionar ubicación
            file_path = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
                initialfile=default_filename,
                title="Guardar resultados como Excel"
            )
            
            if file_path:
                # Crear archivo temporal
                temp_file = exportar_a_excel(
                    procesos_data=self.procesos_data,
                    algoritmo=self.current_algorithm,
                    gantt_data=self.current_gantt,
                    metricas=self.current_metricas,
                    trm=self.current_trm,
                    tem=self.current_tem,
                    quantum=self.current_quantum
                )
                
                # Mover el archivo a la ubicación seleccionada
                import shutil
                shutil.move(temp_file, file_path)
                
                messagebox.showinfo("Éxito", f"Resultados exportados exitosamente a:\n{file_path}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar a Excel:\n{str(e)}")

    def _salir(self):
        self.master.destroy()

    def _zoom_in(self):
        """Aumenta el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        
        self.zoom_level *= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_out(self):
        """Disminuye el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        
        self.zoom_level /= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_reset(self):
        """Resetea el zoom a la vista original."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        
        self.zoom_level = 1.0
        self.current_ax.set_xlim(self.original_xlim)
        self.current_ax.set_ylim(self.original_ylim)
        self.current_canvas.draw()
        self._update_zoom_label()
        
        # Resetear variables de pan
        self.is_panning = False
        self.pan_start_x = None
        self.pan_start_y = None

    def _apply_zoom(self):
        """Aplica el nivel de zoom actual al gráfico."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        
        # Calcular los nuevos límites basados en el zoom
        x_center = (self.original_xlim[0] + self.original_xlim[1]) / 2
        y_center = (self.original_ylim[0] + self.original_ylim[1]) / 2
        
        x_range = (self.original_xlim[1] - self.original_xlim[0]) / self.zoom_level
        y_range = (self.original_ylim[1] - self.original_ylim[0]) / self.zoom_level
        
        new_xlim = (x_center - x_range/2, x_center + x_range/2)
        new_ylim = (y_center - y_range/2, y_center + y_range/2)
        
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()

    def _update_zoom_label(self):
        """Actualiza la etiqueta que muestra el nivel de zoom actual."""
        self.label_zoom_level.configure(text=f"{int(self.zoom_level * 100)}%")

    def _on_mouse_wheel(self, event):
        """Maneja el evento de la rueda del mouse para zoom."""
        if self.current_ax is None:
            return
        
        # Determinar si hacer zoom in o out
        if event.delta > 0:
            self._zoom_in()
        else:
            self._zoom_out()

    def _on_mouse_press(self, event):
        """Maneja el evento de presionar el botón del mouse para iniciar pan."""
        if self.current_ax is None or event.inaxes != self.current_ax:
            return
        
        if event.button == 1:  # Botón izquierdo del mouse
            self.is_panning = True
            self.pan_start_x = event.xdata
            self.pan_start_y = event.ydata
            # Cambiar el cursor para indicar que se puede arrastrar
            self.current_canvas.get_tk_widget().configure(cursor="fleur")

    def _on_mouse_release(self, event):
        """Maneja el evento de soltar el botón del mouse para terminar pan."""
        if self.current_ax is None:
            return
        
        if event.button == 1:  # Botón izquierdo del mouse
            self.is_panning = False
            self.pan_start_x = None
            self.pan_start_y = None
            # Restaurar el cursor normal
            self.current_canvas.get_tk_widget().configure(cursor="")

    def _on_mouse_motion(self, event):
        """Maneja el movimiento del mouse para pan."""
        if (self.current_ax is None or not self.is_panning or 
            event.inaxes != self.current_ax or 
            self.pan_start_x is None or self.pan_start_y is None):
            return
        
        # Calcular el desplazamiento
        dx = event.xdata - self.pan_start_x
        dy = event.ydata - self.pan_start_y
        
        # Obtener los límites actuales
        xlim = self.current_ax.get_xlim()
        ylim = self.current_ax.get_ylim()
        
        # Aplicar el desplazamiento
        new_xlim = (xlim[0] - dx, xlim[1] - dx)
        new_ylim = (ylim[0] - dy, ylim[1] - dy)
        
        # Actualizar los límites
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()
        
        # Actualizar la posición de inicio para el siguiente movimiento
        self.pan_start_x = event.xdata
        self.pan_start_y = event.ydata

    def _open_in_window(self):
        """Abre el gráfico actual en una ventana separada."""
        if self.current_gantt is None or self.current_algorithm is None:
            messagebox.showwarning("Advertencia", "No hay gráfico para abrir. Ejecute un algoritmo primero.")
            return
        
        # Crear y mostrar la ventana separada
        GanttWindow(self.current_gantt, self.current_algorithm)


class GanttWindow:
    """Ventana separada para mostrar el diagrama de Gantt con zoom y pan."""
    
    def __init__(self, gantt_chart, algorithm):
        self.gantt_chart = gantt_chart
        self.algorithm = algorithm
        
        # Crear ventana
        self.window = ctk.CTkToplevel()
        self.window.title(f"Diagrama de Gantt - {algorithm}")
        self.window.geometry("1200x800")
        self.window.resizable(True, True)
        
        # Variables para zoom y pan
        self.zoom_level = 1.0
        self.original_xlim = None
        self.original_ylim = None
        self.current_ax = None
        self.current_canvas = None
        self.pan_start_x = None
        self.pan_start_y = None
        self.is_panning = False
        
        self._create_interface()
        self._create_gantt()
        
        # Centrar la ventana
        self.window.transient()
        self.window.grab_set()
        
    def _create_interface(self):
        """Crea la interfaz de la ventana."""
        # Frame de controles
        control_frame = ctk.CTkFrame(self.window)
        control_frame.pack(fill="x", padx=10, pady=5)
        
        # Título
        title_label = ctk.CTkLabel(control_frame, text=f"Diagrama de Gantt - {self.algorithm}", 
                                 font=("Arial", 16, "bold"))
        title_label.pack(side="left", padx=10)
        
        # Controles de zoom
        zoom_frame = ctk.CTkFrame(control_frame)
        zoom_frame.pack(side="right", padx=10)
        
        ctk.CTkLabel(zoom_frame, text="Zoom:", font=("Arial", 12, "bold")).pack(side="left", padx=5)
        
        btn_zoom_out = ctk.CTkButton(zoom_frame, text="−", command=self._zoom_out, 
                                   width=30, height=30, font=("Arial", 16, "bold"))
        btn_zoom_out.pack(side="left", padx=2)
        
        self.label_zoom_level = ctk.CTkLabel(zoom_frame, text="100%", font=("Arial", 12))
        self.label_zoom_level.pack(side="left", padx=5)
        
        btn_zoom_in = ctk.CTkButton(zoom_frame, text="+", command=self._zoom_in, 
                                  width=30, height=30, font=("Arial", 16, "bold"))
        btn_zoom_in.pack(side="left", padx=2)
        
        btn_zoom_reset = ctk.CTkButton(zoom_frame, text="Reset", command=self._zoom_reset, 
                                     width=50, height=30, fg_color="orange", hover_color="#cc6600")
        btn_zoom_reset.pack(side="left", padx=5)
        
        # Frame para el gráfico
        self.graph_frame = ctk.CTkFrame(self.window)
        self.graph_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
    def _create_gantt(self):
        """Crea el diagrama de Gantt en la ventana."""
        import matplotlib.pyplot as plt
        from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
        
        # Normalizar datos del gantt
        norm = []
        for seg in self.gantt_chart:
            if len(seg) == 3:
                pid, start, end = seg
                tipo = "CPU" if pid != "IDLE" else "IDLE"
                norm.append((pid, start, end, tipo))
            elif len(seg) == 4:
                norm.append(seg)

        # Calcular dimensiones
        num_procesos = len(set(pid for pid, _, _, tipo in norm if pid != "IDLE"))
        max_time = max(end for _, _, end, _ in norm) if norm else 1
        
        fig_width = max(15, max_time * 0.25)
        fig_height = max(6, num_procesos * 0.8)
        
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))
        
        # Procesar datos
        procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
        procesos_unicos = list(dict.fromkeys(procesos_unicos))
        y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

        colors = {}
        color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

        # Dibujar barras
        for pid, start, end, tipo in norm:
            if tipo == "IDLE":
                color = "lightgray"
                hatch = None
                y = -1
                alpha = 0.7
            elif tipo == "BLOCK":
                color = "darkred"
                hatch = "///"
                y = y_positions.get(pid, 0)
                alpha = 0.8
            else:  # CPU
                if pid not in colors:
                    colors[pid] = color_palette(len(colors))
                color = colors[pid]
                hatch = None
                y = y_positions.get(pid, 0)
                alpha = 1.0

            ax.barh(y, end - start, left=start, height=0.6, color=color, 
                   edgecolor='black', hatch=hatch, alpha=alpha)
            
            if tipo != "IDLE":
                text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
                ax.text((start + end) / 2, y, text, ha='center', va='center',
                        fontsize=7, color="white" if tipo == "BLOCK" else "black",
                        weight="bold" if tipo == "BLOCK" else "normal")

        # Configurar ejes
        if procesos_unicos:
            ax.set_yticks(list(y_positions.values()))
            ax.set_yticklabels(list(y_positions.keys()))
        else:
            ax.set_yticks([])

        if norm:
            max_time = max(end for _, _, end, _ in norm)
            ax.set_xticks(range(0, max_time + 1))
            ax.set_xlim(0, max_time)
            
        ax.set_xlabel("Tiempo")
        ax.set_ylabel("Procesos")
        ax.set_title(f"Diagrama de Gantt - {self.algorithm}")
        ax.grid(True, axis='x', linestyle='--', alpha=0.6)
        
        # Leyenda
        legend_elements = [
            plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
            plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
            plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
        ]
        ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))

        plt.tight_layout()
        
        # Crear canvas
        canvas = FigureCanvasTkAgg(fig, master=self.graph_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Almacenar referencias
        self.current_fig = fig
        self.current_ax = ax
        self.current_canvas = canvas
        self.original_xlim = ax.get_xlim()
        self.original_ylim = ax.get_ylim()
        
        # Configurar eventos de mouse
        canvas.mpl_connect("scroll_event", self._on_mouse_wheel)
        canvas.mpl_connect("button_press_event", self._on_mouse_press)
        canvas.mpl_connect("button_release_event", self._on_mouse_release)
        canvas.mpl_connect("motion_notify_event", self._on_mouse_motion)
        
    def _zoom_in(self):
        """Aumenta el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        self.zoom_level *= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_out(self):
        """Disminuye el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        self.zoom_level /= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_reset(self):
        """Resetea el zoom a la vista original."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        self.zoom_level = 1.0
        self.current_ax.set_xlim(self.original_xlim)
        self.current_ax.set_ylim(self.original_ylim)
        self.current_canvas.draw()
        self._update_zoom_label()
        self.is_panning = False
        self.pan_start_x = None
        self.pan_start_y = None

    def _apply_zoom(self):
        """Aplica el nivel de zoom actual al gráfico."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        x_center = (self.original_xlim[0] + self.original_xlim[1]) / 2
        y_center = (self.original_ylim[0] + self.original_ylim[1]) / 2
        x_range = (self.original_xlim[1] - self.original_xlim[0]) / self.zoom_level
        y_range = (self.original_ylim[1] - self.original_ylim[0]) / self.zoom_level
        new_xlim = (x_center - x_range/2, x_center + x_range/2)
        new_ylim = (y_center - y_range/2, y_center + y_range/2)
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()

    def _update_zoom_label(self):
        """Actualiza la etiqueta que muestra el nivel de zoom actual."""
        self.label_zoom_level.configure(text=f"{int(self.zoom_level * 100)}%")

    def _on_mouse_wheel(self, event):
        """Maneja el evento de la rueda del mouse para zoom."""
        if self.current_ax is None:
            return
        if event.delta > 0:
            self._zoom_in()
        else:
            self._zoom_out()

    def _on_mouse_press(self, event):
        """Maneja el evento de presionar el botón del mouse para iniciar pan."""
        if self.current_ax is None or event.inaxes != self.current_ax:
            return
        if event.button == 1:
            self.is_panning = True
            self.pan_start_x = event.xdata
            self.pan_start_y = event.ydata
            self.current_canvas.get_tk_widget().configure(cursor="fleur")

    def _on_mouse_release(self, event):
        """Maneja el evento de soltar el botón del mouse para terminar pan."""
        if self.current_ax is None:
            return
        if event.button == 1:
            self.is_panning = False
            self.pan_start_x = None
            self.pan_start_y = None
            self.current_canvas.get_tk_widget().configure(cursor="")

    def _on_mouse_motion(self, event):
        """Maneja el movimiento del mouse para pan."""
        if (self.current_ax is None or not self.is_panning or 
            event.inaxes != self.current_ax or 
            self.pan_start_x is None or self.pan_start_y is None):
            return
        dx = event.xdata - self.pan_start_x
        dy = event.ydata - self.pan_start_y
        xlim = self.current_ax.get_xlim()
        ylim = self.current_ax.get_ylim()
        new_xlim = (xlim[0] - dx, xlim[1] - dx)
        new_ylim = (ylim[0] - dy, ylim[1] - dy)
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()
        self.pan_start_x = event.xdata
        self.pan_start_y = event.ydata

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\data_input_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox, ttk
from utils import historial

class DataInputScreen(ctk.CTkFrame):
    def __init__(self, master, nombres_procesos, on_continue):
        super().__init__(master)
        self.nombres_procesos = nombres_procesos
        self.on_continue = on_continue

        # Estructura de datos para múltiples ráfagas
        self.process_data = {}  # {nombre: {"arrival": int, "bursts": [int, int, ...]}}
        
        self.label_title = ctk.CTkLabel(self, text="Ingresar datos de procesos", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=20)

        # Frame con scroll para muchos procesos
        self.scroll_frame = ctk.CTkScrollableFrame(self, height=400)
        self.scroll_frame.pack(padx=10, pady=10, fill="both", expand=True)

        self._build_rows()

        # Botones de historial
        btn_historial_frame = ctk.CTkFrame(self)
        btn_historial_frame.pack(pady=10)
        
        self.btn_save_config = ctk.CTkButton(btn_historial_frame, text="Guardar configuración", 
                                           command=self._guardar_configuracion, fg_color="blue", hover_color="#003366")
        self.btn_save_config.pack(side="left", padx=5)
        
        self.btn_load_config = ctk.CTkButton(btn_historial_frame, text="Cargar configuración", 
                                           command=self._cargar_configuracion, fg_color="orange", hover_color="#cc6600")
        self.btn_load_config.pack(side="left", padx=5)

        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _build_rows(self):
        for nombre in self.nombres_procesos:
            # Inicializar datos del proceso
            self.process_data[nombre] = {
                "arrival": None,
                "bursts": []
            }
            
            # Frame principal del proceso
            process_frame = ctk.CTkFrame(self.scroll_frame)
            process_frame.pack(pady=10, fill="x", padx=5)
            
            # Título del proceso
            title_frame = ctk.CTkFrame(process_frame)
            title_frame.pack(fill="x", padx=5, pady=5)
            
            ctk.CTkLabel(title_frame, text=f"Proceso: {nombre}", font=("Arial", 14, "bold")).pack(side="left")
            
            # Tiempo de llegada
            arrival_frame = ctk.CTkFrame(process_frame)
            arrival_frame.pack(fill="x", padx=5, pady=2)
            
            ctk.CTkLabel(arrival_frame, text="Tiempo de llegada:", width=120).pack(side="left", padx=5)
            arrival_entry = ctk.CTkEntry(arrival_frame, placeholder_text="Ej: 0", width=80)
            arrival_entry.pack(side="left", padx=5)
            
            # Frame para las ráfagas
            bursts_frame = ctk.CTkFrame(process_frame)
            bursts_frame.pack(fill="x", padx=5, pady=5)
            
            ctk.CTkLabel(bursts_frame, text="Secuencia de ráfagas:", font=("Arial", 12, "bold")).pack(anchor="w", padx=5, pady=2)
            
            # Frame para los controles de ráfagas
            controls_frame = ctk.CTkFrame(bursts_frame)
            controls_frame.pack(fill="x", padx=5, pady=2)
            
            # Botón para agregar ráfaga
            add_btn = ctk.CTkButton(controls_frame, text="+ Agregar ráfaga", width=120, 
                                   command=lambda n=nombre: self._add_burst(n))
            add_btn.pack(side="left", padx=5)
            
            # Frame para mostrar las ráfagas
            bursts_display_frame = ctk.CTkFrame(bursts_frame)
            bursts_display_frame.pack(fill="x", padx=5, pady=5)
            
            # Almacenar referencias para este proceso
            self.process_data[nombre]["arrival_entry"] = arrival_entry
            self.process_data[nombre]["bursts_display_frame"] = bursts_display_frame
            self.process_data[nombre]["burst_entries"] = []
            
            # Agregar primera ráfaga de CPU por defecto
            self._add_burst(nombre, burst_type="CPU")

    def _add_burst(self, process_name, burst_type=None):
        """Agrega una nueva ráfaga al proceso especificado."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        display_frame = process_info["bursts_display_frame"]
        
        # Determinar el tipo de ráfaga si no se especifica
        if burst_type is None:
            # Si no hay ráfagas, empezar con CPU
            if not burst_entries:
                burst_type = "CPU"
            else:
                # Alternar entre CPU y Bloqueo
                last_type = burst_entries[-1]["type"]
                burst_type = "Bloqueo" if last_type == "CPU" else "CPU"
        
        # Frame para esta ráfaga
        burst_frame = ctk.CTkFrame(display_frame)
        burst_frame.pack(fill="x", padx=2, pady=2)
        
        # Tipo de ráfaga
        type_label = ctk.CTkLabel(burst_frame, text=f"{burst_type}:", width=80)
        type_label.pack(side="left", padx=5)
        
        # Campo de entrada
        burst_entry = ctk.CTkEntry(burst_frame, placeholder_text=f"Duración {burst_type}", width=100)
        burst_entry.pack(side="left", padx=5)
        
        # Botón para eliminar
        remove_btn = ctk.CTkButton(burst_frame, text="✕", width=30, height=25,
                                  command=lambda: self._remove_burst(process_name, burst_frame))
        remove_btn.pack(side="left", padx=5)
        
        # Almacenar información de la ráfaga
        burst_info = {
            "frame": burst_frame,
            "entry": burst_entry,
            "type": burst_type
        }
        burst_entries.append(burst_info)
        
        # Actualizar la secuencia visual
        self._update_sequence_display(process_name)
    
    def _remove_burst(self, process_name, burst_frame):
        """Elimina una ráfaga del proceso especificado."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        
        # Encontrar y eliminar la ráfaga
        for i, burst_info in enumerate(burst_entries):
            if burst_info["frame"] == burst_frame:
                burst_entries.pop(i)
                burst_frame.destroy()
                break
        
        # Actualizar la secuencia visual
        self._update_sequence_display(process_name)
    
    def _update_sequence_display(self, process_name):
        """Actualiza la visualización de la secuencia de ráfagas."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        
        # Crear texto descriptivo de la secuencia
        if burst_entries:
            sequence_parts = []
            for i, burst_info in enumerate(burst_entries):
                sequence_parts.append(f"{burst_info['type']}{i+1}")
            sequence_text = " → ".join(sequence_parts)
        else:
            sequence_text = "Sin ráfagas"
        
        # Actualizar o crear label de secuencia
        if "sequence_label" not in process_info:
            sequence_label = ctk.CTkLabel(process_info["bursts_display_frame"], 
                                        text=f"Secuencia: {sequence_text}", 
                                        font=("Arial", 10, "italic"))
            sequence_label.pack(anchor="w", padx=5, pady=2)
            process_info["sequence_label"] = sequence_label
        else:
            process_info["sequence_label"].configure(text=f"Secuencia: {sequence_text}")

    def _continue_clicked(self):
        procesos_data = []
        try:
            for nombre in self.nombres_procesos:
                process_info = self.process_data[nombre]
                
                # Validar tiempo de llegada
                arrival_str = process_info["arrival_entry"].get().strip()
                if not arrival_str:
                    raise ValueError(f"Proceso {nombre}: Tiempo de llegada requerido")
                
                arrival_time = int(arrival_str)
                if arrival_time < 0:
                    raise ValueError(f"Proceso {nombre}: Tiempo de llegada debe ser ≥ 0")
                
                # Validar ráfagas
                burst_entries = process_info["burst_entries"]
                if not burst_entries:
                    raise ValueError(f"Proceso {nombre}: Debe tener al menos una ráfaga")
                
                bursts = []
                for burst_info in burst_entries:
                    duration_str = burst_info["entry"].get().strip()
                    if not duration_str:
                        raise ValueError(f"Proceso {nombre}: Todas las duraciones son requeridas")
                    
                    duration = int(duration_str)
                    if duration < 0:
                        raise ValueError(f"Proceso {nombre}: Las duraciones deben ser ≥ 0")
                    
                    bursts.append(duration)
                
                # Validar que termine con CPU (índice par)
                if len(bursts) % 2 == 0:
                    # Termina con CPU, está bien
                    pass
                else:
                    # Termina con bloqueo, agregar CPU de 0
                    bursts.append(0)
                
                # Validar que tenga al menos una ráfaga de CPU
                cpu_bursts = [bursts[i] for i in range(0, len(bursts), 2)]
                if not any(cpu > 0 for cpu in cpu_bursts):
                    raise ValueError(f"Proceso {nombre}: Debe tener al menos una ráfaga de CPU > 0")
                
                procesos_data.append({
                    "pid": nombre, 
                    "arrival_time": arrival_time, 
                    "bursts": bursts
                })

        except ValueError as e:
            messagebox.showerror("Error de validación", str(e))
            return
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado: {e}")
            return

        self.on_continue(procesos_data)

    def _guardar_configuracion(self):
        """Guarda la configuración actual de inputs."""
        # Crear ventana de diálogo para ingresar nombre de
        dialog = ctk.CTkToplevel(self)
        dialog.title("Guardar configuración")
        dialog.geometry("400x150")
        dialog.transient(self)
        dialog.grab_set()
        
        # Centrar la ventana
        dialog.geometry("+%d+%d" % (self.winfo_rootx() + 50, self.winfo_rooty() + 50))
        
        # Frame principal
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Label y entry para el nombre
        label_nombre = ctk.CTkLabel(main_frame, text="Nombre de la configuración:", font=("Arial", 12))
        label_nombre.pack(pady=(0, 10))
        
        entry_nombre = ctk.CTkEntry(main_frame, placeholder_text="Ej: Configuración 3 procesos", width=300)
        entry_nombre.pack(pady=(0, 20))
        entry_nombre.focus()
        
        # Botones
        btn_frame = ctk.CTkFrame(main_frame)
        btn_frame.pack()
        
        def guardar():
            nombre = entry_nombre.get().strip()
            if not nombre:
                messagebox.showerror("Error", "Debe ingresar un nombre para la configuración")
                return
            
            try:
                # Recopilar datos actuales
                config_procesos = []
                for nombre_proceso in self.nombres_procesos:
                    process_info = self.process_data[nombre_proceso]
                    
                    # Obtener tiempo de llegada
                    arrival_str = process_info["arrival_entry"].get().strip()
                    arrival = int(arrival_str) if arrival_str else 0
                    
                    # Obtener ráfagas
                    bursts = []
                    for burst_info in process_info["burst_entries"]:
                        duration_str = burst_info["entry"].get().strip()
                        duration = int(duration_str) if duration_str else 0
                        bursts.append(duration)
                    
                    config_procesos.append({
                        "nombre": nombre_proceso,
                        "arrival": arrival,
                        "bursts": bursts
                    })
                
                # Guardar en historial
                historial.guardar_input_config(nombre, config_procesos)
                
                messagebox.showinfo("Éxito", f"Configuración '{nombre}' guardada exitosamente")
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Error", "Error en los datos. Asegúrese de que todos los valores sean números válidos.")
            except Exception as e:
                messagebox.showerror("Error", f"Error al guardar la configuración: {e}")
        
        btn_guardar = ctk.CTkButton(btn_frame, text="Guardar", command=guardar, fg_color="green")
        btn_guardar.pack(side="left", padx=5)
        
        btn_cancelar = ctk.CTkButton(btn_frame, text="Cancelar", command=dialog.destroy)
        btn_cancelar.pack(side="left", padx=5)
        
        # Permitir guardar con Enter
        entry_nombre.bind("<Return>", lambda e: guardar())

    def _cargar_configuracion(self):
        """Carga una configuración guardada."""
        # Obtener lista de configuraciones guardadas
        configs = historial.listar_input_configs()
        
        if not configs:
            messagebox.showinfo("Información", "No hay configuraciones guardadas")
            return
        
        # Crear ventana de diálogo para seleccionar configuración
        dialog = ctk.CTkToplevel(self)
        dialog.title("Cargar configuración")
        dialog.geometry("600x400")
        dialog.transient(self)
        dialog.grab_set()
        
        # Centrar la ventana
        dialog.geometry("+%d+%d" % (self.winfo_rootx() + 50, self.winfo_rooty() + 50))
        
        # Frame principal
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Título
        label_titulo = ctk.CTkLabel(main_frame, text="Seleccionar configuración a cargar:", font=("Arial", 14, "bold"))
        label_titulo.pack(pady=(0, 10))
        
        # Frame para la lista
        list_frame = ctk.CTkFrame(main_frame)
        list_frame.pack(fill="both", expand=True, pady=(0, 10))
        
        # Crear Treeview para mostrar las configuraciones
        columns = ("Nombre", "Fecha", "Procesos")
        tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        # Configurar columnas
        tree.heading("Nombre", text="Nombre")
        tree.heading("Fecha", text="Fecha")
        tree.heading("Procesos", text="N° Procesos")
        
        tree.column("Nombre", width=300)
        tree.column("Fecha", width=150)
        tree.column("Procesos", width=100)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        
        # Empaquetar
        tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Llenar la lista
        for indice, nombre, fecha, num_procesos in configs:
            # Formatear fecha para mostrar
            try:
                from datetime import datetime
                dt = datetime.fromisoformat(fecha)
                fecha_formateada = dt.strftime("%d/%m/%Y %H:%M")
            except:
                fecha_formateada = fecha
            
            tree.insert("", "end", values=(nombre, fecha_formateada, num_procesos), tags=(str(indice),))
        
        # Botones
        btn_frame = ctk.CTkFrame(main_frame)
        btn_frame.pack()
        
        def cargar():
            seleccion = tree.selection()
            if not seleccion:
                messagebox.showwarning("Advertencia", "Seleccione una configuración para cargar")
                return
            
            # Obtener el índice de la configuración seleccionada
            item = tree.item(seleccion[0])
            indice = int(item['tags'][0])
            
            try:
                # Cargar la configuración
                config = historial.cargar_input_config(indice)
                if config is None:
                    messagebox.showerror("Error", "No se pudo cargar la configuración seleccionada")
                    return
                
                # Aplicar la configuración
                self._aplicar_configuracion(config)
                
                messagebox.showinfo("Éxito", f"Configuración '{config['nombre']}' cargada exitosamente")
                dialog.destroy()
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al cargar la configuración: {e}")
        
        def eliminar():
            seleccion = tree.selection()
            if not seleccion:
                messagebox.showwarning("Advertencia", "Seleccione una configuración para eliminar")
                return
            
            # Confirmar eliminación
            if not messagebox.askyesno("Confirmar", "¿Está seguro de que desea eliminar esta configuración?"):
                return
            
            # Obtener el índice de la configuración seleccionada
            item = tree.item(seleccion[0])
            indice = int(item['tags'][0])
            
            try:
                # Eliminar la configuración
                nombre_eliminado = historial.eliminar_input_config(indice)
                if nombre_eliminado:
                    # Actualizar la lista
                    tree.delete(seleccion[0])
                    messagebox.showinfo("Éxito", f"Configuración '{nombre_eliminado}' eliminada exitosamente")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al eliminar la configuración: {e}")
        
        btn_cargar = ctk.CTkButton(btn_frame, text="Cargar", command=cargar, fg_color="green")
        btn_cargar.pack(side="left", padx=5)
        
        btn_eliminar = ctk.CTkButton(btn_frame, text="Eliminar", command=eliminar, fg_color="red")
        btn_eliminar.pack(side="left", padx=5)
        
        btn_cancelar = ctk.CTkButton(btn_frame, text="Cancelar", command=dialog.destroy)
        btn_cancelar.pack(side="left", padx=5)

    def _aplicar_configuracion(self, config):
        """Aplica una configuración cargada a los campos de entrada."""
        try:
            # Limpiar todos los campos actuales
            self._limpiar_campos()
            
            # Aplicar los datos de cada proceso
            for proceso_config in config["procesos"]:
                nombre_proceso = proceso_config["nombre"]
                
                if nombre_proceso in self.process_data:
                    process_info = self.process_data[nombre_proceso]
                    
                    # Aplicar tiempo de llegada
                    if proceso_config["arrival"] is not None:
                        process_info["arrival_entry"].delete(0, "end")
                        process_info["arrival_entry"].insert(0, str(proceso_config["arrival"]))
                    
                    # Aplicar ráfagas
                    bursts = proceso_config["bursts"]
                    if bursts:
                        # Limpiar ráfagas existentes
                        for burst_info in process_info["burst_entries"][:]:
                            self._remove_burst(nombre_proceso, burst_info["frame"])
                        
                        # Añadir ráfagas de la configuración
                        for i, duration in enumerate(bursts):
                            # Determinar tipo de ráfaga (alternando CPU y Bloqueo)
                            burst_type = "CPU" if i % 2 == 0 else "Bloqueo"
                            self._add_burst(nombre_proceso, burst_type)
                            
                            # Establecer el valor
                            if process_info["burst_entries"]:
                                last_burst = process_info["burst_entries"][-1]
                                last_burst["entry"].delete(0, "end")
                                last_burst["entry"].insert(0, str(duration))
                        
        except Exception as e:
            messagebox.showerror("Error", f"Error al aplicar la configuración: {e}")

    def _limpiar_campos(self):
        """Limpia todos los campos de entrada."""
        for nombre_proceso in self.nombres_procesos:
            if nombre_proceso in self.process_data:
                process_info = self.process_data[nombre_proceso]
                
                # Limpiar tiempo de llegada
                process_info["arrival_entry"].delete(0, "end")
                
                # Limpiar ráfagas
                for burst_info in process_info["burst_entries"][:]:
                    self._remove_burst(nombre_proceso, burst_info["frame"])


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\name_input_screen.py

...-------------------...
# gui/name_input_screen.py

import customtkinter as ctk
from tkinter import messagebox

class NameInputScreen(ctk.CTkFrame):
    def __init__(self, master, cantidad_procesos, on_continue):
        """
        Pantalla para ingresar los nombres de los procesos.

        :param master: ventana o frame padre
        :param cantidad_procesos: número de procesos a crear
        :param on_continue: función que recibe la lista de nombres y avanza a la siguiente pantalla
        """
        super().__init__(master)
        self.cantidad_procesos = cantidad_procesos
        self.on_continue = on_continue
        self.entries = []

        # Título
        self.label_title = ctk.CTkLabel(self, text="Asignar nombres a los procesos", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=20)

        # Campos dinámicos
        for i in range(cantidad_procesos):
            frame = ctk.CTkFrame(self)
            frame.pack(pady=5, padx=10, fill="x")

            label = ctk.CTkLabel(frame, text=f"Proceso {i+1}:")
            label.pack(side="left", padx=5)

            entry = ctk.CTkEntry(frame, placeholder_text=f"P{i+1}")
            entry.pack(side="left", padx=5, fill="x", expand=True)
            self.entries.append(entry)

        # Botón continuar
        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _continue_clicked(self):
        """Valida y envía la lista de nombres."""
        nombres = []
        for i, entry in enumerate(self.entries):
            nombre = entry.get().strip()
            if not nombre:
                nombre = f"P{i+1}"  # Si está vacío, asigna nombre por defecto
            nombres.append(nombre)

        # Validar que no haya nombres repetidos
        if len(nombres) != len(set(nombres)):
            messagebox.showerror("Error", "Los nombres de los procesos deben ser únicos.")
            return

        self.on_continue(nombres)


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\start_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox

class StartScreen(ctk.CTkFrame):
    def __init__(self, master, on_continue):
        """
        Pantalla inicial para ingresar la cantidad de procesos.

        :param master: ventana o frame padre
        :param on_continue: función que recibe la cantidad de procesos y avanza a la siguiente pantalla
        """
        super().__init__(master)
        self.on_continue = on_continue

        # Título
        self.label_title = ctk.CTkLabel(self, text="Planificación de CPU", font=("Arial", 20, "bold"))
        self.label_title.pack(pady=20)

        # Instrucción
        self.label_instruction = ctk.CTkLabel(self, text="Ingrese la cantidad de procesos:")
        self.label_instruction.pack(pady=10)

        # Campo de entrada
        self.entry_count = ctk.CTkEntry(self, placeholder_text="Ej: 4")
        self.entry_count.pack(pady=10)

        # Botón continuar
        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _continue_clicked(self):
        """Valida la entrada y llama a la función on_continue."""
        try:
            n = int(self.entry_count.get())
            if n <= 0:
                raise ValueError
            self.on_continue(n)
        except ValueError:
            messagebox.showerror("Error", "Ingrese un número válido mayor a 0")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\models\process.py

...-------------------...
# GanddOperativos/models/process.py
class Process:
    def __init__(self, pid, arrival_time, bursts):
        """
        Representa un proceso con ráfagas de CPU y bloqueos (E/S).

        :param pid: Identificador del proceso (str o int)
        :param arrival_time: Tiempo de llegada inicial al sistema
        :param bursts: Lista de enteros, índices pares = CPU, impares = bloqueo
                       Ej: [3, 2, 5] => CPU 3, Bloqueo 2, CPU 5
        """
        self.pid = pid
        self.arrival_time = arrival_time
        self.bursts = bursts[:]              # copia viva (puede mutar en algoritmos)
        self.bursts_original = bursts[:]     # copia inmutable para métricas
        self.current_burst_index = 0
        self.remaining_time = bursts[0] if bursts else 0

        # Métricas
        self.start_time = None
        self.completion_time = None
        self.turnaround_time = None  # TR
        self.waiting_time = None     # TE

        # Estado de planificación
        self.ready_since = None      # cuándo quedó en ready por última vez

    # ---------- Utilidades de estado ----------
    def is_cpu_burst(self):
        """True si la ráfaga actual es de CPU (índice par)."""
        return self.current_burst_index % 2 == 0

    def is_finished(self):
        """True si el proceso ha terminado todas sus ráfagas."""
        return self.current_burst_index >= len(self.bursts)

    def advance_burst(self):
        """Avanza a la siguiente ráfaga."""
        self.current_burst_index += 1
        if self.current_burst_index < len(self.bursts):
            self.remaining_time = self.bursts[self.current_burst_index]
        else:
            self.remaining_time = 0

    def get_remaining_bursts(self):
        """Retorna las ráfagas restantes del proceso (desde el índice actual)."""
        return self.bursts[self.current_burst_index:] if self.current_burst_index < len(self.bursts) else []

    def get_burst_sequence_description(self):
        """Retorna una descripción legible de la secuencia de ráfagas."""
        if not self.bursts:
            return "Sin ráfagas"
        sequence = []
        for i, duration in enumerate(self.bursts):
            burst_type = "CPU" if i % 2 == 0 else "Bloqueo"
            sequence.append(f"{burst_type}({duration})")
        return " → ".join(sequence)

    # ---------- Cálculos de prioridad / apoyo a algoritmos ----------
    def get_total_cpu_remaining(self):
        """
        Retorna el total de CPU restante desde la posición actual.
        Si está en bloqueo (índice impar), comienza desde la próxima CPU.
        Considera la lista 'bursts' viva (por si un algoritmo preemptivo descuenta).
        """
        idx = self.current_burst_index
        if idx >= len(self.bursts):
            return 0
        start = idx if idx % 2 == 0 else idx + 1
        total = 0
        for i in range(start, len(self.bursts), 2):  # sólo índices de CPU
            dur = self.bursts[i]
            if dur < 0:
                dur = 0
            total += dur
        return total

    # ---------- Métricas (siempre contra los datos originales) ----------
    def calculate_metrics(self):
        """
        Calcula TR (turnaround time) y TE (waiting time).
        TR = completion_time - arrival_time
        TE = TR - tiempo total de CPU - tiempo total de bloqueos
        Se usa 'bursts_original' para evitar sesgos si un algoritmo mutó 'bursts'.
        """
        if self.completion_time is None:
            raise ValueError(f"No se puede calcular métricas: {self.pid} no tiene completion_time asignado.")

        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts

        # Tiempo total en el sistema
        self.turnaround_time = self.completion_time - self.arrival_time

        # Suma de todas las ráfagas de CPU (índices pares)
        total_cpu = sum(source[i] for i in range(0, len(source), 2))

        # Suma de todas las ráfagas de bloqueo/E/S (índices impares)
        total_bloq = sum(source[i] for i in range(1, len(source), 2))

        # Tiempo de espera real en cola de listos
        self.waiting_time = self.turnaround_time - total_cpu - total_bloq

    # ---------- Agregados informativos ----------
    def get_total_cpu_time(self):
        """Retorna el tiempo total de CPU del proceso (sobre datos originales si están disponibles)."""
        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts
        return sum(source[i] for i in range(0, len(source), 2))

    def get_total_blocking_time(self):
        """Retorna el tiempo total de bloqueo del proceso (sobre datos originales si están disponibles)."""
        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts
        return sum(source[i] for i in range(1, len(source), 2))

    def get_burst_count(self):
        """Retorna el número total de ráfagas (CPU + bloqueos)."""
        return len(self.bursts)

    def get_cpu_burst_count(self):
        """Retorna el número de ráfagas de CPU."""
        return len([i for i in range(0, len(self.bursts), 2)])

    def get_blocking_burst_count(self):
        """Retorna el número de ráfagas de bloqueo."""
        return len([i for i in range(1, len(self.bursts), 2)])

    def __repr__(self):
        return (f"Process(pid={self.pid}, arrival={self.arrival_time}, bursts={self.bursts}, "
                f"idx={self.current_burst_index}, start={self.start_time}, completion={self.completion_time}, "
                f"TR={self.turnaround_time}, TE={self.waiting_time})")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\models\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\excel_export.py

...-------------------...
import pandas as pd
import openpyxl
from openpyxl import Workbook
from openpyxl.chart import BarChart, Reference
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.drawing.image import Image
import os
import io
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from datetime import datetime

def exportar_a_excel(procesos_data, algoritmo, gantt_data, metricas, trm, tem, quantum=None):
    """
    Exporta los resultados a un archivo Excel con gráfico de Gantt PNG.
    
    Args:
        procesos_data: Lista de procesos originales
        algoritmo: Nombre del algoritmo usado
        gantt_data: Datos del gráfico de Gantt
        metricas: Lista de métricas calculadas
        trm: Tiempo de respuesta medio
        tem: Tiempo de espera medio
        quantum: Quantum usado (opcional)
    """
    
    # Crear workbook
    wb = Workbook()
    
    # Eliminar hoja por defecto
    wb.remove(wb.active)
    
    # Crear hojas
    ws_metricas = wb.create_sheet("Métricas")
    ws_gantt = wb.create_sheet("Gráfico Gantt")
    ws_datos = wb.create_sheet("Datos Originales")
    
    # === HOJA DE MÉTRICAS ===
    _crear_hoja_metricas(ws_metricas, metricas, trm, tem, algoritmo, quantum)
    
    # === HOJA DE GRÁFICO GANTT ===
    _crear_hoja_gantt_con_imagen(ws_gantt, gantt_data, algoritmo)
    
    # === HOJA DE DATOS ORIGINALES ===
    _crear_hoja_datos_originales(ws_datos, procesos_data)
    
    # Generar nombre de archivo
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"resultados_{algoritmo}_{timestamp}.xlsx"
    
    # Guardar archivo
    filepath = os.path.join(os.path.dirname(__file__), filename)
    wb.save(filepath)
    
    return filepath

def _crear_hoja_metricas(ws, metricas, trm, tem, algoritmo, quantum):
    """Crea la hoja de métricas."""
    ws.title = "Métricas"
    
    # Título
    ws['A1'] = f"Resultados - Algoritmo {algoritmo}"
    ws['A1'].font = Font(size=16, bold=True)
    
    if quantum:
        ws['A2'] = f"Quantum: {quantum}"
        ws['A2'].font = Font(size=12, italic=True)
    
    # Métricas generales
    ws['A4'] = "MÉTRICAS GENERALES"
    ws['A4'].font = Font(size=14, bold=True)
    ws['A4'].fill = PatternFill(start_color="E6E6FA", end_color="E6E6FA", fill_type="solid")
    
    ws['A5'] = "TRM (Tiempo de Respuesta Medio):"
    ws['B5'] = trm
    ws['A6'] = "TEM (Tiempo de Espera Medio):"
    ws['B6'] = tem
    
    # Tabla de métricas por proceso
    ws['A8'] = "MÉTRICAS POR PROCESO"
    ws['A8'].font = Font(size=14, bold=True)
    ws['A8'].fill = PatternFill(start_color="E6E6FA", end_color="E6E6FA", fill_type="solid")
    
    # Encabezados
    headers = ["PID", "Tiempo de Llegada", "Tiempo de CPU", "Tiempo de Respuesta", "Tiempo de Espera"]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=9, column=col, value=header)
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
        cell.alignment = Alignment(horizontal="center")
    
    # Datos
    for row, metrica in enumerate(metricas, 10):
        ws.cell(row=row, column=1, value=metrica["PID"])
        ws.cell(row=row, column=2, value=metrica["Llegada"])
        ws.cell(row=row, column=3, value=metrica["CPU"])
        ws.cell(row=row, column=4, value=metrica["TR"])
        ws.cell(row=row, column=5, value=metrica["TE"])
        
        # Formatear números
        for col in [2, 3, 4, 5]:
            ws.cell(row=row, column=col).number_format = "0.00"
    
    # Ajustar ancho de columnas
    for col in ['A', 'B', 'C', 'D', 'E']:
        ws.column_dimensions[col].width = 15

def _crear_hoja_gantt_con_imagen(ws, gantt_data, algoritmo):
    """Crea la hoja con gráfico de Gantt como imagen PNG."""
    ws.title = "Gráfico Gantt"
    
    # Procesar datos de Gantt
    procesos_unicos = []
    gantt_procesado = []
    
    for segmento in gantt_data:
        if len(segmento) == 3:
            pid, start, end = segmento
            tipo = "CPU" if pid != "IDLE" else "IDLE"
        elif len(segmento) == 4:
            pid, start, end, tipo = segmento
        else:
            continue
            
        if pid != "IDLE" and pid not in procesos_unicos:
            procesos_unicos.append(pid)
            
        gantt_procesado.append({
            "PID": pid,
            "Inicio": start,
            "Fin": end,
            "Duración": end - start,
            "Tipo": tipo
        })
    
    # Crear DataFrame
    df_gantt = pd.DataFrame(gantt_procesado)
    
    # Escribir datos
    for r in dataframe_to_rows(df_gantt, index=False, header=True):
        ws.append(r)
    
    # Formatear encabezados
    for cell in ws[1]:
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
        cell.alignment = Alignment(horizontal="center")
    
    # Generar gráfico de Gantt como imagen
    _generar_gantt_png(ws, gantt_procesado, algoritmo)

def _generar_gantt_png(ws, gantt_procesado, algoritmo):
    """Genera un gráfico de Gantt como imagen PNG replicando exactamente la lógica del programa original."""
    if not gantt_procesado:
        return
    
    # Normalizar datos igual que en el programa original
    norm = []
    for segmento in gantt_procesado:
        pid = segmento['PID']
        start = segmento['Inicio']
        end = segmento['Fin']
        tipo = segmento['Tipo']
        
        # Convertir tipo a formato del programa original
        if tipo == "Bloqueo":
            tipo = "BLOCK"
        elif tipo == "CPU":
            tipo = "CPU"
        elif pid == "IDLE":
            tipo = "IDLE"
            
        norm.append((pid, start, end, tipo))
    
    # Obtener procesos únicos (excluir IDLE) - igual que el programa original
    procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
    procesos_unicos = list(dict.fromkeys(procesos_unicos))  # Mantener orden
    
    if not procesos_unicos:
        return
    
    # Calcular dimensiones adaptativas - igual que el programa original
    num_procesos = len(procesos_unicos)
    max_time = max(end for _, _, end, _ in norm) if norm else 1
    
    fig_width = max(15, max_time * 0.25)  # Ancho basado en duración total
    fig_height = max(4, num_procesos * 0.8)  # Altura basada en número de procesos
    
    # Crear figura con las mismas dimensiones
    fig, ax = plt.subplots(figsize=(fig_width, fig_height))
    
    # Posiciones Y para cada proceso - igual que el programa original
    y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}
    
    # Colores - usar la misma paleta que el programa original
    colors = {}
    color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)
    
    # Dibujar barras - replicar exactamente la lógica del programa original
    for pid, start, end, tipo in norm:
        if tipo == "IDLE":
            color = "lightgray"
            hatch = None
            y = -1
            alpha = 0.7
        elif tipo == "BLOCK":
            color = "darkred"
            hatch = "///"
            y = y_positions.get(pid, 0)
            alpha = 0.8
        else:  # CPU
            if pid not in colors:
                colors[pid] = color_palette(len(colors))
            color = colors[pid]
            hatch = None
            y = y_positions.get(pid, 0)
            alpha = 1.0
        
        # Dibujar barra horizontal - mismo estilo que el programa original
        ax.barh(y, end - start, left=start, height=0.6, color=color, 
               edgecolor='black', hatch=hatch, alpha=alpha)
        
        if tipo != "IDLE":
            # Mostrar el PID y el tipo de ráfaga - mismo formato que el programa original
            text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
            ax.text((start + end) / 2, y, text, ha='center', va='center',
                    fontsize=7, color="white" if tipo == "BLOCK" else "black",
                    weight="bold" if tipo == "BLOCK" else "normal")
    
    # Configurar ejes - igual que el programa original
    if procesos_unicos:
        ax.set_yticks(list(y_positions.values()))
        ax.set_yticklabels(list(y_positions.keys()))
    else:
        ax.set_yticks([])
    
    if norm:
        max_time = max(end for _, _, end, _ in norm)
        # Mostrar TODOS los ticks del 0 al tiempo máximo - igual que el programa original
        ax.set_xticks(range(0, max_time + 1))
        ax.set_xlim(0, max_time)
    
    ax.set_xlabel("Tiempo")
    ax.set_ylabel("Procesos")
    ax.set_title(f"Diagrama de Gantt - {algoritmo}")
    ax.grid(True, axis='x', linestyle='--', alpha=0.6)
    
    # Leyenda explicativa - igual que el programa original
    legend_elements = [
        plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
        plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
        plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
    ]
    ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))
    
    # Ajustar layout
    plt.tight_layout()
    
    # Guardar imagen en memoria
    img_buffer = io.BytesIO()
    plt.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
    img_buffer.seek(0)
    
    # Insertar imagen en Excel
    img = Image(img_buffer)
    img.width = 800  # Ancho más grande para mejor visualización
    img.height = 400  # Alto más grande
    
    # Posicionar imagen debajo de los datos
    ws.add_image(img, 'A8')
    
    # Cerrar figura para liberar memoria
    plt.close(fig)

def _crear_hoja_datos_originales(ws, procesos_data):
    """Crea la hoja con los datos originales de entrada."""
    ws.title = "Datos Originales"
    
    # Título
    ws['A1'] = "Datos Originales de los Procesos"
    ws['A1'].font = Font(size=16, bold=True)
    
    # Encabezados
    headers = ["PID", "Tiempo de Llegada", "Secuencia de Ráfagas"]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=3, column=col, value=header)
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
        cell.alignment = Alignment(horizontal="center")
    
    # Datos
    for row, proceso in enumerate(procesos_data, 4):
        ws.cell(row=row, column=1, value=proceso["pid"])
        ws.cell(row=row, column=2, value=proceso["arrival_time"])
        
        # Formatear ráfagas como texto
        bursts_text = " -> ".join([f"{'CPU' if i%2==0 else 'E/S'}: {burst}" 
                                  for i, burst in enumerate(proceso["bursts"])])
        ws.cell(row=row, column=3, value=bursts_text)
    
    # Ajustar ancho de columnas
    ws.column_dimensions['A'].width = 10
    ws.column_dimensions['B'].width = 15
    ws.column_dimensions['C'].width = 50


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\gantt.py

...-------------------...
# utils/gantt.py

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

def plot_gantt(gantt_chart, title="Diagrama de Gantt"):
    """
    Genera un diagrama de Gantt con cada proceso en su propia fila.

    :param gantt_chart: lista de tuplas (pid, start, end)
                        Ej: [("P1", 0, 5), ("P2", 5, 8), ("IDLE", 8, 10)]
    :param title: título del gráfico
    """
    # Obtener lista única de procesos (excluyendo IDLE)
    procesos_unicos = [pid for pid, _, _ in gantt_chart if pid != "IDLE"]
    procesos_unicos = list(dict.fromkeys(procesos_unicos))  # Mantener orden

    # Asignar un índice Y a cada proceso
    y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

    # Colores
    colors = {}
    color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

    fig, ax = plt.subplots(figsize=(10, len(procesos_unicos) * 0.8))

    for i, (pid, start, end) in enumerate(gantt_chart):
        if pid not in colors:
            if pid == "IDLE":
                colors[pid] = "lightgray"
            else:
                colors[pid] = color_palette(len(colors))

        # Si es IDLE, lo ponemos en una fila especial o en la fila del proceso anterior
        y = y_positions.get(pid, -1)  # -1 si es IDLE

        ax.barh(y, end - start, left=start, height=0.5,
                align='center', color=colors[pid], edgecolor='black')

        # Etiqueta centrada
        ax.text((start + end) / 2, y, pid,
                ha='center', va='center', color='black', fontsize=9)

    # Configuración del eje Y
    ax.set_yticks(list(y_positions.values()))
    ax.set_yticklabels(list(y_positions.keys()))

    # Configuración del eje X: mostrar todos los ticks
    max_time = max(end for _, _, end in gantt_chart)
    ax.set_xticks(range(0, max_time + 1))
    ax.set_xlim(0, max_time)

    # Cuadrícula
    ax.grid(True, axis='x', linestyle='--', alpha=0.6)

    # Etiquetas y título
    ax.set_xlabel("Tiempo")
    ax.set_ylabel("Procesos")
    ax.set_title(title)

    # Leyenda
    legend_patches = [mpatches.Patch(color=col, label=pid) for pid, col in colors.items()]
    ax.legend(handles=legend_patches, bbox_to_anchor=(1.05, 1), loc='upper left')

    plt.tight_layout()
    plt.show()


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\historial.py

...-------------------...
import json
import os
from datetime import datetime

HISTORIAL_FILE = os.path.join(os.path.dirname(__file__), "historial.json")

def _leer_historial():
    if os.path.exists(HISTORIAL_FILE):
        with open(HISTORIAL_FILE, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return []
    return []

def _guardar_historial(data):
    with open(HISTORIAL_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def guardar_ejercicio(nombre, procesos, algoritmo, quantum=None):
    """
    Guarda un ejercicio en el historial.
    procesos: lista de dicts con {"pid":..., "arrival_time":..., "bursts": [...]}
    """
    historial = _leer_historial()
    entrada = {
        "nombre": nombre,
        "fecha": datetime.now().isoformat(timespec="seconds"),
        "algoritmo": algoritmo,
        "quantum": quantum,
        "procesos": procesos
    }
    historial.append(entrada)
    _guardar_historial(historial)

def listar_historial():
    """Devuelve una lista de (indice, nombre, fecha, algoritmo) para mostrar en la GUI."""
    historial = _leer_historial()
    return [(i, h["nombre"], h["fecha"], h["algoritmo"]) for i, h in enumerate(historial)]

def cargar_ejercicio(indice):
    """Devuelve el ejercicio guardado en la posición 'indice'."""
    historial = _leer_historial()
    if 0 <= indice < len(historial):
        return historial[indice]
    return None

# ===== FUNCIONES PARA INPUTS DE DATOS =====

INPUT_HISTORIAL_FILE = os.path.join(os.path.dirname(__file__), "input_historial.json")

def _leer_input_historial():
    """Lee el historial de inputs desde el archivo JSON."""
    if os.path.exists(INPUT_HISTORIAL_FILE):
        with open(INPUT_HISTORIAL_FILE, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return []
    return []

def _guardar_input_historial(data):
    """Guarda el historial de inputs en el archivo JSON.""" #a partir de esto se puede cargar luego.
    with open(INPUT_HISTORIAL_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def guardar_input_config(nombre, procesos_config):
    """
    Guarda una configuración de inputs en el historial.
    procesos_config: lista de dicts con {"nombre": str, "arrival": int, "bursts": [int, ...]}
    """
    historial = _leer_input_historial()
    entrada = {
        "nombre": nombre,
        "fecha": datetime.now().isoformat(timespec="seconds"),
        "procesos": procesos_config
    }
    historial.append(entrada)
    _guardar_input_historial(historial)

def listar_input_configs():
    """Devuelve una lista de (indice, nombre, fecha, num_procesos) para mostrar en la GUI."""
    historial = _leer_input_historial()
    return [(i, h["nombre"], h["fecha"], len(h["procesos"])) for i, h in enumerate(historial)]

def cargar_input_config(indice):
    """Devuelve la configuración de inputs guardada en la posición 'indice'."""
    historial = _leer_input_historial()
    if 0 <= indice < len(historial):
        return historial[indice]
    return None

def eliminar_input_config(indice):
    """Elimina una configuración de inputs del historial."""
    historial = _leer_input_historial()
    if 0 <= indice < len(historial):
        nombre_eliminado = historial[indice]["nombre"]
        del historial[indice]
        _guardar_input_historial(historial)
        return nombre_eliminado
    return None

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\input_historial.json

...-------------------...
[
    {
        "nombre": "Punto 1 GUIA 2 JAVI",
        "fecha": "2025-09-13T16:54:00",
        "procesos": [
            {
                "nombre": "P1",
                "arrival": 0,
                "bursts": [
                    2,
                    5,
                    13
                ]
            },
            {
                "nombre": "P2",
                "arrival": 0,
                "bursts": [
                    9,
                    3,
                    5,
                    5,
                    4
                ]
            },
            {
                "nombre": "P3",
                "arrival": 1,
                "bursts": [
                    5
                ]
            },
            {
                "nombre": "P4",
                "arrival": 1,
                "bursts": [
                    4,
                    6,
                    5
                ]
            },
            {
                "nombre": "P5",
                "arrival": 2,
                "bursts": [
                    5,
                    5,
                    5,
                    5,
                    5
                ]
            },
            {
                "nombre": "P6",
                "arrival": 2,
                "bursts": [
                    3
                ]
            },
            {
                "nombre": "P7",
                "arrival": 4,
                "bursts": [
                    5
                ]
            },
            {
                "nombre": "P8",
                "arrival": 6,
                "bursts": [
                    5,
                    2,
                    5
                ]
            },
            {
                "nombre": "P9",
                "arrival": 8,
                "bursts": [
                    5
                ]
            },
            {
                "nombre": "P10",
                "arrival": 8,
                "bursts": [
                    5,
                    4,
                    5
                ]
            }
        ]
    },
    {
        "nombre": "Punto 3 GUIA 2",
        "fecha": "2025-09-15T03:07:25",
        "procesos": [
            {
                "nombre": "P1",
                "arrival": 0,
                "bursts": [
                    5,
                    22,
                    5
                ]
            },
            {
                "nombre": "P2",
                "arrival": 0,
                "bursts": [
                    2,
                    10,
                    9
                ]
            },
            {
                "nombre": "P3",
                "arrival": 0,
                "bursts": [
                    6,
                    101,
                    5,
                    10,
                    1
                ]
            },
            {
                "nombre": "P4",
                "arrival": 0,
                "bursts": [
                    7,
                    61,
                    8
                ]
            },
            {
                "nombre": "P5",
                "arrival": 1,
                "bursts": [
                    13
                ]
            },
            {
                "nombre": "P6",
                "arrival": 2,
                "bursts": [
                    9,
                    252,
                    8
                ]
            }
        ]
    }
]

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\metricas.py

...-------------------...
def calcular_metricas(procesos):
    lista_metricas = []
    total_tr = 0
    total_te = 0

    for p in procesos:
        # Asegurarnos de que las métricas estén calculadas
        if p.turnaround_time is None or p.waiting_time is None:
            p.calculate_metrics()

        # Usar bursts_original si existe, si no, usar bursts actual
        bursts_fuente = getattr(p, "bursts_original", p.bursts)

        # Suma de todas las ráfagas de CPU (índices pares)
        total_cpu = sum(bursts_fuente[i] for i in range(0, len(bursts_fuente), 2))

        lista_metricas.append({
            "PID": p.pid,
            "Llegada": p.arrival_time,
            "CPU": total_cpu,
            "Finalización": p.completion_time,
            "TR": p.turnaround_time,
            "TE": p.waiting_time
        })

        total_tr += p.turnaround_time
        total_te += p.waiting_time

    trm = total_tr / len(procesos) if procesos else 0
    tem = total_te / len(procesos) if procesos else 0

    return lista_metricas, trm, tem



def imprimir_tabla_metricas(metricas, trm, tem):
    """
    Imprime la tabla de métricas en consola.
    """
    print(f"{'PID':<6}{'Llegada':<10}{'CPU':<8}{'Finalización':<14}{'TR':<8}{'TE':<8}")
    for m in metricas:
        print(f"{m['PID']:<6}{m['Llegada']:<10}{m['CPU']:<8}{m['Finalización']:<14}{m['TR']:<8}{m['TE']:<8}")
    print("\n📈 Promedios:")
    print(f"TRM (Tiempo de Respuesta Medio): {trm:.2f}")
    print(f"TEM (Tiempo de Espera Medio): {tem:.2f}")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\parsers.py

...-------------------...
# utils/parsers.py

def parse_bursts(input_str):
    """
    Convierte una cadena como '3,(2),5' en [3, 2, 5].
    Los números entre paréntesis se interpretan como bloqueos (E/S).
    """
    bursts = []
    # Eliminamos espacios y separamos por comas
    parts = input_str.replace(" ", "").split(",")
    for part in parts:
        if part.startswith("(") and part.endswith(")"):
            # Bloqueo
            val = int(part.strip("()"))
            bursts.append(val)
        else:
            # CPU
            bursts.append(int(part))
    return bursts


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\__init__.py

...-------------------...


...-------------------...
