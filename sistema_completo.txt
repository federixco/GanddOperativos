
...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\generar_sistema_txt.py

...-------------------...

import os

def generar_documento_txt(ruta_base: str, archivo_salida: str):
    """
    Recorre recursivamente la ruta base y, para cada archivo con extensión .py o .json,
    escribe su contenido en el archivo de salida, separando cada módulo con un separador.

    Args:
        ruta_base (str): Directorio base desde donde comenzar la búsqueda.
        archivo_salida (str): Nombre del archivo TXT a generar.
    """
    separador = "\n...-------------------...\n"
    with open(archivo_salida, "w", encoding="utf-8") as out_file:
        for root, dirs, files in os.walk(ruta_base):
            for archivo in files:
                if archivo.endswith(".py") or archivo.endswith(".json"):
                    ruta_archivo = os.path.join(root, archivo)
                    # Escribe el encabezado del archivo
                    out_file.write(separador)
                    out_file.write(f"Archivo: {ruta_archivo}\n")
                    out_file.write(separador)
                    try:
                        with open(ruta_archivo, "r", encoding="utf-8") as in_file:
                            contenido = in_file.read()
                        out_file.write(contenido)
                    except Exception as e:
                        out_file.write(f"Error al leer el archivo: {e}")
                    out_file.write("\n")
        out_file.write(separador)
    print(f"Documento generado en: {archivo_salida}")

if __name__ == "__main__":
    # Si el script se encuentra al mismo nivel que main.py,
    # establecemos la ruta base como el directorio actual.
    ruta_base = os.path.dirname(os.path.realpath(__file__))
    generar_documento_txt(ruta_base, "sistema_completo.txt")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\main.py

...-------------------...
import customtkinter as ctk
from GUI.start_screen import StartScreen
from GUI.name_input_screen import NameInputScreen
from GUI.data_input_screen import DataInputScreen
from GUI.algorithm_screen import AlgorithmScreen

# --- Funciones de navegación entre pantallas ---

def ir_a_nombres(cantidad):
    limpiar_ventana()
    name_screen = NameInputScreen(root, cantidad, ir_a_tiempos)
    name_screen.pack(fill="both", expand=True)

def ir_a_tiempos(nombres):
    limpiar_ventana()
    data_screen = DataInputScreen(root, nombres, ir_a_algoritmo)
    data_screen.pack(fill="both", expand=True)

def ir_a_algoritmo(procesos_data):
    limpiar_ventana()
    algo_screen = AlgorithmScreen(root, procesos_data, volver_inicio)
    algo_screen.pack(fill="both", expand=True)

def volver_inicio():
    limpiar_ventana()
    start_screen = StartScreen(root, ir_a_nombres)
    start_screen.pack(fill="both", expand=True)

def limpiar_ventana():
    """Elimina todos los widgets de la ventana principal."""
    for widget in root.winfo_children():
        widget.destroy()

# --- Configuración inicial de la app ---
if __name__ == "__main__":
    ctk.set_appearance_mode("dark")  # Modo oscuro
    ctk.set_default_color_theme("blue")  # Tema azul

    root = ctk.CTk()
    root.title("TimeSlice - Simulador de Planificación de CPU")
    root.geometry("800x600")

    # Pantalla inicial
    start_screen = StartScreen(root, ir_a_nombres)
    start_screen.pack(fill="both", expand=True)

    root.mainloop()


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\fifo.py

...-------------------...
from copy import deepcopy

def fifo(process_list):
    """
    ALGORITMO FIFO (First In, First Out) - NO EXPULSIVO SIN BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en el orden de llegada (FIFO)
    - Una vez que un proceso comienza a ejecutarse, no puede ser interrumpido
    - No hay bloqueos de E/S, solo ráfagas de CPU
    - Cada proceso tiene una sola ráfaga de CPU que se ejecuta completamente
    
    CARACTERÍSTICAS:
    - No expulsivo: no hay preempción
    - Sin bloqueos: no hay operaciones de E/S
    - Simple y justo: el primero en llegar es el primero en ejecutarse
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU]
    
    RETORNA:
    - gantt: Lista de tuplas (pid, start, end) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt = []  # Lista para almacenar el diagrama de Gantt
    ready = []  # Cola de procesos listos para ejecutar (FIFO)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar

    # Ordenar procesos por tiempo de llegada para consistencia
    # Esto asegura que si hay empates en llegada, se mantenga un orden predecible
    processes.sort(key=lambda p: p.arrival_time)

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: ENCOLAR LLEGADAS
        # Revisar todos los procesos para ver cuáles han llegado al tiempo actual
        for p in processes:
            # Verificar si el proceso cumple todas las condiciones para ser encolado:
            # - No ha empezado a ejecutarse (start_time is None)
            # - Ya llegó al sistema (arrival_time <= time)
            # - No está ya en la cola de listos
            # - No ha terminado (completion_time is None)
            if p.start_time is None and p.arrival_time <= time and p not in ready and p.completion_time is None:
                ready.append(p)  # Agregar a la cola de listos (al final de la cola)

        # FASE 2: EJECUTAR PROCESO
        if ready:  # Si hay procesos listos para ejecutar
            
            # Seleccionar proceso: FIFO = First In, First Out
            current = ready.pop(0)  # Tomar el primero de la cola (el que llegó primero)
            
            # Marcar tiempo de inicio si es la primera vez que se ejecuta
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # Marcar tiempo de inicio del proceso

            # Ejecutar el proceso completamente (FIFO es no expulsivo)
            start = time  # Guardar tiempo de inicio de esta ejecución
            cpu = current.remaining_time  # Tiempo de CPU restante (equivale a bursts[0])
            time += cpu  # Avanzar el reloj del sistema por el tiempo de CPU completo
            gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

            # Marcar proceso como completado
            current.completion_time = time  # Marcar tiempo de finalización
            current.calculate_metrics()  # Calcular métricas del proceso (TR, TE, etc.)
            completed += 1  # Incrementar contador de procesos completados
            
        else:
            # No hay procesos listos: CPU ociosa
            # Avanzar 1 unidad de tiempo y reintentar en la siguiente iteración
            time += 1

    # Retornar resultados de la simulación
    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\fifo_blocking.py

...-------------------...
# NO TOCAR MAS YA FUNCIONA BIEN 
from copy import deepcopy

def fifo_blocking(process_list):
    """
    ALGORITMO FIFO (First In, First Out) - NO EXPULSIVO CON BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en el orden de llegada (FIFO)
    - Una vez que un proceso comienza a ejecutarse, no puede ser interrumpido
    - Los procesos pueden tener múltiples ráfagas de CPU y E/S (bloqueos)
    - Cuando un proceso termina una ráfaga de CPU, puede ir a bloqueo o continuar con otra CPU
    - Cuando un proceso termina un bloqueo, regresa a la cola de listos
    - Se respeta la prioridad: procesos que terminan CPU tienen prioridad sobre los que salen de bloqueo
    
    CARACTERÍSTICAS:
    - No expulsivo: no hay preempción una vez que comienza la ejecución
    - Con bloqueos: maneja operaciones de E/S (Entrada/Salida)
    - Simple y justo: el primero en llegar es el primero en ejecutarse
    - Maneja múltiples ráfagas: CPU → E/S → CPU → E/S → ...
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU, E/S, CPU, E/S, ...]
    
    RETORNA:
    - gantt_chart: Lista de tuplas (pid, start, end, tipo) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt
    ready_queue = []  # Cola de procesos listos para ejecutar (FIFO)
    blocked_queue = []  # Cola de procesos bloqueados: (proceso, unblock_time)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar

    # Variables para controlar la ejecución actual
    current = None  # Proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    # Buffers de encolado para respetar la prioridad:
    # primero entran los que terminan CPU (CPU_FINISH), luego los que salen de BLOQ (UNBLOCK)
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: PROCESAR LLEGADAS
        # Buscar procesos que llegan exactamente en este momento
        for p in processes:
            # Verificar si el proceso cumple todas las condiciones para ser procesado:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No ha terminado (completion_time is None)
            # - No está ya en la cola de listos
            # - No está bloqueado
            # - No es el proceso actual en ejecución
            # - No está ya en los buffers de encolado
            if (
                p.arrival_time == time
                and p.completion_time is None
                and p not in ready_queue
                and all(bp is not p for bp, _ in blocked_queue)
                and p is not current
                and p not in enq_cpu  # evitar duplicado si llega y ya está en buffer
                and p not in enq_unblock
            ):
                # Determinar qué tipo de ráfaga tiene el proceso al llegar
                if p.is_cpu_burst():  # Si la primera ráfaga es de CPU
                    enq_cpu.append(p)  # PRIORIDAD: llegan a ready como CPU_FINISH
                else:  # Si la primera ráfaga es de bloqueo
                    dur = p.bursts[p.current_burst_index]  # Duración del bloqueo
                    if dur > 0:  # Si el bloqueo tiene duración
                        gantt_chart.append((p.pid, time, time + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                        blocked_queue.append((p, time + dur))  # Agregar a cola de bloqueados
                    else:  # Si el bloqueo es de duración 0 (bloqueo instantáneo)
                        p.advance_burst()  # Avanzar a la siguiente ráfaga
                        if p.current_burst_index >= len(p.bursts):  # Si terminó el proceso
                            p.completion_time = time
                            completed += 1
                        elif p.is_cpu_burst():  # Si la siguiente es CPU
                            enq_cpu.append(p)  # entra por CPU
                        else:  # Si la siguiente es otro bloqueo
                            dur2 = p.bursts[p.current_burst_index]
                            if dur2 > 0:  # Si tiene duración
                                gantt_chart.append((p.pid, time, time + dur2, "BLOCK"))
                                blocked_queue.append((p, time + dur2))
                            else:  # Si es de duración 0
                                p.advance_burst()
                                if p.current_burst_index < len(p.bursts) and p.is_cpu_burst():
                                    enq_cpu.append(p)

        # FASE 2: PROCESAR DESBLOQUEOS
        # Buscar procesos que terminan su bloqueo en este momento
        for (bp, unblock_time) in blocked_queue[:]:  # Iterar sobre una copia de la lista
            if unblock_time == time:  # Si el bloqueo termina en este momento
                blocked_queue.remove((bp, unblock_time))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                if bp.current_burst_index >= len(bp.bursts):  # Si terminó el proceso
                    bp.completion_time = time
                    completed += 1
                else:
                    if bp.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        enq_unblock.append(bp)  # SALIDA DE BLOQ va detrás de CPU_FINISH
                    else:  # Si la siguiente ráfaga es de bloqueo
                        dur2 = bp.bursts[bp.current_burst_index]
                        if dur2 > 0:  # Si tiene duración
                            gantt_chart.append((bp.pid, time, time + dur2, "BLOCK"))
                            blocked_queue.append((bp, time + dur2))
                        else:  # Si es de duración 0
                            bp.advance_burst()
                            if bp.current_burst_index >= len(bp.bursts):  # Si terminó
                                bp.completion_time = time
                                completed += 1
                            elif bp.is_cpu_burst():  # Si la siguiente es CPU
                                enq_unblock.append(bp)

        # FASE 3: VOLCAR BUFFERS A COLA DE LISTOS
        # Mezclar en ready con la prioridad requerida: primero enq_cpu, luego enq_unblock
        if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
            ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero (mayor prioridad)
            ready_queue.extend(enq_unblock)  # Luego los de desbloqueo (menor prioridad)
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # FASE 4: SELECCIÓN DE PROCESO (CRITERIO FIFO)
        # Elegir proceso para ejecutar si no hay uno ejecutando
        if current is None and ready_queue:  # Si no hay proceso ejecutando y hay listos
            current = ready_queue.pop(0)  # Tomar el primero de la cola (FIFO)
            start_time = time  # Marcar inicio del bloque en Gantt
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # solo la primera vez que toca CPU

        # FASE 5: EJECUTAR PROCESO O AVANZAR TIEMPO
        if current:  # Si hay un proceso ejecutando
            # Ejecutar 1 tick de CPU
            current.remaining_time -= 1  # Reducir tiempo restante del proceso
            time += 1  # Avanzar el reloj del sistema

            # FASE 6: VERIFICAR SI TERMINÓ LA RÁFAGA DE CPU
            if current.remaining_time == 0:  # Si terminó la ráfaga de CPU
                # Cerrar tramo de CPU en el diagrama de Gantt
                gantt_chart.append((current.pid, start_time, time, "CPU"))

                # Avanzar a la siguiente ráfaga
                current.advance_burst()

                # FASE 7: DETERMINAR QUÉ HACER CON EL PROCESO
                if current.current_burst_index >= len(current.bursts):  # Si terminó el proceso
                    current.completion_time = time
                    completed += 1
                    current = None  # Liberar CPU
                else:
                    # Verificar qué tipo de ráfaga sigue
                    if current.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        # Entra a ready como "CPU_FINISH" (prioridad sobre UNBLOCK si coincide el instante)
                        enq_cpu.append(current)
                        current = None  # Liberar CPU
                    else:  # Si la siguiente ráfaga es de bloqueo
                        # Siguiente es BLOQUEO
                        dur = current.bursts[current.current_burst_index]
                        if dur > 0:  # Si tiene duración
                            gantt_chart.append((current.pid, time, time + dur, "BLOCK"))
                            blocked_queue.append((current, time + dur))
                            current = None  # Liberar CPU
                        else:  # Si es de duración 0 (bloqueo instantáneo)
                            # Bloqueo de 0 → saltar
                            current.advance_burst()
                            if current.current_burst_index >= len(current.bursts):  # Si terminó
                                current.completion_time = time
                                completed += 1
                                current = None
                            elif current.is_cpu_burst():  # Si la siguiente es CPU
                                enq_cpu.append(current)
                                current = None

            # FASE 8: VOLCAR BUFFERS DESPUÉS DE EJECUTAR
            # Tras terminar el tick, antes de próxima selección, volcamos buffers con prioridad
            if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
                ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready_queue.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
        else:  # No hay proceso ejecutando
            # No hay proceso ejecutando ni listo: avanzar tiempo "vacío" (no pintamos IDLE)
            time += 1

    # Retornar resultados de la simulación
    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\priority.py

...-------------------...
from copy import deepcopy

def priority(process_list):
    """
    ALGORITMO DE PRIORIDADES - NO EXPULSIVO SIN BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en orden de prioridad (mayor número = mayor prioridad)
    - Una vez que un proceso comienza a ejecutarse, no puede ser interrumpido
    - No hay bloqueos de E/S, solo ráfagas de CPU
    - Cada proceso tiene una sola ráfaga de CPU que se ejecuta completamente
    - En caso de empate de prioridad, se aplica FIFO (orden de llegada)
    
    CARACTERÍSTICAS:
    - No expulsivo: no hay preempción una vez que comienza la ejecución
    - Sin bloqueos: no hay operaciones de E/S
    - Basado en prioridades: mayor número = mayor prioridad
    - Desempate FIFO: en caso de empate de prioridad, el primero en llegar se ejecuta primero
    - Puede causar inanición: procesos de baja prioridad pueden esperar indefinidamente
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU] y priority asignada
    
    RETORNA:
    - gantt: Lista de tuplas (pid, start, end) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt = []  # Lista para almacenar el diagrama de Gantt
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar

    # Verificar que los procesos tengan prioridad asignada
    for p in processes:
        # Verificar que el proceso tenga prioridad asignada (por defecto es 0)
        if not hasattr(p, 'priority'):
            p.priority = 0

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: IDENTIFICAR PROCESOS ELEGIBLES
        # Buscar procesos que han llegado y no han terminado
        elegibles = [p for p in processes if p.arrival_time <= time and p.completion_time is None]

        # FASE 2: MANEJAR CPU OCIOSA
        if not elegibles:  # Si no hay procesos elegibles
            time += 1  # Avanzar tiempo y continuar en la siguiente iteración
            continue

        # FASE 3: SELECCIÓN DE PROCESO (CRITERIO DE PRIORIDADES)
        # Ordenar por prioridad (mayor número = mayor prioridad), luego FIFO en empates
        elegibles.sort(key=lambda p: (
            -p.priority,  # Prioridad descendente (mayor número primero)
            p.arrival_time,  # FIFO en empates (menor tiempo de llegada primero)
            p.pid  # Estabilidad (desempate por PID)
        ))
        
        # Seleccionar el proceso con mayor prioridad
        current = elegibles[0]  # Tomar el proceso con mayor prioridad

        # FASE 4: EJECUTAR PROCESO COMPLETAMENTE
        # Marcar tiempo de inicio si es la primera vez que se ejecuta
        if current.start_time is None:  # Si es la primera vez que se ejecuta
            current.start_time = time  # Marcar tiempo de inicio del proceso

        # Ejecutar el proceso completamente (algoritmo de prioridades es no expulsivo)
        start = time  # Guardar tiempo de inicio de esta ejecución
        cpu = current.remaining_time  # Tiempo de CPU restante (equivale a bursts[0])
        time += cpu  # Avanzar el reloj del sistema por el tiempo de CPU completo
        gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

        # FASE 5: MARCAR PROCESO COMO COMPLETADO
        current.completion_time = time  # Marcar tiempo de finalización
        current.calculate_metrics()  # Calcular métricas del proceso (TR, TE, etc.)
        completed += 1  # Incrementar contador de procesos completados

    # Retornar resultados de la simulación
    return gantt, processes



...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\priority_blocking.py

...-------------------...
from copy import deepcopy

def priority_blocking(process_list):
    """
    ALGORITMO DE PRIORIDADES - NO EXPULSIVO CON BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en orden de prioridad (mayor número = mayor prioridad)
    - Una vez que un proceso comienza a ejecutarse, no puede ser interrumpido
    - Los procesos pueden tener múltiples ráfagas de CPU y E/S (bloqueos)
    - Cuando un proceso termina una ráfaga de CPU, puede ir a bloqueo o continuar con otra CPU
    - Cuando un proceso termina un bloqueo, regresa a la cola de listos
    - Se respeta la prioridad: procesos que terminan CPU tienen prioridad sobre los que salen de bloqueo
    - En caso de empate de prioridad, se aplica FIFO (orden de llegada)
    
    CARACTERÍSTICAS:
    - No expulsivo: no hay preempción una vez que comienza la ejecución
    - Con bloqueos: maneja operaciones de E/S (Entrada/Salida)
    - Basado en prioridades: mayor número = mayor prioridad
    - Desempate FIFO: en caso de empate de prioridad, el primero en llegar se ejecuta primero
    - Maneja múltiples ráfagas: CPU → E/S → CPU → E/S → ...
    - Puede causar inanición: procesos de baja prioridad pueden esperar indefinidamente
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU, E/S, CPU, E/S, ...] y priority asignada
    
    RETORNA:
    - gantt_chart: Lista de tuplas (pid, start, end, tipo) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt
    ready_queue = []  # Cola de procesos listos para ejecutar
    blocked_queue = []  # Cola de procesos bloqueados: (proceso, unblock_time)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar

    # Variables para controlar la ejecución actual
    current = None  # Proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    # Buffers de encolado para respetar la prioridad:
    # primero entran los que terminan CPU (CPU_FINISH), luego los que salen de BLOQ (UNBLOCK)
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    # Verificar que los procesos tengan prioridad asignada
    for p in processes:
        if not hasattr(p, 'priority'):
            p.priority = 0

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: PROCESAR LLEGADAS
        # Buscar procesos que llegan exactamente en este momento
        for p in processes:
            # Verificar si el proceso cumple todas las condiciones para ser procesado:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No ha terminado (completion_time is None)
            # - No está ya en la cola de listos
            # - No está bloqueado
            # - No es el proceso actual en ejecución
            # - No está ya en los buffers de encolado
            if (
                p.arrival_time == time
                and p.completion_time is None
                and p not in ready_queue
                and all(bp is not p for bp, _ in blocked_queue)
                and p is not current
                and p not in enq_cpu  # evitar duplicado si llega y ya está en buffer
                and p not in enq_unblock
            ):
                # Determinar qué tipo de ráfaga tiene el proceso al llegar
                if p.is_cpu_burst():  # Si la primera ráfaga es de CPU
                    enq_cpu.append(p)  # PRIORIDAD: llegan a ready como CPU_FINISH
                else:  # Si la primera ráfaga es de bloqueo
                    dur = p.bursts[p.current_burst_index]  # Duración del bloqueo
                    if dur > 0:  # Si el bloqueo tiene duración
                        gantt_chart.append((p.pid, time, time + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                        blocked_queue.append((p, time + dur))  # Agregar a cola de bloqueados
                    else:  # Si el bloqueo es de duración 0 (bloqueo instantáneo)
                        p.advance_burst()  # Avanzar a la siguiente ráfaga
                        if p.current_burst_index >= len(p.bursts):  # Si terminó el proceso
                            p.completion_time = time
                            completed += 1
                        elif p.is_cpu_burst():  # Si la siguiente es CPU
                            enq_cpu.append(p)  # entra por CPU
                        else:  # Si la siguiente es otro bloqueo
                            dur2 = p.bursts[p.current_burst_index]
                            if dur2 > 0:  # Si tiene duración
                                gantt_chart.append((p.pid, time, time + dur2, "BLOCK"))
                                blocked_queue.append((p, time + dur2))
                            else:  # Si es de duración 0
                                p.advance_burst()
                                if p.current_burst_index < len(p.bursts) and p.is_cpu_burst():
                                    enq_cpu.append(p)

        # FASE 2: PROCESAR DESBLOQUEOS
        # Buscar procesos que terminan su bloqueo en este momento
        for (bp, unblock_time) in blocked_queue[:]:  # Iterar sobre una copia de la lista
            if unblock_time == time:  # Si el bloqueo termina en este momento
                blocked_queue.remove((bp, unblock_time))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                if bp.current_burst_index >= len(bp.bursts):  # Si terminó el proceso
                    bp.completion_time = time
                    completed += 1
                else:
                    if bp.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        enq_unblock.append(bp)  # SALIDA DE BLOQ va detrás de CPU_FINISH
                    else:  # Si la siguiente ráfaga es de bloqueo
                        dur2 = bp.bursts[bp.current_burst_index]
                        if dur2 > 0:  # Si tiene duración
                            gantt_chart.append((bp.pid, time, time + dur2, "BLOCK"))
                            blocked_queue.append((bp, time + dur2))
                        else:  # Si es de duración 0
                            bp.advance_burst()
                            if bp.current_burst_index >= len(bp.bursts):  # Si terminó
                                bp.completion_time = time
                                completed += 1
                            elif bp.is_cpu_burst():  # Si la siguiente es CPU
                                enq_unblock.append(bp)

        # FASE 3: VOLCAR BUFFERS A COLA DE LISTOS
        # Mezclar en ready con la prioridad requerida: primero enq_cpu, luego enq_unblock
        if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
            ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero (mayor prioridad)
            ready_queue.extend(enq_unblock)  # Luego los de desbloqueo (menor prioridad)
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # FASE 4: SELECCIÓN DE PROCESO (CRITERIO DE PRIORIDADES)
        # Elegir proceso para ejecutar si no hay uno ejecutando
        if current is None and ready_queue:  # Si no hay proceso ejecutando y hay listos
            # Ordenar por prioridad (mayor número = mayor prioridad), luego FIFO en empates
            ready_queue.sort(key=lambda p: (
                -p.priority,  # Prioridad descendente (mayor número primero)
                p.arrival_time,  # FIFO en empates (menor tiempo de llegada primero)
                p.pid  # Estabilidad (desempate por PID)
            ))
            
            current = ready_queue.pop(0)  # Tomar el proceso con mayor prioridad
            start_time = time  # Marcar inicio del bloque en Gantt
            
            # Marcar tiempo de inicio si es la primera vez que se ejecuta
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # solo la primera vez que toca CPU

        # FASE 5: EJECUTAR PROCESO O AVANZAR TIEMPO
        if current:  # Si hay un proceso ejecutando
            # Ejecutar 1 tick de CPU
            current.remaining_time -= 1  # Reducir tiempo restante del proceso
            time += 1  # Avanzar el reloj del sistema

            # FASE 6: VERIFICAR SI TERMINÓ LA RÁFAGA DE CPU
            if current.remaining_time == 0:  # Si terminó la ráfaga de CPU
                # Cerrar tramo de CPU en el diagrama de Gantt
                gantt_chart.append((current.pid, start_time, time, "CPU"))

                # Avanzar a la siguiente ráfaga
                current.advance_burst()

                # FASE 7: DETERMINAR QUÉ HACER CON EL PROCESO
                if current.current_burst_index >= len(current.bursts):  # Si terminó el proceso
                    current.completion_time = time
                    completed += 1
                    current = None  # Liberar CPU
                else:
                    # Verificar qué tipo de ráfaga sigue
                    if current.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        # Entra a ready como "CPU_FINISH" (prioridad sobre UNBLOCK si coincide el instante)
                        enq_cpu.append(current)
                        current = None  # Liberar CPU
                    else:  # Si la siguiente ráfaga es de bloqueo
                        # Siguiente es BLOQUEO
                        dur = current.bursts[current.current_burst_index]
                        if dur > 0:  # Si tiene duración
                            gantt_chart.append((current.pid, time, time + dur, "BLOCK"))
                            blocked_queue.append((current, time + dur))
                            current = None  # Liberar CPU
                        else:  # Si es de duración 0 (bloqueo instantáneo)
                            # Bloqueo de 0 → saltar
                            current.advance_burst()
                            if current.current_burst_index >= len(current.bursts):  # Si terminó
                                current.completion_time = time
                                completed += 1
                                current = None
                            elif current.is_cpu_burst():  # Si la siguiente es CPU
                                enq_cpu.append(current)
                                current = None

            # FASE 8: VOLCAR BUFFERS DESPUÉS DE EJECUTAR
            # Tras terminar el tick, antes de próxima selección, volcamos buffers con prioridad
            if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
                ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready_queue.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
        else:  # No hay proceso ejecutando
            # No hay proceso ejecutando ni listo: avanzar tiempo "vacío" (no pintamos IDLE)
            time += 1

    # Retornar resultados de la simulación
    return gantt_chart, processes



...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\roundrobin.py

...-------------------...
from copy import deepcopy
from collections import deque

def round_robin(process_list, quantum):
    """
    ALGORITMO ROUND ROBIN (RR) - EXPULSIVO SIN BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en turnos de tiempo fijo (quantum)
    - Cuando un proceso termina su quantum, se suspende y va al final de la cola
    - El siguiente proceso en la cola toma el CPU
    - Si un proceso termina antes de completar su quantum, libera el CPU inmediatamente
    - No hay bloqueos de E/S, solo ráfagas de CPU
    
    CARACTERÍSTICAS:
    - Expulsivo: los procesos pueden ser interrumpidos por el quantum
    - Sin bloqueos: no hay operaciones de E/S
    - Justo: todos los procesos reciben tiempo de CPU equitativo
    - Responsivo: los procesos no esperan mucho tiempo para ejecutarse
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU]
    - quantum: Tiempo máximo que un proceso puede ejecutarse continuamente
    
    RETORNA:
    - gantt_chart: Lista de tuplas (pid, start, end) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    n = len(processes)  # Total de procesos a procesar
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    completed = 0  # Contador de procesos completados
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt

    # Estructuras de datos para Round Robin
    ready_queue = deque()  # Cola de procesos listos (FIFO con deque para eficiencia)
    
    # Ordenar procesos por tiempo de llegada, luego por PID para consistencia
    # Esto asegura un orden predecible cuando hay empates en llegada
    procesos_pendientes = sorted(processes, key=lambda p: (p.arrival_time, p.pid))

    # Variables para controlar cambios de proceso en el diagrama de Gantt
    current_pid = None  # PID del proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: ENCOLAR LLEGADAS AL TIEMPO ACTUAL
        # Buscar procesos que llegan exactamente en este momento
        procesos_que_llegan = []
        for p in procesos_pendientes:
            # Verificar si el proceso cumple las condiciones para ser encolado:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No está ya en la cola de listos
            # - Aún tiene tiempo restante para ejecutar
            if p.arrival_time == time and p not in ready_queue and p.remaining_time > 0:
                procesos_que_llegan.append(p)
        
        # Ordenar por PID para mantener consistencia y agregar al final de la cola
        procesos_que_llegan.sort(key=lambda p: p.pid)
        for p in procesos_que_llegan:
            ready_queue.append(p)  # Agregar al final de la cola (FIFO)

        # FASE 2: EJECUTAR PROCESO
        if ready_queue:  # Si hay procesos listos para ejecutar
            
            # Seleccionar proceso: Round Robin = FIFO con quantum
            current = ready_queue.popleft()  # Tomar el primero de la cola

            # CONTROL DE CAMBIOS DE PROCESO EN GANTT
            if current_pid != current.pid:  # Si cambió el proceso
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = current.pid  # Actualizar PID actual
                start_time = time  # Marcar inicio del nuevo bloque
                
                # Marcar tiempo de inicio si es la primera vez que se ejecuta
                if current.start_time is None:  # Si es la primera vez que se ejecuta
                    current.start_time = time  # Marcar tiempo de inicio del proceso

            # FASE 3: EJECUTAR PROCESO POR QUANTUM
            # Ejecutar hasta quantum o hasta que termine (lo que ocurra primero)
            exec_time = min(quantum, current.remaining_time)  # Tiempo a ejecutar
            current.remaining_time -= exec_time  # Reducir tiempo restante del proceso
            time += exec_time  # Avanzar el reloj del sistema

            # FASE 4: ENCOLAR LLEGADAS DURANTE LA EJECUCIÓN
            # Buscar procesos que llegaron durante la ejecución del proceso actual
            procesos_nuevos = []
            for p in procesos_pendientes:
                # Verificar si llegó durante la ejecución del proceso actual
                # (entre time - exec_time y time)
                if time - exec_time < p.arrival_time <= time and p.remaining_time > 0 and p not in ready_queue:
                    procesos_nuevos.append(p)
            
            # Ordenar por PID y agregar al final de la cola
            procesos_nuevos.sort(key=lambda p: p.pid)
            for p in procesos_nuevos:
                ready_queue.append(p)  # Agregar al final de la cola

            # FASE 5: DECIDIR QUÉ HACER CON EL PROCESO ACTUAL
            if current.remaining_time > 0:  # Si el proceso no terminó
                # Agregar el proceso actual al final de la cola (Round Robin)
                # Esto implementa la rotación de procesos
                ready_queue.append(current)
            else:  # Si el proceso terminó
                current.completion_time = time  # Marcar tiempo de finalización
                current.calculate_metrics()  # Calcular métricas del proceso (TR, TE, etc.)
                completed += 1  # Incrementar contador de procesos completados
                
        else:  # No hay procesos listos: CPU ociosa
            # CONTROL DE PERÍODOS IDLE EN GANTT
            if current_pid != "IDLE":  # Si no está marcado como IDLE
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = "IDLE"  # Marcar como IDLE
                start_time = time  # Marcar inicio del período IDLE
            
            # Avanzar tiempo sin ejecutar nada
            time += 1

    # Cerrar el último bloque del diagrama de Gantt
    if current_pid is not None:
        gantt_chart.append((current_pid, start_time, time))

    # Retornar resultados de la simulación
    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\round_robin_blocking.py

...-------------------...
from copy import deepcopy
from collections import deque

def round_robin_blocking(process_list, quantum):
    """
    ALGORITMO ROUND ROBIN (RR) - EXPULSIVO CON BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en turnos de tiempo fijo (quantum)
    - Cuando un proceso termina su quantum, se suspende y va al final de la cola
    - El siguiente proceso en la cola toma el CPU
    - Los procesos pueden tener múltiples ráfagas de CPU y E/S (bloqueos)
    - Cuando un proceso termina una ráfaga de CPU, puede ir a bloqueo o continuar con otra CPU
    - Cuando un proceso termina un bloqueo, regresa a la cola de listos
    - Se respeta la prioridad: procesos que terminan CPU tienen prioridad sobre los que salen de bloqueo
    
    CARACTERÍSTICAS:
    - Expulsivo: los procesos pueden ser interrumpidos por el quantum
    - Con bloqueos: maneja operaciones de E/S (Entrada/Salida)
    - Justo: todos los procesos reciben tiempo de CPU equitativo
    - Responsivo: los procesos no esperan mucho tiempo para ejecutarse
    - Maneja múltiples ráfagas: CPU → E/S → CPU → E/S → ...
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU, E/S, CPU, E/S, ...]
    - quantum: Tiempo máximo que un proceso puede ejecutarse continuamente
    
    RETORNA:
    - gantt: Lista de tuplas (pid, start, end, tipo) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """

    def collapse_zeros(proc, t):
        """
        FUNCIÓN AUXILIAR: Saltar ráfagas de duración 0 encadenadas.
        
        Si un proceso tiene ráfagas de duración 0, las salta automáticamente
        hasta encontrar una ráfaga con duración > 0 o hasta que termine el proceso.
        
        Args:
            proc: Proceso a procesar
            t: Tiempo actual
            
        Returns:
            bool: True si el proceso terminó, False si aún tiene ráfagas
        """
        # Saltar todas las ráfagas de duración 0 consecutivas
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()  # Avanzar a la siguiente ráfaga
        
        # Verificar si el proceso terminó después de saltar ráfagas 0
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t  # Marcar tiempo de finalización
            return True  # El proceso terminó
        return False  # El proceso aún tiene ráfagas

    def handle_after_cpu_or_arrival(proc, t, enq_cpu, blocked, gantt):
        """
        FUNCIÓN AUXILIAR: Resolver transición tras llegada o fin de CPU.
        
        Determina qué hacer con un proceso después de que termina una ráfaga de CPU
        o cuando llega al sistema. Puede ir a CPU, bloqueo, o terminar.
        
        Args:
            proc: Proceso a procesar
            t: Tiempo actual
            enq_cpu: Buffer de procesos que van a CPU
            blocked: Lista de procesos bloqueados
            gantt: Lista del diagrama de Gantt
            
        Returns:
            bool: True si el proceso terminó, False si continúa
        """
        # Primero saltar ráfagas 0 si las hay
        if collapse_zeros(proc, t):
            return True  # El proceso terminó
        
        # Determinar qué tipo de ráfaga sigue
        if proc.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
            enq_cpu.append(proc)  # Agregar al buffer de CPU (alta prioridad)
        else:  # Si la siguiente ráfaga es de bloqueo
            dur = proc.bursts[proc.current_burst_index]  # Duración del bloqueo
            if dur > 0:  # Si tiene duración
                gantt.append((proc.pid, t, t + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                blocked.append((proc, t + dur))  # Agregar a cola de bloqueados
            else:  # Si es de duración 0 (bloqueo instantáneo)
                proc.advance_burst()  # Avanzar a la siguiente ráfaga
                # Llamar recursivamente para procesar la siguiente ráfaga
                return handle_after_cpu_or_arrival(proc, t, enq_cpu, blocked, gantt)
        return False  # El proceso continúa

    def handle_after_unblock(proc, t, enq_unblock, blocked, gantt):
        """
        FUNCIÓN AUXILIAR: Resolver transición tras fin de bloqueo.
        
        Determina qué hacer con un proceso después de que termina un bloqueo.
        Puede ir a CPU, otro bloqueo, o terminar.
        
        Args:
            proc: Proceso a procesar
            t: Tiempo actual
            enq_unblock: Buffer de procesos que salen de bloqueo
            blocked: Lista de procesos bloqueados
            gantt: Lista del diagrama de Gantt
            
        Returns:
            bool: True si el proceso terminó, False si continúa
        """
        # Primero saltar ráfagas 0 si las hay
        if collapse_zeros(proc, t):
            return True  # El proceso terminó
        
        # Determinar qué tipo de ráfaga sigue
        if proc.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
            enq_unblock.append(proc)  # Agregar al buffer de desbloqueo (baja prioridad)
        else:  # Si la siguiente ráfaga es de bloqueo
            dur = proc.bursts[proc.current_burst_index]  # Duración del bloqueo
            if dur > 0:  # Si tiene duración
                gantt.append((proc.pid, t, t + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                blocked.append((proc, t + dur))  # Agregar a cola de bloqueados
            else:  # Si es de duración 0 (bloqueo instantáneo)
                proc.advance_burst()  # Avanzar a la siguiente ráfaga
                # Llamar recursivamente para procesar la siguiente ráfaga
                return handle_after_unblock(proc, t, enq_unblock, blocked, gantt)
        return False  # El proceso continúa

    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)

    # FASE DE INICIALIZACIÓN
    # Configurar atributos necesarios para cada proceso
    for idx, p in enumerate(processes):
        # Guardar copia original de bursts para referencia
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        
        # Asignar secuencia para desempates
        p._seq = idx
        
        # Inicializar atributos de tiempo
        p.ready_since = None  # Tiempo desde que está listo
        p.start_time = None  # Tiempo de primera ejecución
        p.completion_time = None  # Tiempo de finalización
        
        # Manejar procesos sin ráfagas (caso especial)
        if not p.bursts:
            p.current_burst_index = 0
            p.remaining_time = 0
            p.completion_time = 0

    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt = []  # Lista para almacenar el diagrama de Gantt
    ready = deque()  # Cola de procesos listos (FIFO con deque para eficiencia)
    blocked = []  # Lista de procesos bloqueados: (proceso, unblock_time)
    completed = sum(1 for p in processes if p.completion_time is not None)  # Contador de completados
    n = len(processes)  # Total de procesos a procesar
    arrived = set()  # Conjunto de PIDs que ya llegaron al sistema

    # Buffers de encolado para respetar la prioridad
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    def enqueue_arrivals_leq_t(t):
        """
        FUNCIÓN AUXILIAR: Encolar llegadas hasta tiempo t (incluido) con prioridad de llegada.
        
        Busca todos los procesos que han llegado al sistema hasta el tiempo t
        y los procesa según su tipo de primera ráfaga.
        
        Args:
            t: Tiempo hasta el cual buscar llegadas
        """
        nonlocal completed
        for p in processes:
            # Saltar procesos que ya llegaron
            if p.pid in arrived:
                continue
            
            # Verificar si el proceso llegó y no ha terminado
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)  # Marcar como llegado
                # Procesar llegada usando la función auxiliar
                if handle_after_cpu_or_arrival(p, t, enq_cpu, blocked, gantt):
                    completed += 1

    # PROCESAR LLEGADAS INICIALES
    # Buscar procesos que llegan en tiempo 0
    enqueue_arrivals_leq_t(time)
    
    # Volcar buffers iniciales a la cola de listos
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)  # Agregar procesos de CPU primero
        ready.extend(enq_unblock)  # Luego los de desbloqueo
        enq_cpu.clear()  # Limpiar buffer de CPU
        enq_unblock.clear()  # Limpiar buffer de desbloqueo

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: MANEJAR CPU OCIOSA
        # Si no hay procesos listos, saltar al siguiente evento
        if not ready:
            # Buscar próximos eventos (llegadas y desbloqueos)
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            
            # Verificar si no hay más eventos futuros
            if not future_arrivals and not future_unblocks:
                # Procesar procesos que terminaron sin completar
                for p in processes:
                    if p.completion_time is None and p.current_burst_index >= len(p.bursts):
                        p.completion_time = time
                        completed += 1
                break  # Terminar simulación
            
            # Calcular el próximo evento
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else time + 1
            
            # Avanzar tiempo hasta el próximo evento
            if next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))  # Registrar período IDLE
                time = next_event
            else:
                time += 1

            # FASE 2: PROCESAR EVENTOS EN EL TIEMPO ACTUAL
            # Procesar desbloqueos que vencen en este momento
            for (bp, unb) in blocked[:]:  # Iterar sobre una copia de la lista
                if unb == time:  # Si el bloqueo termina en este momento
                    blocked.remove((bp, unb))  # Remover de la cola de bloqueados
                    bp.advance_burst()  # Avanzar a la siguiente ráfaga
                    if handle_after_unblock(bp, time, enq_unblock, blocked, gantt):
                        completed += 1

            # Procesar llegadas en este momento
            enqueue_arrivals_leq_t(time)
            
            # Volcar buffers a la cola de listos
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
            continue  # Volver al inicio del bucle

        # FASE 3: SELECCIÓN DE PROCESO (CRITERIO ROUND ROBIN)
        # Seleccionar el primer proceso de la cola (FIFO)
        current = ready.popleft()

        # FASE 4: VERIFICAR TIPO DE RÁFAGA
        # Si el proceso no está en una ráfaga de CPU, procesarlo
        if not current.is_cpu_burst():
            if handle_after_cpu_or_arrival(current, time, enq_cpu, blocked, gantt):
                completed += 1
            # Volcar buffers después de procesar
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
            continue  # Volver al inicio del bucle

        # FASE 5: MARCAR TIEMPO DE INICIO
        # Marcar tiempo de inicio si es la primera vez que se ejecuta
        if current.start_time is None:
            current.start_time = time

        # FASE 6: SINCRONIZAR TIEMPO RESTANTE
        # IMPORTANTE: Sincronizar remaining_time con el burst actual
        current.remaining_time = current.bursts[current.current_burst_index]

        # FASE 7: CALCULAR TIEMPO DE EJECUCIÓN
        # Definir tramo a ejecutar (quantum o tiempo restante, lo que sea menor)
        exec_time = min(quantum, current.remaining_time)
        start = time  # Tiempo de inicio de esta ejecución
        end = time + exec_time  # Tiempo de fin de esta ejecución

        # FASE 8: PROCESAR EVENTOS DURANTE LA EJECUCIÓN
        # Procesar desbloqueos que ocurren durante la ejecución
        for (bp, unb) in sorted(blocked[:], key=lambda x: x[1]):  # Ordenar por tiempo de desbloqueo
            if time < unb <= end:  # Si el desbloqueo ocurre durante la ejecución
                blocked.remove((bp, unb))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                if handle_after_unblock(bp, unb, enq_unblock, blocked, gantt):
                    completed += 1

        # Procesar llegadas que ocurren durante la ejecución
        for p in processes:
            if p.pid in arrived:  # Saltar procesos que ya llegaron
                continue
            if time < p.arrival_time <= end and p.completion_time is None:  # Si llega durante la ejecución
                arrived.add(p.pid)  # Marcar como llegado
                if handle_after_cpu_or_arrival(p, p.arrival_time, enq_cpu, blocked, gantt):
                    completed += 1

        # FASE 9: EJECUTAR PROCESO
        # CRÍTICO: Actualizar AMBOS - remaining_time Y el burst actual
        current.remaining_time -= exec_time  # Reducir tiempo restante
        current.bursts[current.current_burst_index] -= exec_time  # ← ESTA LÍNEA ES CRÍTICA
        time = end  # Avanzar el reloj del sistema
        gantt.append((current.pid, start, end, "CPU"))  # Registrar ejecución en Gantt

        # FASE 10: DETERMINAR QUÉ HACER CON EL PROCESO
        # ¿Terminó la ráfaga o agotó el quantum?
        if current.remaining_time == 0:  # Si terminó la ráfaga de CPU
            current.bursts[current.current_burst_index] = 0  # Asegurar que queda en 0
            current.advance_burst()  # Avanzar a la siguiente ráfaga
            
            if current.current_burst_index >= len(current.bursts):  # Si terminó el proceso
                current.completion_time = time
                completed += 1
            else:  # Si aún tiene ráfagas
                if handle_after_cpu_or_arrival(current, time, enq_cpu, blocked, gantt):
                    completed += 1
        else:  # Si la ráfaga no terminó (agotó quantum)
            # Ráfaga no terminó → reencolar al final (Round Robin)
            current.ready_since = time  # Marcar tiempo desde que está listo
            enq_cpu.append(current)  # Agregar al buffer de CPU

        # FASE 11: VOLCAR BUFFERS CON PRIORIDAD
        # Volcar buffers a la cola de listos respetando prioridades
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)  # Agregar procesos de CPU primero
            ready.extend(enq_unblock)  # Luego los de desbloqueo
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

    # FASE FINAL: SALVAGUARDA
    # Procesar procesos que terminaron sin completar
    for p in processes:
        if p.completion_time is None and p.current_burst_index >= len(p.bursts):
            p.completion_time = time

    # Retornar resultados de la simulación
    return gantt, processes

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\sjf.py

...-------------------...
from copy import deepcopy

def sjf(process_list):
    """
    ALGORITMO SJF (Shortest Job First) - NO EXPULSIVO SIN BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en orden de duración (el más corto primero)
    - Una vez que un proceso comienza a ejecutarse, no puede ser interrumpido
    - No hay bloqueos de E/S, solo ráfagas de CPU
    - Cada proceso tiene una sola ráfaga de CPU que se ejecuta completamente
    - En cada momento, se selecciona el proceso con menor tiempo de CPU restante
    
    CARACTERÍSTICAS:
    - No expulsivo: no hay preempción una vez que comienza la ejecución
    - Sin bloqueos: no hay operaciones de E/S
    - Optimiza tiempo de respuesta: los trabajos cortos terminan rápido
    - Puede causar inanición: trabajos largos pueden esperar indefinidamente
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU]
    
    RETORNA:
    - gantt: Lista de tuplas (pid, start, end) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt = []  # Lista para almacenar el diagrama de Gantt
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar

    # Verificar que los procesos tengan remaining_time inicializado correctamente
    # (esto es una verificación de seguridad, remaining_time ya viene de Process)
    for p in processes:
        # remaining_time ya viene inicializado de Process(bursts=[cpu])
        pass

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: IDENTIFICAR PROCESOS ELEGIBLES
        # Buscar procesos que han llegado y no han terminado
        elegibles = [p for p in processes if p.arrival_time <= time and p.completion_time is None]

        # FASE 2: MANEJAR CPU OCIOSA
        if not elegibles:  # Si no hay procesos elegibles
            time += 1  # Avanzar tiempo y continuar en la siguiente iteración
            continue

        # FASE 3: SELECCIÓN DE PROCESO (CRITERIO SJF)
        # Elegir el proceso con menor remaining_time (trabajo más corto)
        # SJF: Shortest Job First - el trabajo más corto primero
        current = min(elegibles, key=lambda p: p.remaining_time)

        # FASE 4: EJECUTAR PROCESO COMPLETAMENTE
        # Marcar tiempo de inicio si es la primera vez que se ejecuta
        if current.start_time is None:  # Si es la primera vez que se ejecuta
            current.start_time = time  # Marcar tiempo de inicio del proceso

        # Ejecutar el proceso completamente (SJF es no expulsivo)
        start = time  # Guardar tiempo de inicio de esta ejecución
        cpu = current.remaining_time  # Tiempo de CPU restante (equivale a bursts[0])
        time += cpu  # Avanzar el reloj del sistema por el tiempo de CPU completo
        gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

        # FASE 5: MARCAR PROCESO COMO COMPLETADO
        current.completion_time = time  # Marcar tiempo de finalización
        current.calculate_metrics()  # Calcular métricas del proceso (TR, TE, etc.)
        completed += 1  # Incrementar contador de procesos completados

    # Retornar resultados de la simulación
    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\sjf_blocking.py

...-------------------...
﻿from copy import deepcopy

def sjf_blocking(process_list):
    """
    ALGORITMO SJF (Shortest Job First) - NO EXPULSIVO CON BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en orden de duración total de CPU restante (el más corto primero)
    - Una vez que un proceso comienza a ejecutarse, no puede ser interrumpido
    - Los procesos pueden tener múltiples ráfagas de CPU y E/S (bloqueos)
    - Cuando un proceso termina una ráfaga de CPU, puede ir a bloqueo o continuar con otra CPU
    - Cuando un proceso termina un bloqueo, regresa a la cola de listos
    - Se respeta la prioridad: procesos que terminan CPU tienen prioridad sobre los que salen de bloqueo
    
    CARACTERÍSTICAS:
    - No expulsivo: no hay preempción una vez que comienza la ejecución
    - Con bloqueos: maneja operaciones de E/S (Entrada/Salida)
    - Optimiza tiempo de respuesta: los trabajos cortos terminan rápido
    - Puede causar inanición: trabajos largos pueden esperar indefinidamente
    - Maneja múltiples ráfagas: CPU → E/S → CPU → E/S → ...
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU, E/S, CPU, E/S, ...]
    
    RETORNA:
    - gantt: Lista de tuplas (pid, start, end, tipo) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)

    def cpu_total_restante(p):
        """
        FUNCIÓN AUXILIAR: Calcula el total de CPU restante desde la posición actual.
        
        Esta función es crucial para SJF ya que determina la prioridad del proceso.
        Calcula cuánto tiempo de CPU le queda al proceso desde su posición actual.
        
        Args:
            p: Proceso del cual calcular el tiempo restante
            
        Returns:
            int: Total de tiempo de CPU restante
        """
        idx = p.current_burst_index  # Índice de la ráfaga actual
        if idx >= len(p.bursts):  # Si el proceso terminó
            return 0
        
        total = 0
        # Si estamos en una ráfaga de CPU (índice par)
        if idx % 2 == 0:
            # El burst actual YA refleja lo que queda (se va descontando)
            total += p.bursts[idx]
            start = idx + 2  # Siguiente CPU (saltar el bloqueo)
        else:
            # Si estamos en bloqueo, la próxima CPU es idx+1
            start = idx + 1
        
        # Sumar las ráfagas de CPU futuras
        for i in range(start, len(p.bursts), 2):  # Solo índices pares (CPU)
            total += p.bursts[i]
        
        return total

    # FASE DE INICIALIZACIÓN
    # Configurar atributos necesarios para cada proceso
    for idx, p in enumerate(processes):
        # Guardar copia original de bursts para referencia
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        
        # Asignar secuencia para desempates
        p._seq = idx
        
        # Calcular tiempo total de CPU (solo ráfagas pares)
        p.remaining_time = sum(b for i, b in enumerate(p.bursts) if i % 2 == 0)
        
        # Inicializar atributos de tiempo
        p.ready_since = None  # Tiempo desde que está listo
        p.start_time = None  # Tiempo de primera ejecución
        p.completion_time = None  # Tiempo de finalización

    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt = []  # Lista para almacenar el diagrama de Gantt
    ready = []  # Lista de procesos listos para ejecutar
    blocked = []  # Lista de procesos bloqueados: (proceso, unblock_time)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar
    arrived = set()  # Conjunto de PIDs que ya llegaron al sistema

    # Buffers de encolado para respetar la prioridad
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    def collapse_zeros(proc, t):
        """
        FUNCIÓN AUXILIAR: Saltar ráfagas de duración 0 encadenadas.
        
        Si un proceso tiene ráfagas de duración 0, las salta automáticamente
        hasta encontrar una ráfaga con duración > 0 o hasta que termine el proceso.
        
        Args:
            proc: Proceso a procesar
            t: Tiempo actual
            
        Returns:
            bool: True si el proceso terminó, False si aún tiene ráfagas
        """
        # Saltar todas las ráfagas de duración 0 consecutivas
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()  # Avanzar a la siguiente ráfaga
        
        # Verificar si el proceso terminó después de saltar ráfagas 0
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t  # Marcar tiempo de finalización
            return True  # El proceso terminó
        return False  # El proceso aún tiene ráfagas

    def enqueue_arrivals_leq_t(t):
        """
        FUNCIÓN AUXILIAR: Encolar llegadas hasta tiempo t (incluido) con prioridad de llegada.
        
        Busca todos los procesos que han llegado al sistema hasta el tiempo t
        y los procesa según su tipo de primera ráfaga.
        
        Args:
            t: Tiempo hasta el cual buscar llegadas
        """
        nonlocal completed
        for p in processes:
            # Saltar procesos que ya llegaron
            if p.pid in arrived:
                continue
            
            # Verificar si el proceso llegó y no ha terminado
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)  # Marcar como llegado
                
                # Saltar ráfagas 0 si las hay
                if collapse_zeros(p, t):
                    completed += 1
                    continue
                
                # Determinar qué tipo de ráfaga tiene el proceso al llegar
                if p.is_cpu_burst():  # Si la primera ráfaga es de CPU
                    p.ready_since = p.arrival_time  # Marcar tiempo desde que está listo
                    enq_cpu.append(p)  # Agregar al buffer de CPU (alta prioridad)
                else:  # Si la primera ráfaga es de bloqueo
                    dur = p.bursts[p.current_burst_index]  # Duración del bloqueo
                    if dur > 0:  # Si tiene duración
                        gantt.append((p.pid, t, t + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                        blocked.append((p, t + dur))  # Agregar a cola de bloqueados
                    else:  # Si es de duración 0 (bloqueo instantáneo)
                        p.advance_burst()  # Avanzar a la siguiente ráfaga
                        if collapse_zeros(p, t):
                            completed += 1
                        elif p.is_cpu_burst():  # Si la siguiente es CPU
                            p.ready_since = p.arrival_time  # Marcar tiempo desde que está listo
                            enq_cpu.append(p)  # Agregar al buffer de CPU

    # PROCESAR LLEGADAS INICIALES
    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)  # Agregar procesos de CPU primero
        ready.extend(enq_unblock)  # Luego los de desbloqueo
        enq_cpu.clear()  # Limpiar buffer de CPU
        enq_unblock.clear()  # Limpiar buffer de desbloqueo

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: PROCESAR DESBLOQUEOS
        # Ordenar bloqueados por tiempo de desbloqueo
        if blocked:
            blocked.sort(key=lambda x: x[1])
        
        # Procesar desbloqueos que vencen en este momento
        for (bp, unb) in blocked[:]:  # Iterar sobre una copia de la lista
            if unb <= time:  # Si el bloqueo termina en este momento o antes
                blocked.remove((bp, unb))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                
                # Saltar ráfagas 0 si las hay
                if collapse_zeros(bp, time):
                    completed += 1
                    continue
                
                # Determinar qué tipo de ráfaga sigue
                if bp.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                    bp.ready_since = time  # Marcar tiempo desde que está listo
                    enq_unblock.append(bp)  # Agregar al buffer de desbloqueo (baja prioridad)
                else:  # Si la siguiente ráfaga es de bloqueo
                    dur = bp.bursts[bp.current_burst_index]  # Duración del bloqueo
                    if dur > 0:  # Si tiene duración
                        gantt.append((bp.pid, time, time + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                        blocked.append((bp, time + dur))  # Agregar a cola de bloqueados
                    else:  # Si es de duración 0 (bloqueo instantáneo)
                        bp.advance_burst()  # Avanzar a la siguiente ráfaga
                        if collapse_zeros(bp, time):
                            completed += 1
                        elif bp.is_cpu_burst():  # Si la siguiente es CPU
                            bp.ready_since = time  # Marcar tiempo desde que está listo
                            enq_unblock.append(bp)  # Agregar al buffer de desbloqueo

        # FASE 2: PROCESAR LLEGADAS
        enqueue_arrivals_leq_t(time)

        # FASE 3: VOLCAR BUFFERS A COLA DE LISTOS
        # Volcar buffers a ready respetando prioridades
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)  # Agregar procesos de CPU primero
            ready.extend(enq_unblock)  # Luego los de desbloqueo
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # FASE 4: MANEJAR CPU OCIOSA
        # Si no hay procesos listos, saltar al siguiente evento
        if not ready:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                break
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else None
            if next_event is None:
                time += 1
            elif next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            continue

        # FASE 5: SELECCIÓN DE PROCESO (CRITERIO SJF)
        # Filtrar procesos que aún tienen ráfagas
        ready = [p for p in ready if p.current_burst_index < len(p.bursts)]
        
        # Ordenar por criterio SJF con desempates
        ready.sort(key=lambda x: (
            cpu_total_restante(x),  # SJF: menor tiempo total de CPU restante (prioridad principal)
            (x.ready_since if x.ready_since is not None else x.arrival_time),  # FIFO en empates
            x.pid  # Estabilidad (desempate por PID)
        ))

        # Seleccionar el proceso con menor tiempo total de CPU restante
        current = ready.pop(0)
        
        # Marcar tiempo de inicio si es la primera vez que se ejecuta
        if current.start_time is None:
            current.start_time = time

        # FASE 6: EJECUTAR RÁFAGA COMPLETA (SJF es no expulsivo)
        start = time  # Tiempo de inicio de esta ejecución
        cpu_dur = current.bursts[current.current_burst_index]  # Duración de la ráfaga de CPU
        if cpu_dur <= 0:
            if collapse_zeros(current, time):
                completed += 1
            else:
                if current.is_cpu_burst():
                    current.ready_since = time
                    enq_cpu.append(current)
            continue

        time += cpu_dur
        
        # CRÍTICO: Actualizar tanto remaining_time como el burst actual
        if hasattr(current, "remaining_time") and current.remaining_time is not None:
            current.remaining_time -= cpu_dur
            if current.remaining_time < 0:
                current.remaining_time = 0
        
        # IMPORTANTE: Marcar la ráfaga como completada
        current.bursts[current.current_burst_index] = 0
        
        gantt.append((current.pid, start, time, "CPU"))

        # Avanzar bursts
        current.advance_burst()
        if collapse_zeros(current, time):
            completed += 1
            continue

        if current.is_cpu_burst():
            current.ready_since = time
            enq_cpu.append(current)
        else:
            dur = current.bursts[current.current_burst_index]
            if dur > 0:
                gantt.append((current.pid, time, time + dur, "BLOCK"))
                blocked.append((current, time + dur))
            else:
                current.advance_burst()
                if collapse_zeros(current, time):
                    completed += 1
                elif current.is_cpu_burst():
                    current.ready_since = time
                    enq_cpu.append(current)

        # Volcar buffers
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

    return gantt, processes

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\srtf.py

...-------------------...
from copy import deepcopy

def srtf(process_list):
    """
    ALGORITMO SRTF (Shortest Remaining Time First) - EXPULSIVO SIN BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en orden de tiempo restante (el más corto primero)
    - En cada unidad de tiempo, se selecciona el proceso con menor tiempo restante
    - Los procesos pueden ser interrumpidos si llega uno con menor tiempo restante
    - No hay bloqueos de E/S, solo ráfagas de CPU
    - Cada proceso tiene una sola ráfaga de CPU que se ejecuta por unidades de tiempo
    
    CARACTERÍSTICAS:
    - Expulsivo: los procesos pueden ser preemptados en cualquier momento
    - Sin bloqueos: no hay operaciones de E/S
    - Optimiza tiempo de respuesta: los trabajos cortos tienen prioridad
    - Puede causar inanición: trabajos largos pueden ser postergados indefinidamente
    - Muy responsivo: responde inmediatamente a trabajos más cortos
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU]
    
    RETORNA:
    - gantt_chart: Lista de tuplas (pid, start, end) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """
    
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # Inicializar variables del simulador
    n = len(processes)  # Total de procesos a procesar
    completed = 0  # Contador de procesos completados
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt

    # Variables para controlar cambios de proceso en el diagrama de Gantt
    current_pid = None  # PID del proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: IDENTIFICAR PROCESOS LISTOS
        # Filtrar procesos que han llegado y aún tienen tiempo restante
        ready_queue = [p for p in processes if p.arrival_time <= time and p.remaining_time > 0]

        # FASE 2: SELECCIÓN DE PROCESO (CRITERIO SRTF)
        if ready_queue:  # Si hay procesos listos para ejecutar
            
            # Ordenar por criterio SRTF con desempates
            ready_queue.sort(key=lambda x: (
                x.remaining_time,  # SRTF: menor tiempo restante (prioridad principal)
                x.arrival_time,    # FIFO en empates (desempate por llegada)
                x.pid             # Estabilidad (desempate por PID)
            ))
            
            # Seleccionar el proceso con menor tiempo restante
            current = ready_queue[0]  # Tomar el proceso con menor tiempo restante

            # FASE 3: CONTROL DE CAMBIOS DE PROCESO EN GANTT
            # Si cambia el proceso en ejecución, cerrar el bloque anterior
            if current_pid != current.pid:  # Si cambió el proceso
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = current.pid  # Actualizar PID actual
                start_time = time  # Marcar inicio del nuevo bloque
                
                # Marcar tiempo de inicio si es la primera vez que se ejecuta
                if current.start_time is None:  # Si es la primera vez que se ejecuta
                    current.start_time = time  # Marcar tiempo de inicio del proceso

            # FASE 4: EJECUTAR PROCESO POR 1 UNIDAD DE TIEMPO
            # Ejecutar 1 unidad de tiempo (SRTF es expulsivo por unidades)
            current.remaining_time -= 1  # Reducir tiempo restante del proceso
            time += 1  # Avanzar el reloj del sistema

            # FASE 5: VERIFICAR SI EL PROCESO TERMINÓ
            if current.remaining_time == 0:  # Si el proceso terminó
                current.completion_time = time  # Marcar tiempo de finalización
                current.calculate_metrics()  # Calcular métricas del proceso (TR, TE, etc.)
                completed += 1  # Incrementar contador de procesos completados
                
        else:  # No hay procesos listos: CPU ociosa
            # CONTROL DE PERÍODOS IDLE EN GANTT
            if current_pid != "IDLE":  # Si no está marcado como IDLE
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = "IDLE"  # Marcar como IDLE
                start_time = time  # Marcar inicio del período IDLE
            
            # Avanzar tiempo sin ejecutar nada
            time += 1

    # Cerrar el último bloque del diagrama de Gantt
    if current_pid is not None:
        gantt_chart.append((current_pid, start_time, time))

    # Retornar resultados de la simulación
    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\srtf_blocking.py

...-------------------...
from copy import deepcopy

def srtf_blocking(process_list):
    """
    ALGORITMO SRTF (Shortest Remaining Time First) - EXPULSIVO CON BLOQUEOS
    
    FUNCIONAMIENTO:
    - Los procesos se ejecutan en orden de tiempo total de CPU restante (el más corto primero)
    - En cada unidad de tiempo, se selecciona el proceso con menor tiempo total restante
    - Los procesos pueden ser interrumpidos si llega uno con menor tiempo total restante
    - Los procesos pueden tener múltiples ráfagas de CPU y E/S (bloqueos)
    - Cuando un proceso termina una ráfaga de CPU, puede ir a bloqueo o continuar con otra CPU
    - Cuando un proceso termina un bloqueo, regresa a la cola de listos
    - Se respeta la prioridad: procesos que terminan CPU tienen prioridad sobre los que salen de bloqueo
    
    CARACTERÍSTICAS:
    - Expulsivo: los procesos pueden ser preemptados en cualquier momento
    - Con bloqueos: maneja operaciones de E/S (Entrada/Salida)
    - Optimiza tiempo de respuesta: los trabajos cortos tienen prioridad
    - Puede causar inanición: trabajos largos pueden ser postergados indefinidamente
    - Muy responsivo: responde inmediatamente a trabajos más cortos
    - Maneja múltiples ráfagas: CPU → E/S → CPU → E/S → ...
    
    PARÁMETROS:
    - process_list: Lista de objetos Process con bursts=[CPU, E/S, CPU, E/S, ...]
    
    RETORNA:
    - gantt: Lista de tuplas (pid, start, end, tipo) para el diagrama de Gantt
    - processes: Lista de procesos con métricas calculadas
    """

    def collapse_zeros(proc, t):
        """
        FUNCIÓN AUXILIAR: Saltar ráfagas de duración 0 encadenadas.
        
        Si un proceso tiene ráfagas de duración 0, las salta automáticamente
        hasta encontrar una ráfaga con duración > 0 o hasta que termine el proceso.
        
        Args:
            proc: Proceso a procesar
            t: Tiempo actual
            
        Returns:
            bool: True si el proceso terminó, False si aún tiene ráfagas
        """
        # Saltar todas las ráfagas de duración 0 consecutivas
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()  # Avanzar a la siguiente ráfaga
        
        # Verificar si el proceso terminó después de saltar ráfagas 0
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t  # Marcar tiempo de finalización
            return True  # El proceso terminó
        return False  # El proceso aún tiene ráfagas

    def handle_post(proc, t, destino_cpu, destino_unblock, destino_blocked, gantt):
        """
        FUNCIÓN AUXILIAR: Resolver transición tras fin de ráfaga.
        
        Determina qué hacer con un proceso después de que termina una ráfaga.
        Puede ir a CPU, bloqueo, o terminar.
        
        Args:
            proc: Proceso a procesar
            t: Tiempo actual
            destino_cpu: Buffer de procesos que van a CPU
            destino_unblock: Buffer de procesos que salen de bloqueo
            destino_blocked: Lista de procesos bloqueados
            gantt: Lista del diagrama de Gantt
            
        Returns:
            bool: True si el proceso terminó, False si continúa
        """
        # Primero saltar ráfagas 0 si las hay
        if collapse_zeros(proc, t):
            return True  # El proceso terminó
        
        # Determinar qué tipo de ráfaga sigue
        if proc.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
            destino_cpu.append(proc)  # Agregar al buffer correspondiente
        else:  # Si la siguiente ráfaga es de bloqueo
            dur = proc.bursts[proc.current_burst_index]  # Duración del bloqueo
            if dur > 0:  # Si tiene duración
                gantt.append((proc.pid, t, t + dur, "BLOCK"))  # Registrar bloqueo en Gantt
                destino_blocked.append((proc, t + dur))  # Agregar a cola de bloqueados
            else:  # Si es de duración 0 (bloqueo instantáneo)
                proc.advance_burst()  # Avanzar a la siguiente ráfaga
                # Llamar recursivamente para procesar la siguiente ráfaga
                return handle_post(proc, t, destino_cpu, destino_unblock, destino_blocked, gantt)
        return False  # El proceso continúa

    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    
    # FASE DE INICIALIZACIÓN
    # Configurar atributos necesarios para cada proceso
    for idx, p in enumerate(processes):
        # Guardar copia original de bursts para referencia
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        
        # Asignar secuencia para desempates
        p._seq = idx
        
        # Inicializar atributos de tiempo
        p.ready_since = None  # Tiempo desde que está listo
        p.start_time = None  # Tiempo de primera ejecución
        p.completion_time = None  # Tiempo de finalización

    # Inicializar variables del simulador
    time = 0  # Reloj del sistema (tiempo actual de simulación)
    gantt = []  # Lista para almacenar el diagrama de Gantt
    ready = []  # Lista de procesos listos para ejecutar
    blocked = []  # Lista de procesos bloqueados: (proceso, unblock_time)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos a procesar
    arrived = set()  # Conjunto de PIDs que ya llegaron al sistema

    # Buffers de encolado para respetar la prioridad
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    def enqueue_arrivals_leq_t(t):
        """
        FUNCIÓN AUXILIAR: Encolar llegadas hasta tiempo t (incluido) con prioridad de llegada.
        
        Busca todos los procesos que han llegado al sistema hasta el tiempo t
        y los procesa según su tipo de primera ráfaga.
        
        Args:
            t: Tiempo hasta el cual buscar llegadas
        """
        nonlocal completed
        for p in processes:
            # Saltar procesos que ya llegaron
            if p.pid in arrived:
                continue
            
            # Verificar si el proceso llegó y no ha terminado
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)  # Marcar como llegado
                # Procesar llegada usando la función auxiliar
                if handle_post(p, t, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

    def process_unblocks_leq_t(t):
        """
        FUNCIÓN AUXILIAR: Procesar desbloqueos hasta tiempo t (incluido).
        
        Busca todos los procesos que terminan su bloqueo hasta el tiempo t
        y los procesa según su tipo de siguiente ráfaga.
        
        Args:
            t: Tiempo hasta el cual buscar desbloqueos
        """
        nonlocal completed
        for (bp, unb) in blocked[:]:  # Iterar sobre una copia de la lista
            if unb <= t:  # Si el bloqueo termina en este momento o antes
                blocked.remove((bp, unb))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                # Procesar desbloqueo usando la función auxiliar
                if handle_post(bp, t, enq_unblock, enq_unblock, blocked, gantt):
                    completed += 1

    # PROCESAR LLEGADAS INICIALES
    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)  # Agregar procesos de CPU primero
        ready.extend(enq_unblock)  # Luego los de desbloqueo
        enq_cpu.clear()  # Limpiar buffer de CPU
        enq_unblock.clear()  # Limpiar buffer de desbloqueo

    # Variables para controlar la ejecución actual
    current = None  # Proceso actualmente en ejecución
    seg_start = None  # Tiempo de inicio del segmento actual en Gantt

    # BUCLE PRINCIPAL: Simular hasta que todos los procesos terminen
    while completed < n:  # Mientras no se completen todos los procesos
        
        # FASE 1: PROCESAR EVENTOS
        # Procesar desbloqueos que vencen en este momento
        process_unblocks_leq_t(time)
        
        # Procesar llegadas en este momento
        enqueue_arrivals_leq_t(time)

        # FASE 2: VOLCAR BUFFERS A COLA DE LISTOS
        # Volcar buffers a ready respetando prioridades
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)  # Agregar procesos de CPU primero
            ready.extend(enq_unblock)  # Luego los de desbloqueo
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # FASE 3: IDENTIFICAR PROCESOS ELEGIBLES
        # Filtrar procesos que están en ráfaga de CPU y no han terminado
        eligibles = [p for p in ready if p.is_cpu_burst() and not p.is_finished()]
        
        # FASE 4: MANEJAR CPU OCIOSA
        if not eligibles:  # Si no hay procesos elegibles
            # Buscar próximos eventos (llegadas y desbloqueos)
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            
            # Verificar si no hay más eventos futuros
            if not future_arrivals and not future_unblocks:
                break  # Terminar simulación
            
            # Calcular el próximo evento
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else None
            
            # Avanzar tiempo hasta el próximo evento
            if next_event is None:
                time += 1
            elif next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))  # Registrar período IDLE
                time = next_event
            else:
                time += 1
            
            # Limpiar proceso actual
            current = None
            seg_start = None
            continue

        # FASE 5: SELECCIÓN DE PROCESO (CRITERIO SRTF)
        # Ordenar por criterio SRTF con desempates
        eligibles.sort(key=lambda x: (x.get_total_cpu_remaining(), x.arrival_time, x._seq, x.pid))
        candidate = eligibles[0]  # Seleccionar el proceso con menor tiempo total restante

        # FASE 6: CONTROL DE CAMBIOS DE PROCESO EN GANTT
        if current is not candidate:  # Si cambió el proceso
            # Cerrar segmento anterior si existe
            if current is not None and seg_start is not None and time > seg_start:
                gantt.append((current.pid, seg_start, time, "CPU"))
            
            # Cambiar al nuevo proceso
            current = candidate
            seg_start = time  # Marcar inicio del nuevo segmento
            
            # Marcar tiempo de inicio si es la primera vez que se ejecuta
            if current.start_time is None:
                current.start_time = time

        # FASE 7: EJECUTAR PROCESO POR 1 UNIDAD DE TIEMPO
        # Ejecutar 1 tick de CPU (SRTF es expulsivo por unidades)
        current.bursts[current.current_burst_index] -= 1  # Reducir ráfaga actual
        current.remaining_time = current.get_total_cpu_remaining()  # Actualizar tiempo restante
        time += 1  # Avanzar el reloj del sistema

        # FASE 8: VERIFICAR SI TERMINÓ LA RÁFAGA
        if current.bursts[current.current_burst_index] == 0:  # Si terminó la ráfaga de CPU
            # Cerrar segmento de CPU en el diagrama de Gantt
            gantt.append((current.pid, seg_start, time, "CPU"))
            current.advance_burst()  # Avanzar a la siguiente ráfaga
            
            if current.is_finished():  # Si terminó el proceso
                current.completion_time = time
                completed += 1
                current = None  # Liberar CPU
                seg_start = None
            else:  # Si aún tiene ráfagas
                if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
                current = None  # Liberar CPU
                seg_start = None
            
            # Volcar buffers después de terminar ráfaga
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
            continue  # Volver al inicio del bucle

        # FASE 9: VERIFICAR PREEMPCIÓN
        # Procesar eventos que pueden causar preempción
        process_unblocks_leq_t(time)  # Procesar desbloqueos
        enqueue_arrivals_leq_t(time)  # Procesar llegadas
        
        # Volcar buffers después de procesar eventos
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)  # Agregar procesos de CPU primero
            ready.extend(enq_unblock)  # Luego los de desbloqueo
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # FASE 10: VERIFICAR PREEMPCIÓN POR PROCESO MÁS CORTO
        # Re-evaluar si hay un proceso más corto que puede preemptar
        eligibles = [p for p in ready if p.is_cpu_burst() and not p.is_finished()]
        if eligibles:  # Si hay procesos elegibles
            # Ordenar por criterio SRTF
            eligibles.sort(key=lambda x: (x.get_total_cpu_remaining(), x.arrival_time, x._seq, x.pid))
            best = eligibles[0]  # El mejor proceso candidato
            
            # Verificar si debe preemptar al proceso actual
            if best is not current and best.get_total_cpu_remaining() < current.get_total_cpu_remaining():
                # Preemptar: cerrar segmento actual y cambiar proceso
                gantt.append((current.pid, seg_start, time, "CPU"))  # Cerrar segmento actual
                current.ready_since = time  # Marcar tiempo desde que está listo
                enq_cpu.append(current)  # Agregar proceso actual al buffer
                current = None  # Liberar CPU
                seg_start = None
                
                # Volcar buffers inmediatamente
                ready.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo

    # FASE FINAL: CERRAR ÚLTIMO SEGMENTO
    # Cerrar el último segmento del diagrama de Gantt si existe
    if current is not None and seg_start is not None and time > seg_start:
        gantt.append((current.pid, seg_start, time, "CPU"))

    # Retornar resultados de la simulación
    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\algorithm_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox, ttk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt

from utils import historial

from models.process import Process
# Algoritmos sin bloqueos
from algoritmos.fifo import fifo
from algoritmos.sjf import sjf
from algoritmos.srtf import srtf
from algoritmos.roundrobin import round_robin
# Algoritmos con bloqueos
from algoritmos.fifo_blocking import fifo_blocking
from algoritmos.sjf_blocking import sjf_blocking
from algoritmos.srtf_blocking import srtf_blocking
from algoritmos.round_robin_blocking import round_robin_blocking
# Algoritmos de prioridades
from algoritmos.priority import priority
from algoritmos.priority_blocking import priority_blocking

from utils.metricas import calcular_metricas
from utils.excel_export import exportar_a_excel


class AlgorithmScreen(ctk.CTkFrame):
    def __init__(self, master, procesos_data, volver_inicio):
        super().__init__(master)
        self.procesos_data = procesos_data
        self.volver_inicio = volver_inicio
        
        # Variables para almacenar el gráfico actual
        self.current_gantt = None
        self.current_algorithm = None
        self.current_fig = None
        self.current_metricas = None
        self.current_trm = None
        self.current_tem = None
        self.current_quantum = None
        
        # Variables para el zoom
        self.zoom_level = 1.0
        self.original_xlim = None
        self.original_ylim = None
        self.current_ax = None
        self.current_canvas = None
        
        # Variables para el pan (arrastrar)
        self.pan_start_x = None
        self.pan_start_y = None
        self.is_panning = False

        # --- Detectar uso de prioridades ---
        self.usar_prioridades = self._detectar_uso_prioridades()

        # --- Selección de algoritmo ---
        self.label_title = ctk.CTkLabel(self, text="Seleccionar algoritmo", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=10)
        
        # --- Indicador de prioridades ---
        if self.usar_prioridades:
            self.label_prioridades = ctk.CTkLabel(self, text="ℹ️ Ejercicio con prioridades detectado", 
                                                font=("Arial", 12), text_color="blue")
        else:
            self.label_prioridades = ctk.CTkLabel(self, text="ℹ️ Ejercicio sin prioridades", 
                                                font=("Arial", 12), text_color="gray")
        self.label_prioridades.pack(pady=2)

        # Lista base de algoritmos (siempre disponibles)
        self.algoritmos_base = ["FIFO", "SJF", "SRTF", "Round Robin"]
        
        # Algoritmos de prioridades (solo si se usan prioridades)
        if self.usar_prioridades:
            self.algoritmos = self.algoritmos_base + ["Prioridades", "Prioridades con Bloqueos"]
        else:
            self.algoritmos = self.algoritmos_base
        self.selected_algo = ctk.StringVar(value=self.algoritmos[0])
        self.option_menu = ctk.CTkOptionMenu(
            self, values=self.algoritmos, variable=self.selected_algo, command=self._on_algo_change
        )
        self.option_menu.pack(pady=5)

        # --- Botones de control ---
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)
        self.btn_run = ctk.CTkButton(btn_frame, text="Ejecutar", command=self._run_algorithm)
        self.btn_run.pack(side="left", padx=5)
        self.btn_export = ctk.CTkButton(btn_frame, text="Exportar PNG", command=self._export_png, 
                                      fg_color="green", hover_color="#006600")
        self.btn_export.pack(side="left", padx=5)
        self.btn_export_excel = ctk.CTkButton(btn_frame, text="Exportar Excel", command=self._export_excel, 
                                            fg_color="purple", hover_color="#660066")
        self.btn_export_excel.pack(side="left", padx=5)
        self.btn_new = ctk.CTkButton(btn_frame, text="Nuevo ejercicio", command=self.volver_inicio)
        self.btn_new.pack(side="left", padx=5)
        self.btn_exit = ctk.CTkButton(
            btn_frame, text="Salir", fg_color="red", hover_color="#aa0000", command=self._salir
        )
        self.btn_exit.pack(side="left", padx=5)

        # --- Controles de zoom ---
        zoom_frame = ctk.CTkFrame(self)
        zoom_frame.pack(pady=5)
        
        self.label_zoom = ctk.CTkLabel(zoom_frame, text="Zoom:", font=("Arial", 12, "bold"))
        self.label_zoom.pack(side="left", padx=5)
        
        self.btn_zoom_out = ctk.CTkButton(zoom_frame, text="−", command=self._zoom_out, 
                                        width=30, height=30, font=("Arial", 16, "bold"))
        self.btn_zoom_out.pack(side="left", padx=2)
        
        self.label_zoom_level = ctk.CTkLabel(zoom_frame, text="100%", font=("Arial", 12))
        self.label_zoom_level.pack(side="left", padx=5)
        
        self.btn_zoom_in = ctk.CTkButton(zoom_frame, text="+", command=self._zoom_in, 
                                       width=30, height=30, font=("Arial", 16, "bold"))
        self.btn_zoom_in.pack(side="left", padx=2)
        
        self.btn_zoom_reset = ctk.CTkButton(zoom_frame, text="Reset", command=self._zoom_reset, 
                                          width=50, height=30, fg_color="orange", hover_color="#cc6600")
        self.btn_zoom_reset.pack(side="left", padx=5)
        
        self.btn_open_window = ctk.CTkButton(zoom_frame, text="Abrir en Ventana", 
                                           command=self._open_in_window, 
                                           width=120, height=30, 
                                           fg_color="purple", hover_color="#660066")
        self.btn_open_window.pack(side="left", padx=5)
        
        # Etiqueta informativa
        self.label_zoom_info = ctk.CTkLabel(zoom_frame, 
                                          text="💡 Rueda: Zoom | Click+Arrastrar: Mover", 
                                          font=("Arial", 10), text_color="gray")
        self.label_zoom_info.pack(side="left", padx=10)

        # --- Campo quantum (solo si RR) ---
        self.frame_quantum = ctk.CTkFrame(self)
        self.label_quantum = ctk.CTkLabel(self.frame_quantum, text="Quantum:")
        self.label_quantum.pack(side="left", padx=5)
        self.entry_quantum = ctk.CTkEntry(self.frame_quantum, placeholder_text="Ej: 2", width=60)
        self.entry_quantum.pack(side="left", padx=5)

        # --- Tabla BCP ---
        if self.usar_prioridades:
            columns = ("PID", "Llegada", "Prioridad", "CPU", "TR", "TE")
        else:
            columns = ("PID", "Llegada", "CPU", "TR", "TE")
            
        self.tree = ttk.Treeview(self, columns=columns, show="headings", height=8)
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=80, anchor="center")
        self.tree.pack(pady=10, fill="x")

        # --- Label promedios ---
        self.label_promedios = ctk.CTkLabel(self, text="TRM: -    |    TEM: -", font=("Arial", 14))
        self.label_promedios.pack(pady=5)

        # --- Frame gráfico ---
        self.frame_gantt = ctk.CTkFrame(self)
        self.frame_gantt.pack(pady=10, fill="both", expand=True)

    def _detectar_uso_prioridades(self):
        """Detecta si algún proceso tiene prioridad > 0 (diferente a la prioridad por defecto)."""
        for proceso in self.procesos_data:
            if proceso.get("priority", 0) > 0:
                return True
        return False

    def _on_algo_change(self, value):
        if value == "Round Robin":
            self.frame_quantum.pack(before=self.tree, pady=5)
        else:
            self.frame_quantum.pack_forget()

    def _run_algorithm(self):
        # Crear copias de los procesos para no modificar los originales
        from copy import deepcopy
        procesos = [Process(p["pid"], p["arrival_time"], p["bursts"], p.get("priority", 0)) for p in self.procesos_data]
        algo = self.selected_algo.get()

        try:
            if algo == "FIFO":
                gantt, result = fifo_blocking(procesos)
            elif algo == "SJF":
                gantt, result = sjf_blocking(procesos)
            elif algo == "SRTF":
                gantt, result = srtf_blocking(procesos)
            elif algo == "Round Robin":
                quantum = self._get_quantum()
                if quantum is None:
                    return
                # Detectar si los procesos tienen bloqueos
                tiene_bloqueos = any(len(p["bursts"]) > 1 for p in self.procesos_data)
                if tiene_bloqueos:
                    gantt, result = round_robin_blocking(procesos, quantum)
                else:
                    gantt, result = round_robin(procesos, quantum)
            elif algo == "Prioridades":
                # Detectar si los procesos tienen bloqueos
                tiene_bloqueos = any(len(p["bursts"]) > 1 for p in self.procesos_data)
                if tiene_bloqueos:
                    gantt, result = priority_blocking(procesos)
                else:
                    gantt, result = priority(procesos)
            elif algo == "Prioridades con Bloqueos":
                gantt, result = priority_blocking(procesos)
        except Exception as e:
            messagebox.showerror("Error", f"Ocurrió un error al ejecutar: {e}")
            return

        # Calcular métricas
        metricas, trm, tem = calcular_metricas(result)

        # Actualizar tabla
        for row in self.tree.get_children():
            self.tree.delete(row)
        for m in metricas:
            if self.usar_prioridades:
                # Obtener la prioridad del proceso original
                priority = next((p.get("priority", 0) for p in self.procesos_data if p["pid"] == m["PID"]), 0)
                self.tree.insert("", "end", values=(m["PID"], m["Llegada"], priority, m["CPU"], m["TR"], m["TE"]))
            else:
                # Sin columna de prioridad
                self.tree.insert("", "end", values=(m["PID"], m["Llegada"], m["CPU"], m["TR"], m["TE"]))

        # Actualizar promedios
        self.label_promedios.configure(
            text=f"TRM (Tiempo de Respuesta Medio): {trm:.2f}    |    TEM (Tiempo de Espera Medio): {tem:.2f}"
        )

        # Almacenar datos del gráfico para exportación
        self.current_gantt = gantt
        self.current_algorithm = algo
        self.current_metricas = metricas
        self.current_trm = trm
        self.current_tem = tem
        
        # Obtener quantum si es Round Robin
        if algo == "Round Robin":
            self.current_quantum = self._get_quantum()
        else:
            self.current_quantum = None
        
        # Mostrar gráfico
        self._mostrar_gantt_embebido(gantt, algo)

    def _get_quantum(self):
        try:
            quantum = int(self.entry_quantum.get())
            if quantum <= 0:
                raise ValueError
            return quantum
        except ValueError:
            messagebox.showerror("Error", "Ingrese un quantum válido (> 0)")
            return None

    def _mostrar_gantt_embebido(self, gantt_chart, algo):
        for widget in self.frame_gantt.winfo_children():
            widget.destroy()

        norm = []
        for seg in gantt_chart:
            if len(seg) == 3:
                pid, start, end = seg
                tipo = "CPU" if pid != "IDLE" else "IDLE"
                norm.append((pid, start, end, tipo))
            elif len(seg) == 4:
                norm.append(seg)

        # Ajustar el tamaño del gráfico según el número de procesos y duración total
        num_procesos = len(set(pid for pid, _, _, tipo in norm if pid != "IDLE"))
        max_time = max(end for _, _, end, _ in norm) if norm else 1
        
        # Calcular dimensiones adaptativas - más ancho para mostrar todos los ticks
        fig_width = max(15, max_time * 0.25)  # Ancho basado en duración total, más generoso
        fig_height = max(4, num_procesos * 0.8)  # Altura basada en número de procesos
        
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))
        
        procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
        procesos_unicos = list(dict.fromkeys(procesos_unicos))
        y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

        colors = {}
        color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

        for pid, start, end, tipo in norm:
            if tipo == "IDLE":
                color = "lightgray"
                hatch = None
                y = -1
                alpha = 0.7
            elif tipo == "BLOCK":
                color = "darkred"
                hatch = "///"
                y = y_positions.get(pid, 0)
                alpha = 0.8
            else:  # CPU
                if pid not in colors:
                    colors[pid] = color_palette(len(colors))
                color = colors[pid]
                hatch = None
                y = y_positions.get(pid, 0)
                alpha = 1.0

            ax.barh(y, end - start, left=start, height=0.6, color=color, 
                   edgecolor='black', hatch=hatch, alpha=alpha)
            
            if tipo != "IDLE":
                # Mostrar el PID y el tipo de ráfaga
                text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
                ax.text((start + end) / 2, y, text, ha='center', va='center',
                        fontsize=7, color="white" if tipo == "BLOCK" else "black",
                        weight="bold" if tipo == "BLOCK" else "normal")

        if procesos_unicos:
            ax.set_yticks(list(y_positions.values()))
            ax.set_yticklabels(list(y_positions.keys()))
        else:
            ax.set_yticks([])

        if norm:
            max_time = max(end for _, _, end, _ in norm)
            
            # Mostrar TODOS los ticks del 0 al tiempo máximo
            ax.set_xticks(range(0, max_time + 1))
            ax.set_xlim(0, max_time)
        ax.set_xlabel("Tiempo")
        ax.set_ylabel("Procesos")
        ax.set_title(f"Diagrama de Gantt - {algo}")
        ax.grid(True, axis='x', linestyle='--', alpha=0.6)
        
        # Agregar leyenda explicativa
        legend_elements = [
            plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
            plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
            plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
        ]
        ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))

        # Ajustar el layout para mejor uso del espacio
        plt.tight_layout()
        
        # Crear canvas directamente en el frame
        canvas = FigureCanvasTkAgg(fig, master=self.frame_gantt)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Almacenar la figura y canvas para zoom
        self.current_fig = fig
        self.current_ax = ax
        self.current_canvas = canvas
        
        # Guardar los límites originales para el zoom
        self.original_xlim = ax.get_xlim()
        self.original_ylim = ax.get_ylim()
        
        # Resetear el nivel de zoom
        self.zoom_level = 1.0
        self._update_zoom_label()
        
        # Variables para el pan (arrastrar)
        self.pan_start_x = None
        self.pan_start_y = None
        self.is_panning = False
        
        # Configurar eventos de mouse
        canvas.mpl_connect("scroll_event", self._on_mouse_wheel)
        canvas.mpl_connect("button_press_event", self._on_mouse_press)
        canvas.mpl_connect("button_release_event", self._on_mouse_release)
        canvas.mpl_connect("motion_notify_event", self._on_mouse_motion)

    def _export_png(self):
        """Exporta el gráfico actual como PNG."""
        if self.current_fig is None:
            messagebox.showwarning("Advertencia", "No hay gráfico para exportar. Ejecute un algoritmo primero.")
            return
        
        try:
            from tkinter import filedialog
            import os
            from datetime import datetime
            
            # Generar nombre de archivo con timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"gantt_{self.current_algorithm}_{timestamp}.png"
            
            # Abrir diálogo para seleccionar ubicación
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("All files", "*.*")],
                initialfile=default_filename,
                title="Guardar gráfico como PNG"
            )
            
            if file_path:
                # Exportar con alta resolución
                self.current_fig.savefig(file_path, dpi=300, bbox_inches='tight', 
                                       facecolor='white', edgecolor='none')
                messagebox.showinfo("Éxito", f"Gráfico exportado exitosamente:\n{file_path}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar el gráfico:\n{str(e)}")

    def _export_excel(self):
        """Exporta los resultados actuales a un archivo Excel."""
        if (self.current_gantt is None or self.current_algorithm is None or 
            self.current_metricas is None):
            messagebox.showwarning("Advertencia", "No hay datos para exportar. Ejecute un algoritmo primero.")
            return
        
        try:
            from tkinter import filedialog
            import os
            from datetime import datetime
            
            # Generar nombre de archivo con timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"resultados_{self.current_algorithm}_{timestamp}.xlsx"
            
            # Abrir diálogo para seleccionar ubicación
            file_path = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
                initialfile=default_filename,
                title="Guardar resultados como Excel"
            )
            
            if file_path:
                # Crear archivo temporal
                temp_file = exportar_a_excel(
                    procesos_data=self.procesos_data,
                    algoritmo=self.current_algorithm,
                    gantt_data=self.current_gantt,
                    metricas=self.current_metricas,
                    trm=self.current_trm,
                    tem=self.current_tem,
                    quantum=self.current_quantum
                )
                
                # Mover el archivo a la ubicación seleccionada
                import shutil
                shutil.move(temp_file, file_path)
                
                messagebox.showinfo("Éxito", f"Resultados exportados exitosamente a:\n{file_path}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar a Excel:\n{str(e)}")

    def _salir(self):
        self.master.destroy()

    def _zoom_in(self):
        """Aumenta el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        
        self.zoom_level *= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_out(self):
        """Disminuye el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        
        self.zoom_level /= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_reset(self):
        """Resetea el zoom a la vista original."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        
        self.zoom_level = 1.0
        self.current_ax.set_xlim(self.original_xlim)
        self.current_ax.set_ylim(self.original_ylim)
        self.current_canvas.draw()
        self._update_zoom_label()
        
        # Resetear variables de pan
        self.is_panning = False
        self.pan_start_x = None
        self.pan_start_y = None

    def _apply_zoom(self):
        """Aplica el nivel de zoom actual al gráfico."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        
        # Calcular los nuevos límites basados en el zoom
        x_center = (self.original_xlim[0] + self.original_xlim[1]) / 2
        y_center = (self.original_ylim[0] + self.original_ylim[1]) / 2
        
        x_range = (self.original_xlim[1] - self.original_xlim[0]) / self.zoom_level
        y_range = (self.original_ylim[1] - self.original_ylim[0]) / self.zoom_level
        
        new_xlim = (x_center - x_range/2, x_center + x_range/2)
        new_ylim = (y_center - y_range/2, y_center + y_range/2)
        
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()

    def _update_zoom_label(self):
        """Actualiza la etiqueta que muestra el nivel de zoom actual."""
        self.label_zoom_level.configure(text=f"{int(self.zoom_level * 100)}%")

    def _on_mouse_wheel(self, event):
        """Maneja el evento de la rueda del mouse para zoom."""
        if self.current_ax is None:
            return
        
        # Determinar si hacer zoom in o out
        # Manejar diferentes plataformas (Windows usa delta, Linux/Mac usan step)
        delta = getattr(event, 'delta', None)
        if delta is None:
            delta = getattr(event, 'step', 0)
        
        if delta > 0:
            self._zoom_in()
        else:
            self._zoom_out()

    def _on_mouse_press(self, event):
        """Maneja el evento de presionar el botón del mouse para iniciar pan."""
        if self.current_ax is None or event.inaxes != self.current_ax:
            return
        
        if event.button == 1:  # Botón izquierdo del mouse
            self.is_panning = True
            self.pan_start_x = event.xdata
            self.pan_start_y = event.ydata
            # Cambiar el cursor para indicar que se puede arrastrar
            self.current_canvas.get_tk_widget().configure(cursor="fleur")

    def _on_mouse_release(self, event):
        """Maneja el evento de soltar el botón del mouse para terminar pan."""
        if self.current_ax is None:
            return
        
        if event.button == 1:  # Botón izquierdo del mouse
            self.is_panning = False
            self.pan_start_x = None
            self.pan_start_y = None
            # Restaurar el cursor normal
            self.current_canvas.get_tk_widget().configure(cursor="")

    def _on_mouse_motion(self, event):
        """Maneja el movimiento del mouse para pan."""
        if (self.current_ax is None or not self.is_panning or 
            event.inaxes != self.current_ax or 
            self.pan_start_x is None or self.pan_start_y is None):
            return
        
        # Calcular el desplazamiento
        dx = event.xdata - self.pan_start_x
        dy = event.ydata - self.pan_start_y
        
        # Obtener los límites actuales
        xlim = self.current_ax.get_xlim()
        ylim = self.current_ax.get_ylim()
        
        # Aplicar el desplazamiento
        new_xlim = (xlim[0] - dx, xlim[1] - dx)
        new_ylim = (ylim[0] - dy, ylim[1] - dy)
        
        # Actualizar los límites
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()
        
        # Actualizar la posición de inicio para el siguiente movimiento
        self.pan_start_x = event.xdata
        self.pan_start_y = event.ydata

    def _open_in_window(self):
        """Abre el gráfico actual en una ventana separada."""
        if self.current_gantt is None or self.current_algorithm is None:
            messagebox.showwarning("Advertencia", "No hay gráfico para abrir. Ejecute un algoritmo primero.")
            return
        
        # Crear y mostrar la ventana separada
        GanttWindow(self.current_gantt, self.current_algorithm)


class GanttWindow:
    """Ventana separada para mostrar el diagrama de Gantt con zoom y pan."""
    
    def __init__(self, gantt_chart, algorithm):
        self.gantt_chart = gantt_chart
        self.algorithm = algorithm
        
        # Crear ventana
        self.window = ctk.CTkToplevel()
        self.window.title(f"Diagrama de Gantt - {algorithm}")
        self.window.geometry("1200x800")
        self.window.resizable(True, True)
        
        # Variables para zoom y pan
        self.zoom_level = 1.0
        self.original_xlim = None
        self.original_ylim = None
        self.current_ax = None
        self.current_canvas = None
        self.pan_start_x = None
        self.pan_start_y = None
        self.is_panning = False
        
        self._create_interface()
        self._create_gantt()
        
        # Centrar la ventana
        self.window.transient()
        self.window.grab_set()
        
    def _create_interface(self):
        """Crea la interfaz de la ventana."""
        # Frame de controles
        control_frame = ctk.CTkFrame(self.window)
        control_frame.pack(fill="x", padx=10, pady=5)
        
        # Título
        title_label = ctk.CTkLabel(control_frame, text=f"Diagrama de Gantt - {self.algorithm}", 
                                 font=("Arial", 16, "bold"))
        title_label.pack(side="left", padx=10)
        
        # Controles de zoom
        zoom_frame = ctk.CTkFrame(control_frame)
        zoom_frame.pack(side="right", padx=10)
        
        ctk.CTkLabel(zoom_frame, text="Zoom:", font=("Arial", 12, "bold")).pack(side="left", padx=5)
        
        btn_zoom_out = ctk.CTkButton(zoom_frame, text="−", command=self._zoom_out, 
                                   width=30, height=30, font=("Arial", 16, "bold"))
        btn_zoom_out.pack(side="left", padx=2)
        
        self.label_zoom_level = ctk.CTkLabel(zoom_frame, text="100%", font=("Arial", 12))
        self.label_zoom_level.pack(side="left", padx=5)
        
        btn_zoom_in = ctk.CTkButton(zoom_frame, text="+", command=self._zoom_in, 
                                  width=30, height=30, font=("Arial", 16, "bold"))
        btn_zoom_in.pack(side="left", padx=2)
        
        btn_zoom_reset = ctk.CTkButton(zoom_frame, text="Reset", command=self._zoom_reset, 
                                     width=50, height=30, fg_color="orange", hover_color="#cc6600")
        btn_zoom_reset.pack(side="left", padx=5)
        
        # Frame para el gráfico
        self.graph_frame = ctk.CTkFrame(self.window)
        self.graph_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
    def _create_gantt(self):
        """Crea el diagrama de Gantt en la ventana."""
        import matplotlib.pyplot as plt
        from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
        
        # Normalizar datos del gantt
        norm = []
        for seg in self.gantt_chart:
            if len(seg) == 3:
                pid, start, end = seg
                tipo = "CPU" if pid != "IDLE" else "IDLE"
                norm.append((pid, start, end, tipo))
            elif len(seg) == 4:
                norm.append(seg)

        # Calcular dimensiones
        num_procesos = len(set(pid for pid, _, _, tipo in norm if pid != "IDLE"))
        max_time = max(end for _, _, end, _ in norm) if norm else 1
        
        fig_width = max(15, max_time * 0.25)
        fig_height = max(6, num_procesos * 0.8)
        
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))
        
        # Procesar datos
        procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
        procesos_unicos = list(dict.fromkeys(procesos_unicos))
        y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

        colors = {}
        color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

        # Dibujar barras
        for pid, start, end, tipo in norm:
            if tipo == "IDLE":
                color = "lightgray"
                hatch = None
                y = -1
                alpha = 0.7
            elif tipo == "BLOCK":
                color = "darkred"
                hatch = "///"
                y = y_positions.get(pid, 0)
                alpha = 0.8
            else:  # CPU
                if pid not in colors:
                    colors[pid] = color_palette(len(colors))
                color = colors[pid]
                hatch = None
                y = y_positions.get(pid, 0)
                alpha = 1.0

            ax.barh(y, end - start, left=start, height=0.6, color=color, 
                   edgecolor='black', hatch=hatch, alpha=alpha)
            
            if tipo != "IDLE":
                text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
                ax.text((start + end) / 2, y, text, ha='center', va='center',
                        fontsize=7, color="white" if tipo == "BLOCK" else "black",
                        weight="bold" if tipo == "BLOCK" else "normal")

        # Configurar ejes
        if procesos_unicos:
            ax.set_yticks(list(y_positions.values()))
            ax.set_yticklabels(list(y_positions.keys()))
        else:
            ax.set_yticks([])

        if norm:
            max_time = max(end for _, _, end, _ in norm)
            ax.set_xticks(range(0, max_time + 1))
            ax.set_xlim(0, max_time)
            
        ax.set_xlabel("Tiempo")
        ax.set_ylabel("Procesos")
        ax.set_title(f"Diagrama de Gantt - {self.algorithm}")
        ax.grid(True, axis='x', linestyle='--', alpha=0.6)
        
        # Leyenda
        legend_elements = [
            plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
            plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
            plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
        ]
        ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))

        plt.tight_layout()
        
        # Crear canvas
        canvas = FigureCanvasTkAgg(fig, master=self.graph_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Almacenar referencias
        self.current_fig = fig
        self.current_ax = ax
        self.current_canvas = canvas
        self.original_xlim = ax.get_xlim()
        self.original_ylim = ax.get_ylim()
        
        # Configurar eventos de mouse
        canvas.mpl_connect("scroll_event", self._on_mouse_wheel)
        canvas.mpl_connect("button_press_event", self._on_mouse_press)
        canvas.mpl_connect("button_release_event", self._on_mouse_release)
        canvas.mpl_connect("motion_notify_event", self._on_mouse_motion)
        
    def _zoom_in(self):
        """Aumenta el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        self.zoom_level *= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_out(self):
        """Disminuye el nivel de zoom del gráfico."""
        if self.current_ax is None:
            return
        self.zoom_level /= 1.2
        self._apply_zoom()
        self._update_zoom_label()

    def _zoom_reset(self):
        """Resetea el zoom a la vista original."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        self.zoom_level = 1.0
        self.current_ax.set_xlim(self.original_xlim)
        self.current_ax.set_ylim(self.original_ylim)
        self.current_canvas.draw()
        self._update_zoom_label()
        self.is_panning = False
        self.pan_start_x = None
        self.pan_start_y = None

    def _apply_zoom(self):
        """Aplica el nivel de zoom actual al gráfico."""
        if self.current_ax is None or self.original_xlim is None or self.original_ylim is None:
            return
        x_center = (self.original_xlim[0] + self.original_xlim[1]) / 2
        y_center = (self.original_ylim[0] + self.original_ylim[1]) / 2
        x_range = (self.original_xlim[1] - self.original_xlim[0]) / self.zoom_level
        y_range = (self.original_ylim[1] - self.original_ylim[0]) / self.zoom_level
        new_xlim = (x_center - x_range/2, x_center + x_range/2)
        new_ylim = (y_center - y_range/2, y_center + y_range/2)
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()

    def _update_zoom_label(self):
        """Actualiza la etiqueta que muestra el nivel de zoom actual."""
        self.label_zoom_level.configure(text=f"{int(self.zoom_level * 100)}%")

    def _on_mouse_wheel(self, event):
        """Maneja el evento de la rueda del mouse para zoom."""
        if self.current_ax is None:
            return
        if event.delta > 0:
            self._zoom_in()
        else:
            self._zoom_out()

    def _on_mouse_press(self, event):
        """Maneja el evento de presionar el botón del mouse para iniciar pan."""
        if self.current_ax is None or event.inaxes != self.current_ax:
            return
        if event.button == 1:
            self.is_panning = True
            self.pan_start_x = event.xdata
            self.pan_start_y = event.ydata
            self.current_canvas.get_tk_widget().configure(cursor="fleur")

    def _on_mouse_release(self, event):
        """Maneja el evento de soltar el botón del mouse para terminar pan."""
        if self.current_ax is None:
            return
        if event.button == 1:
            self.is_panning = False
            self.pan_start_x = None
            self.pan_start_y = None
            self.current_canvas.get_tk_widget().configure(cursor="")

    def _on_mouse_motion(self, event):
        """Maneja el movimiento del mouse para pan."""
        if (self.current_ax is None or not self.is_panning or 
            event.inaxes != self.current_ax or 
            self.pan_start_x is None or self.pan_start_y is None):
            return
        dx = event.xdata - self.pan_start_x
        dy = event.ydata - self.pan_start_y
        xlim = self.current_ax.get_xlim()
        ylim = self.current_ax.get_ylim()
        new_xlim = (xlim[0] - dx, xlim[1] - dx)
        new_ylim = (ylim[0] - dy, ylim[1] - dy)
        self.current_ax.set_xlim(new_xlim)
        self.current_ax.set_ylim(new_ylim)
        self.current_canvas.draw()
        self.pan_start_x = event.xdata
        self.pan_start_y = event.ydata

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\data_input_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox, ttk
from utils import historial

class DataInputScreen(ctk.CTkFrame):
    def __init__(self, master, nombres_procesos, on_continue):
        super().__init__(master)
        self.nombres_procesos = nombres_procesos
        self.on_continue = on_continue

        # Estructura de datos para múltiples ráfagas
        self.process_data = {}  # {nombre: {"arrival": int, "priority": int, "bursts": [int, int, ...]}}
        
        self.label_title = ctk.CTkLabel(self, text="Ingresar datos de procesos", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=20)

        # Frame con scroll para muchos procesos
        self.scroll_frame = ctk.CTkScrollableFrame(self, height=400)
        self.scroll_frame.pack(padx=10, pady=10, fill="both", expand=True)

        self._build_rows()

        # Botones de historial
        btn_historial_frame = ctk.CTkFrame(self)
        btn_historial_frame.pack(pady=10)
        
        self.btn_save_config = ctk.CTkButton(btn_historial_frame, text="Guardar configuración", 
                                           command=self._guardar_configuracion, fg_color="blue", hover_color="#003366")
        self.btn_save_config.pack(side="left", padx=5)
        
        self.btn_load_config = ctk.CTkButton(btn_historial_frame, text="Cargar configuración", 
                                           command=self._cargar_configuracion, fg_color="orange", hover_color="#cc6600")
        self.btn_load_config.pack(side="left", padx=5)

        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _build_rows(self):
        for nombre in self.nombres_procesos:
            # Inicializar datos del proceso
            self.process_data[nombre] = {
                "arrival": None,
                "priority": 0,  # Prioridad por defecto
                "bursts": []
            }
            
            # Frame principal del proceso
            process_frame = ctk.CTkFrame(self.scroll_frame)
            process_frame.pack(pady=10, fill="x", padx=5)
            
            # Título del proceso
            title_frame = ctk.CTkFrame(process_frame)
            title_frame.pack(fill="x", padx=5, pady=5)
            
            ctk.CTkLabel(title_frame, text=f"Proceso: {nombre}", font=("Arial", 14, "bold")).pack(side="left")
            
            # Tiempo de llegada
            arrival_frame = ctk.CTkFrame(process_frame)
            arrival_frame.pack(fill="x", padx=5, pady=2)
            
            ctk.CTkLabel(arrival_frame, text="Tiempo de llegada:", width=120).pack(side="left", padx=5)
            arrival_entry = ctk.CTkEntry(arrival_frame, placeholder_text="Ej: 0", width=80)
            arrival_entry.pack(side="left", padx=5)
            
            # Prioridad
            priority_frame = ctk.CTkFrame(process_frame)
            priority_frame.pack(fill="x", padx=5, pady=2)
            
            ctk.CTkLabel(priority_frame, text="Prioridad (0-9):", width=120).pack(side="left", padx=5)
            priority_entry = ctk.CTkEntry(priority_frame, placeholder_text="Ej: 5", width=80)
            priority_entry.pack(side="left", padx=5)
            
            # Tooltip para explicar prioridades
            ctk.CTkLabel(priority_frame, text="(9=mayor prioridad, 0=menor prioridad)", 
                        font=("Arial", 10), text_color="gray").pack(side="left", padx=10)
            
            # Frame para las ráfagas
            bursts_frame = ctk.CTkFrame(process_frame)
            bursts_frame.pack(fill="x", padx=5, pady=5)
            
            ctk.CTkLabel(bursts_frame, text="Secuencia de ráfagas:", font=("Arial", 12, "bold")).pack(anchor="w", padx=5, pady=2)
            
            # Frame para los controles de ráfagas
            controls_frame = ctk.CTkFrame(bursts_frame)
            controls_frame.pack(fill="x", padx=5, pady=2)
            
            # Botón para agregar ráfaga
            add_btn = ctk.CTkButton(controls_frame, text="+ Agregar ráfaga", width=120, 
                                   command=lambda n=nombre: self._add_burst(n))
            add_btn.pack(side="left", padx=5)
            
            # Frame para mostrar las ráfagas
            bursts_display_frame = ctk.CTkFrame(bursts_frame)
            bursts_display_frame.pack(fill="x", padx=5, pady=5)
            
            # Almacenar referencias para este proceso
            self.process_data[nombre]["arrival_entry"] = arrival_entry
            self.process_data[nombre]["priority_entry"] = priority_entry
            self.process_data[nombre]["bursts_display_frame"] = bursts_display_frame
            self.process_data[nombre]["burst_entries"] = []
            
            # Agregar primera ráfaga de CPU por defecto
            self._add_burst(nombre, burst_type="CPU")

    def _add_burst(self, process_name, burst_type=None):
        """Agrega una nueva ráfaga al proceso especificado."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        display_frame = process_info["bursts_display_frame"]
        
        # Determinar el tipo de ráfaga si no se especifica
        if burst_type is None:
            # Si no hay ráfagas, empezar con CPU
            if not burst_entries:
                burst_type = "CPU"
            else:
                # Alternar entre CPU y Bloqueo
                last_type = burst_entries[-1]["type"]
                burst_type = "Bloqueo" if last_type == "CPU" else "CPU"
        
        # Frame para esta ráfaga
        burst_frame = ctk.CTkFrame(display_frame)
        burst_frame.pack(fill="x", padx=2, pady=2)
        
        # Tipo de ráfaga
        type_label = ctk.CTkLabel(burst_frame, text=f"{burst_type}:", width=80)
        type_label.pack(side="left", padx=5)
        
        # Campo de entrada
        burst_entry = ctk.CTkEntry(burst_frame, placeholder_text=f"Duración {burst_type}", width=100)
        burst_entry.pack(side="left", padx=5)
        
        # Botón para eliminar
        remove_btn = ctk.CTkButton(burst_frame, text="✕", width=30, height=25,
                                  command=lambda: self._remove_burst(process_name, burst_frame))
        remove_btn.pack(side="left", padx=5)
        
        # Almacenar información de la ráfaga
        burst_info = {
            "frame": burst_frame,
            "entry": burst_entry,
            "type": burst_type
        }
        burst_entries.append(burst_info)
        
        # Actualizar la secuencia visual
        self._update_sequence_display(process_name)
    
    def _remove_burst(self, process_name, burst_frame):
        """Elimina una ráfaga del proceso especificado."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        
        # Encontrar y eliminar la ráfaga
        for i, burst_info in enumerate(burst_entries):
            if burst_info["frame"] == burst_frame:
                burst_entries.pop(i)
                burst_frame.destroy()
                break
        
        # Actualizar la secuencia visual
        self._update_sequence_display(process_name)
    
    def _update_sequence_display(self, process_name):
        """Actualiza la visualización de la secuencia de ráfagas."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        
        # Crear texto descriptivo de la secuencia
        if burst_entries:
            sequence_parts = []
            for i, burst_info in enumerate(burst_entries):
                sequence_parts.append(f"{burst_info['type']}{i+1}")
            sequence_text = " → ".join(sequence_parts)
        else:
            sequence_text = "Sin ráfagas"
        
        # Actualizar o crear label de secuencia
        if "sequence_label" not in process_info:
            sequence_label = ctk.CTkLabel(process_info["bursts_display_frame"], 
                                        text=f"Secuencia: {sequence_text}", 
                                        font=("Arial", 10, "italic"))
            sequence_label.pack(anchor="w", padx=5, pady=2)
            process_info["sequence_label"] = sequence_label
        else:
            process_info["sequence_label"].configure(text=f"Secuencia: {sequence_text}")

    def _continue_clicked(self):
        procesos_data = []
        try:
            for nombre in self.nombres_procesos:
                process_info = self.process_data[nombre]
                
                # Validar tiempo de llegada
                arrival_str = process_info["arrival_entry"].get().strip()
                if not arrival_str:
                    raise ValueError(f"Proceso {nombre}: Tiempo de llegada requerido")
                
                arrival_time = int(arrival_str)
                if arrival_time < 0:
                    raise ValueError(f"Proceso {nombre}: Tiempo de llegada debe ser ≥ 0")
                
                # Validar prioridad
                priority_str = process_info["priority_entry"].get().strip()
                if not priority_str:
                    priority = 0  # Prioridad por defecto
                else:
                    priority = int(priority_str)
                    if priority < 0 or priority > 9:
                        raise ValueError(f"Proceso {nombre}: Prioridad debe estar entre 0 y 9")
                
                # Validar ráfagas
                burst_entries = process_info["burst_entries"]
                if not burst_entries:
                    raise ValueError(f"Proceso {nombre}: Debe tener al menos una ráfaga")
                
                bursts = []
                for burst_info in burst_entries:
                    duration_str = burst_info["entry"].get().strip()
                    if not duration_str:
                        raise ValueError(f"Proceso {nombre}: Todas las duraciones son requeridas")
                    
                    duration = int(duration_str)
                    if duration < 0:
                        raise ValueError(f"Proceso {nombre}: Las duraciones deben ser ≥ 0")
                    
                    bursts.append(duration)
                
                # Validar que termine con CPU (índice par)
                if len(bursts) % 2 == 0:
                    # Termina con CPU, está bien
                    pass
                else:
                    # Termina con bloqueo, agregar CPU de 0
                    bursts.append(0)
                
                # Validar que tenga al menos una ráfaga de CPU
                cpu_bursts = [bursts[i] for i in range(0, len(bursts), 2)]
                if not any(cpu > 0 for cpu in cpu_bursts):
                    raise ValueError(f"Proceso {nombre}: Debe tener al menos una ráfaga de CPU > 0")
                
                procesos_data.append({
                    "pid": nombre, 
                    "arrival_time": arrival_time, 
                    "priority": priority,
                    "bursts": bursts
                })

        except ValueError as e:
            messagebox.showerror("Error de validación", str(e))
            return
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado: {e}")
            return

        self.on_continue(procesos_data)

    def _guardar_configuracion(self):
        """Guarda la configuración actual de inputs."""
        # Crear ventana de diálogo para ingresar nombre de
        dialog = ctk.CTkToplevel(self)
        dialog.title("Guardar configuración")
        dialog.geometry("400x150")
        dialog.transient(self)
        dialog.grab_set()
        
        # Centrar la ventana
        dialog.geometry("+%d+%d" % (self.winfo_rootx() + 50, self.winfo_rooty() + 50))
        
        # Frame principal
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Label y entry para el nombre
        label_nombre = ctk.CTkLabel(main_frame, text="Nombre de la configuración:", font=("Arial", 12))
        label_nombre.pack(pady=(0, 10))
        
        entry_nombre = ctk.CTkEntry(main_frame, placeholder_text="Ej: Configuración 3 procesos", width=300)
        entry_nombre.pack(pady=(0, 20))
        entry_nombre.focus()
        
        # Botones
        btn_frame = ctk.CTkFrame(main_frame)
        btn_frame.pack()
        
        def guardar():
            nombre = entry_nombre.get().strip()
            if not nombre:
                messagebox.showerror("Error", "Debe ingresar un nombre para la configuración")
                return
            
            try:
                # Recopilar datos actuales
                config_procesos = []
                for nombre_proceso in self.nombres_procesos:
                    process_info = self.process_data[nombre_proceso]
                    
                    # Obtener tiempo de llegada
                    arrival_str = process_info["arrival_entry"].get().strip()
                    arrival = int(arrival_str) if arrival_str else 0
                    
                    # Obtener prioridad
                    priority_str = process_info["priority_entry"].get().strip()
                    priority = int(priority_str) if priority_str else 0
                    
                    # Obtener ráfagas
                    bursts = []
                    for burst_info in process_info["burst_entries"]:
                        duration_str = burst_info["entry"].get().strip()
                        duration = int(duration_str) if duration_str else 0
                        bursts.append(duration)
                    
                    config_procesos.append({
                        "nombre": nombre_proceso,
                        "arrival": arrival,
                        "priority": priority,
                        "bursts": bursts
                    })
                
                # Guardar en historial
                historial.guardar_input_config(nombre, config_procesos)
                
                messagebox.showinfo("Éxito", f"Configuración '{nombre}' guardada exitosamente")
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Error", "Error en los datos. Asegúrese de que todos los valores sean números válidos.")
            except Exception as e:
                messagebox.showerror("Error", f"Error al guardar la configuración: {e}")
        
        btn_guardar = ctk.CTkButton(btn_frame, text="Guardar", command=guardar, fg_color="green")
        btn_guardar.pack(side="left", padx=5)
        
        btn_cancelar = ctk.CTkButton(btn_frame, text="Cancelar", command=dialog.destroy)
        btn_cancelar.pack(side="left", padx=5)
        
        # Permitir guardar con Enter
        entry_nombre.bind("<Return>", lambda e: guardar())

    def _cargar_configuracion(self):
        """Carga una configuración guardada."""
        # Obtener lista de configuraciones guardadas
        configs = historial.listar_input_configs()
        
        if not configs:
            messagebox.showinfo("Información", "No hay configuraciones guardadas")
            return
        
        # Crear ventana de diálogo para seleccionar configuración
        dialog = ctk.CTkToplevel(self)
        dialog.title("Cargar configuración")
        dialog.geometry("600x400")
        dialog.transient(self)
        dialog.grab_set()
        
        # Centrar la ventana
        dialog.geometry("+%d+%d" % (self.winfo_rootx() + 50, self.winfo_rooty() + 50))
        
        # Frame principal
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Título
        label_titulo = ctk.CTkLabel(main_frame, text="Seleccionar configuración a cargar:", font=("Arial", 14, "bold"))
        label_titulo.pack(pady=(0, 10))
        
        # Frame para la lista
        list_frame = ctk.CTkFrame(main_frame)
        list_frame.pack(fill="both", expand=True, pady=(0, 10))
        
        # Crear Treeview para mostrar las configuraciones
        columns = ("Nombre", "Fecha", "Procesos")
        tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        # Configurar columnas
        tree.heading("Nombre", text="Nombre")
        tree.heading("Fecha", text="Fecha")
        tree.heading("Procesos", text="N° Procesos")
        
        tree.column("Nombre", width=300)
        tree.column("Fecha", width=150)
        tree.column("Procesos", width=100)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        
        # Empaquetar
        tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Llenar la lista
        for indice, nombre, fecha, num_procesos in configs:
            # Formatear fecha para mostrar
            try:
                from datetime import datetime
                dt = datetime.fromisoformat(fecha)
                fecha_formateada = dt.strftime("%d/%m/%Y %H:%M")
            except:
                fecha_formateada = fecha
            
            tree.insert("", "end", values=(nombre, fecha_formateada, num_procesos), tags=(str(indice),))
        
        # Botones
        btn_frame = ctk.CTkFrame(main_frame)
        btn_frame.pack()
        
        def cargar():
            seleccion = tree.selection()
            if not seleccion:
                messagebox.showwarning("Advertencia", "Seleccione una configuración para cargar")
                return
            
            # Obtener el índice de la configuración seleccionada
            item = tree.item(seleccion[0])
            indice = int(item['tags'][0])
            
            try:
                # Cargar la configuración
                config = historial.cargar_input_config(indice)
                if config is None:
                    messagebox.showerror("Error", "No se pudo cargar la configuración seleccionada")
                    return
                
                # Aplicar la configuración
                self._aplicar_configuracion(config)
                
                messagebox.showinfo("Éxito", f"Configuración '{config['nombre']}' cargada exitosamente")
                dialog.destroy()
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al cargar la configuración: {e}")
        
        def eliminar():
            seleccion = tree.selection()
            if not seleccion:
                messagebox.showwarning("Advertencia", "Seleccione una configuración para eliminar")
                return
            
            # Confirmar eliminación
            if not messagebox.askyesno("Confirmar", "¿Está seguro de que desea eliminar esta configuración?"):
                return
            
            # Obtener el índice de la configuración seleccionada
            item = tree.item(seleccion[0])
            indice = int(item['tags'][0])
            
            try:
                # Eliminar la configuración
                nombre_eliminado = historial.eliminar_input_config(indice)
                if nombre_eliminado:
                    # Actualizar la lista
                    tree.delete(seleccion[0])
                    messagebox.showinfo("Éxito", f"Configuración '{nombre_eliminado}' eliminada exitosamente")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al eliminar la configuración: {e}")
        
        btn_cargar = ctk.CTkButton(btn_frame, text="Cargar", command=cargar, fg_color="green")
        btn_cargar.pack(side="left", padx=5)
        
        btn_eliminar = ctk.CTkButton(btn_frame, text="Eliminar", command=eliminar, fg_color="red")
        btn_eliminar.pack(side="left", padx=5)
        
        btn_cancelar = ctk.CTkButton(btn_frame, text="Cancelar", command=dialog.destroy)
        btn_cancelar.pack(side="left", padx=5)

    def _aplicar_configuracion(self, config):
        """Aplica una configuración cargada a los campos de entrada."""
        try:
            # Limpiar todos los campos actuales
            self._limpiar_campos()
            
            # Aplicar los datos de cada proceso
            for proceso_config in config["procesos"]:
                nombre_proceso = proceso_config["nombre"]
                
                if nombre_proceso in self.process_data:
                    process_info = self.process_data[nombre_proceso]
                    
                    # Aplicar tiempo de llegada
                    if proceso_config["arrival"] is not None:
                        process_info["arrival_entry"].delete(0, "end")
                        process_info["arrival_entry"].insert(0, str(proceso_config["arrival"]))
                    
                    # Aplicar prioridad (si existe en la configuración, sino usar 0)
                    priority = proceso_config.get("priority", 0)
                    process_info["priority_entry"].delete(0, "end")
                    process_info["priority_entry"].insert(0, str(priority))
                    
                    # Aplicar ráfagas
                    bursts = proceso_config["bursts"]
                    if bursts:
                        # Limpiar ráfagas existentes
                        for burst_info in process_info["burst_entries"][:]:
                            self._remove_burst(nombre_proceso, burst_info["frame"])
                        
                        # Añadir ráfagas de la configuración
                        for i, duration in enumerate(bursts):
                            # Determinar tipo de ráfaga (alternando CPU y Bloqueo)
                            burst_type = "CPU" if i % 2 == 0 else "Bloqueo"
                            self._add_burst(nombre_proceso, burst_type)
                            
                            # Establecer el valor
                            if process_info["burst_entries"]:
                                last_burst = process_info["burst_entries"][-1]
                                last_burst["entry"].delete(0, "end")
                                last_burst["entry"].insert(0, str(duration))
                        
        except Exception as e:
            messagebox.showerror("Error", f"Error al aplicar la configuración: {e}")

    def _limpiar_campos(self):
        """Limpia todos los campos de entrada."""
        for nombre_proceso in self.nombres_procesos:
            if nombre_proceso in self.process_data:
                process_info = self.process_data[nombre_proceso]
                
                # Limpiar tiempo de llegada
                process_info["arrival_entry"].delete(0, "end")
                
                # Limpiar prioridad
                process_info["priority_entry"].delete(0, "end")
                
                # Limpiar ráfagas
                for burst_info in process_info["burst_entries"][:]:
                    self._remove_burst(nombre_proceso, burst_info["frame"])


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\name_input_screen.py

...-------------------...
# gui/name_input_screen.py

import customtkinter as ctk
from tkinter import messagebox

class NameInputScreen(ctk.CTkFrame):
    def __init__(self, master, cantidad_procesos, on_continue):
        """
        Pantalla para ingresar los nombres de los procesos.

        :param master: ventana o frame padre
        :param cantidad_procesos: número de procesos a crear
        :param on_continue: función que recibe la lista de nombres y avanza a la siguiente pantalla
        """
        super().__init__(master)
        self.cantidad_procesos = cantidad_procesos
        self.on_continue = on_continue
        self.entries = []

        # Título
        self.label_title = ctk.CTkLabel(self, text="Asignar nombres a los procesos", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=20)

        # Campos dinámicos
        for i in range(cantidad_procesos):
            frame = ctk.CTkFrame(self)
            frame.pack(pady=5, padx=10, fill="x")

            label = ctk.CTkLabel(frame, text=f"Proceso {i+1}:")
            label.pack(side="left", padx=5)

            entry = ctk.CTkEntry(frame, placeholder_text=f"P{i+1}")
            entry.pack(side="left", padx=5, fill="x", expand=True)
            self.entries.append(entry)

        # Botón continuar
        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _continue_clicked(self):
        """Valida y envía la lista de nombres."""
        nombres = []
        for i, entry in enumerate(self.entries):
            nombre = entry.get().strip()
            if not nombre:
                nombre = f"P{i+1}"  # Si está vacío, asigna nombre por defecto
            nombres.append(nombre)

        # Validar que no haya nombres repetidos
        if len(nombres) != len(set(nombres)):
            messagebox.showerror("Error", "Los nombres de los procesos deben ser únicos.")
            return

        self.on_continue(nombres)


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\start_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox

class StartScreen(ctk.CTkFrame):
    def __init__(self, master, on_continue):
        """
        Pantalla inicial para ingresar la cantidad de procesos.

        :param master: ventana o frame padre
        :param on_continue: función que recibe la cantidad de procesos y avanza a la siguiente pantalla
        """
        super().__init__(master)
        self.on_continue = on_continue

        # Título
        self.label_title = ctk.CTkLabel(self, text="Planificación de CPU", font=("Arial", 20, "bold"))
        self.label_title.pack(pady=20)

        # Instrucción
        self.label_instruction = ctk.CTkLabel(self, text="Ingrese la cantidad de procesos:")
        self.label_instruction.pack(pady=10)

        # Campo de entrada
        self.entry_count = ctk.CTkEntry(self, placeholder_text="Ej: 4")
        self.entry_count.pack(pady=10)

        # Botón continuar
        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _continue_clicked(self):
        """Valida la entrada y llama a la función on_continue."""
        try:
            n = int(self.entry_count.get())
            if n <= 0:
                raise ValueError
            self.on_continue(n)
        except ValueError:
            messagebox.showerror("Error", "Ingrese un número válido mayor a 0")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\models\process.py

...-------------------...
# GanddOperativos/models/process.py
class Process:
    def __init__(self, pid, arrival_time, bursts, priority=0):
        """
        Representa un proceso con ráfagas de CPU y bloqueos (E/S).

        :param pid: Identificador del proceso (str o int)
        :param arrival_time: Tiempo de llegada inicial al sistema
        :param bursts: Lista de enteros, índices pares = CPU, impares = bloqueo
                       Ej: [3, 2, 5] => CPU 3, Bloqueo 2, CPU 5
        :param priority: Prioridad del proceso (entero, mayor número = mayor prioridad)
        """
        self.pid = pid
        self.arrival_time = arrival_time
        self.bursts = bursts[:]              # copia viva (puede mutar en algoritmos)
        self.bursts_original = bursts[:]     # copia inmutable para métricas
        self.current_burst_index = 0
        self.remaining_time = bursts[0] if bursts else 0
        self.priority = priority             # Prioridad del proceso (mayor número = mayor prioridad)

        # Métricas
        self.start_time = None
        self.completion_time = None
        self.turnaround_time = None  # TR
        self.waiting_time = None     # TE

        # Estado de planificación
        self.ready_since = None      # cuándo quedó en ready por última vez

    # ---------- Utilidades de estado ----------
    def is_cpu_burst(self):
        """True si la ráfaga actual es de CPU (índice par)."""
        return self.current_burst_index % 2 == 0

    def is_finished(self):
        """True si el proceso ha terminado todas sus ráfagas."""
        return self.current_burst_index >= len(self.bursts)

    def advance_burst(self):
        """Avanza a la siguiente ráfaga."""
        self.current_burst_index += 1
        if self.current_burst_index < len(self.bursts):
            self.remaining_time = self.bursts[self.current_burst_index]
        else:
            self.remaining_time = 0

    def get_remaining_bursts(self):
        """Retorna las ráfagas restantes del proceso (desde el índice actual)."""
        return self.bursts[self.current_burst_index:] if self.current_burst_index < len(self.bursts) else []

    def get_burst_sequence_description(self):
        """Retorna una descripción legible de la secuencia de ráfagas."""
        if not self.bursts:
            return "Sin ráfagas"
        sequence = []
        for i, duration in enumerate(self.bursts):
            burst_type = "CPU" if i % 2 == 0 else "Bloqueo"
            sequence.append(f"{burst_type}({duration})")
        return " → ".join(sequence)

    # ---------- Cálculos de prioridad / apoyo a algoritmos ----------
    def get_total_cpu_remaining(self):
        """
        Retorna el total de CPU restante desde la posición actual.
        Si está en bloqueo (índice impar), comienza desde la próxima CPU.
        Considera la lista 'bursts' viva (por si un algoritmo preemptivo descuenta).
        """
        idx = self.current_burst_index
        if idx >= len(self.bursts):
            return 0
        start = idx if idx % 2 == 0 else idx + 1
        total = 0
        for i in range(start, len(self.bursts), 2):  # sólo índices de CPU
            dur = self.bursts[i]
            if dur < 0:
                dur = 0
            total += dur
        return total

    # ---------- Métricas (siempre contra los datos originales) ----------
    def calculate_metrics(self):
        """
        Calcula TR (turnaround time) y TE (waiting time).
        TR = completion_time - arrival_time
        TE = TR - tiempo total de CPU - tiempo total de bloqueos
        Se usa 'bursts_original' para evitar sesgos si un algoritmo mutó 'bursts'.
        """
        if self.completion_time is None:
            raise ValueError(f"No se puede calcular métricas: {self.pid} no tiene completion_time asignado.")

        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts

        # Tiempo total en el sistema
        self.turnaround_time = self.completion_time - self.arrival_time

        # Suma de todas las ráfagas de CPU (índices pares)
        total_cpu = sum(source[i] for i in range(0, len(source), 2))

        # Suma de todas las ráfagas de bloqueo/E/S (índices impares)
        total_bloq = sum(source[i] for i in range(1, len(source), 2))

        # Tiempo de espera real en cola de listos
        self.waiting_time = self.turnaround_time - total_cpu - total_bloq

    # ---------- Agregados informativos ----------
    def get_total_cpu_time(self):
        """Retorna el tiempo total de CPU del proceso (sobre datos originales si están disponibles)."""
        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts
        return sum(source[i] for i in range(0, len(source), 2))

    def get_total_blocking_time(self):
        """Retorna el tiempo total de bloqueo del proceso (sobre datos originales si están disponibles)."""
        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts
        return sum(source[i] for i in range(1, len(source), 2))

    def get_burst_count(self):
        """Retorna el número total de ráfagas (CPU + bloqueos)."""
        return len(self.bursts)

    def get_cpu_burst_count(self):
        """Retorna el número de ráfagas de CPU."""
        return len([i for i in range(0, len(self.bursts), 2)])

    def get_blocking_burst_count(self):
        """Retorna el número de ráfagas de bloqueo."""
        return len([i for i in range(1, len(self.bursts), 2)])

    def __repr__(self):
        return (f"Process(pid={self.pid}, arrival={self.arrival_time}, bursts={self.bursts}, "
                f"priority={self.priority}, idx={self.current_burst_index}, start={self.start_time}, "
                f"completion={self.completion_time}, TR={self.turnaround_time}, TE={self.waiting_time})")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\models\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\excel_export.py

...-------------------...
import pandas as pd
import openpyxl
from openpyxl import Workbook
from openpyxl.chart import BarChart, Reference
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.drawing.image import Image
import os
import io
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from datetime import datetime

def exportar_a_excel(procesos_data, algoritmo, gantt_data, metricas, trm, tem, quantum=None):
    """
    Exporta los resultados a un archivo Excel con gráfico de Gantt PNG.
    
    Args:
        procesos_data: Lista de procesos originales
        algoritmo: Nombre del algoritmo usado
        gantt_data: Datos del gráfico de Gantt
        metricas: Lista de métricas calculadas
        trm: Tiempo de respuesta medio
        tem: Tiempo de espera medio
        quantum: Quantum usado (opcional)
    """
    
    # Crear workbook
    wb = Workbook()
    
    # Eliminar hoja por defecto
    wb.remove(wb.active)
    
    # Crear hojas
    ws_metricas = wb.create_sheet("Métricas")
    ws_gantt = wb.create_sheet("Gráfico Gantt")
    ws_datos = wb.create_sheet("Datos Originales")
    
    # === HOJA DE MÉTRICAS ===
    _crear_hoja_metricas(ws_metricas, metricas, trm, tem, algoritmo, quantum)
    
    # === HOJA DE GRÁFICO GANTT ===
    _crear_hoja_gantt_con_imagen(ws_gantt, gantt_data, algoritmo)
    
    # === HOJA DE DATOS ORIGINALES ===
    _crear_hoja_datos_originales(ws_datos, procesos_data)
    
    # Generar nombre de archivo
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"resultados_{algoritmo}_{timestamp}.xlsx"
    
    # Guardar archivo
    filepath = os.path.join(os.path.dirname(__file__), filename)
    wb.save(filepath)
    
    return filepath

def _crear_hoja_metricas(ws, metricas, trm, tem, algoritmo, quantum):
    """Crea la hoja de métricas."""
    ws.title = "Métricas"
    
    # Título
    ws['A1'] = f"Resultados - Algoritmo {algoritmo}"
    ws['A1'].font = Font(size=16, bold=True)
    
    if quantum:
        ws['A2'] = f"Quantum: {quantum}"
        ws['A2'].font = Font(size=12, italic=True)
    
    # Métricas generales
    ws['A4'] = "MÉTRICAS GENERALES"
    ws['A4'].font = Font(size=14, bold=True)
    ws['A4'].fill = PatternFill(start_color="E6E6FA", end_color="E6E6FA", fill_type="solid")
    
    ws['A5'] = "TRM (Tiempo de Respuesta Medio):"
    ws['B5'] = trm
    ws['A6'] = "TEM (Tiempo de Espera Medio):"
    ws['B6'] = tem
    
    # Tabla de métricas por proceso
    ws['A8'] = "MÉTRICAS POR PROCESO"
    ws['A8'].font = Font(size=14, bold=True)
    ws['A8'].fill = PatternFill(start_color="E6E6FA", end_color="E6E6FA", fill_type="solid")
    
    # Encabezados
    headers = ["PID", "Tiempo de Llegada", "Tiempo de CPU", "Tiempo de Respuesta", "Tiempo de Espera"]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=9, column=col, value=header)
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
        cell.alignment = Alignment(horizontal="center")
    
    # Datos
    for row, metrica in enumerate(metricas, 10):
        ws.cell(row=row, column=1, value=metrica["PID"])
        ws.cell(row=row, column=2, value=metrica["Llegada"])
        ws.cell(row=row, column=3, value=metrica["CPU"])
        ws.cell(row=row, column=4, value=metrica["TR"])
        ws.cell(row=row, column=5, value=metrica["TE"])
        
        # Formatear números
        for col in [2, 3, 4, 5]:
            ws.cell(row=row, column=col).number_format = "0.00"
    
    # Ajustar ancho de columnas
    for col in ['A', 'B', 'C', 'D', 'E']:
        ws.column_dimensions[col].width = 15

def _crear_hoja_gantt_con_imagen(ws, gantt_data, algoritmo):
    """Crea la hoja con gráfico de Gantt como imagen PNG."""
    ws.title = "Gráfico Gantt"
    
    # Procesar datos de Gantt
    procesos_unicos = []
    gantt_procesado = []
    
    for segmento in gantt_data:
        if len(segmento) == 3:
            pid, start, end = segmento
            tipo = "CPU" if pid != "IDLE" else "IDLE"
        elif len(segmento) == 4:
            pid, start, end, tipo = segmento
        else:
            continue
            
        if pid != "IDLE" and pid not in procesos_unicos:
            procesos_unicos.append(pid)
            
        gantt_procesado.append({
            "PID": pid,
            "Inicio": start,
            "Fin": end,
            "Duración": end - start,
            "Tipo": tipo
        })
    
    # Crear DataFrame
    df_gantt = pd.DataFrame(gantt_procesado)
    
    # Escribir datos
    for r in dataframe_to_rows(df_gantt, index=False, header=True):
        ws.append(r)
    
    # Formatear encabezados
    for cell in ws[1]:
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
        cell.alignment = Alignment(horizontal="center")
    
    # Generar gráfico de Gantt como imagen
    _generar_gantt_png(ws, gantt_procesado, algoritmo)

def _generar_gantt_png(ws, gantt_procesado, algoritmo):
    """Genera un gráfico de Gantt como imagen PNG replicando exactamente la lógica del programa original."""
    if not gantt_procesado:
        return
    
    # Normalizar datos igual que en el programa original
    norm = []
    for segmento in gantt_procesado:
        pid = segmento['PID']
        start = segmento['Inicio']
        end = segmento['Fin']
        tipo = segmento['Tipo']
        
        # Convertir tipo a formato del programa original
        if tipo == "Bloqueo":
            tipo = "BLOCK"
        elif tipo == "CPU":
            tipo = "CPU"
        elif pid == "IDLE":
            tipo = "IDLE"
            
        norm.append((pid, start, end, tipo))
    
    # Obtener procesos únicos (excluir IDLE) - igual que el programa original
    procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
    procesos_unicos = list(dict.fromkeys(procesos_unicos))  # Mantener orden
    
    if not procesos_unicos:
        return
    
    # Calcular dimensiones adaptativas - igual que el programa original
    num_procesos = len(procesos_unicos)
    max_time = max(end for _, _, end, _ in norm) if norm else 1
    
    fig_width = max(15, max_time * 0.25)  # Ancho basado en duración total
    fig_height = max(4, num_procesos * 0.8)  # Altura basada en número de procesos
    
    # Crear figura con las mismas dimensiones
    fig, ax = plt.subplots(figsize=(fig_width, fig_height))
    
    # Posiciones Y para cada proceso - igual que el programa original
    y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}
    
    # Colores - usar la misma paleta que el programa original
    colors = {}
    color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)
    
    # Dibujar barras - replicar exactamente la lógica del programa original
    for pid, start, end, tipo in norm:
        if tipo == "IDLE":
            color = "lightgray"
            hatch = None
            y = -1
            alpha = 0.7
        elif tipo == "BLOCK":
            color = "darkred"
            hatch = "///"
            y = y_positions.get(pid, 0)
            alpha = 0.8
        else:  # CPU
            if pid not in colors:
                colors[pid] = color_palette(len(colors))
            color = colors[pid]
            hatch = None
            y = y_positions.get(pid, 0)
            alpha = 1.0
        
        # Dibujar barra horizontal - mismo estilo que el programa original
        ax.barh(y, end - start, left=start, height=0.6, color=color, 
               edgecolor='black', hatch=hatch, alpha=alpha)
        
        if tipo != "IDLE":
            # Mostrar el PID y el tipo de ráfaga - mismo formato que el programa original
            text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
            ax.text((start + end) / 2, y, text, ha='center', va='center',
                    fontsize=7, color="white" if tipo == "BLOCK" else "black",
                    weight="bold" if tipo == "BLOCK" else "normal")
    
    # Configurar ejes - igual que el programa original
    if procesos_unicos:
        ax.set_yticks(list(y_positions.values()))
        ax.set_yticklabels(list(y_positions.keys()))
    else:
        ax.set_yticks([])
    
    if norm:
        max_time = max(end for _, _, end, _ in norm)
        # Mostrar TODOS los ticks del 0 al tiempo máximo - igual que el programa original
        ax.set_xticks(range(0, max_time + 1))
        ax.set_xlim(0, max_time)
    
    ax.set_xlabel("Tiempo")
    ax.set_ylabel("Procesos")
    ax.set_title(f"Diagrama de Gantt - {algoritmo}")
    ax.grid(True, axis='x', linestyle='--', alpha=0.6)
    
    # Leyenda explicativa - igual que el programa original
    legend_elements = [
        plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
        plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
        plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
    ]
    ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))
    
    # Ajustar layout
    plt.tight_layout()
    
    # Guardar imagen en memoria
    img_buffer = io.BytesIO()
    plt.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
    img_buffer.seek(0)
    
    # Insertar imagen en Excel
    img = Image(img_buffer)
    img.width = 800  # Ancho más grande para mejor visualización
    img.height = 400  # Alto más grande
    
    # Posicionar imagen debajo de los datos
    ws.add_image(img, 'A8')
    
    # Cerrar figura para liberar memoria
    plt.close(fig)

def _crear_hoja_datos_originales(ws, procesos_data):
    """Crea la hoja con los datos originales de entrada."""
    ws.title = "Datos Originales"
    
    # Título
    ws['A1'] = "Datos Originales de los Procesos"
    ws['A1'].font = Font(size=16, bold=True)
    
    # Encabezados
    headers = ["PID", "Tiempo de Llegada", "Secuencia de Ráfagas"]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=3, column=col, value=header)
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
        cell.alignment = Alignment(horizontal="center")
    
    # Datos
    for row, proceso in enumerate(procesos_data, 4):
        ws.cell(row=row, column=1, value=proceso["pid"])
        ws.cell(row=row, column=2, value=proceso["arrival_time"])
        
        # Formatear ráfagas como texto
        bursts_text = " -> ".join([f"{'CPU' if i%2==0 else 'E/S'}: {burst}" 
                                  for i, burst in enumerate(proceso["bursts"])])
        ws.cell(row=row, column=3, value=bursts_text)
    
    # Ajustar ancho de columnas
    ws.column_dimensions['A'].width = 10
    ws.column_dimensions['B'].width = 15
    ws.column_dimensions['C'].width = 50


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\gantt.py

...-------------------...
# utils/gantt.py

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

def plot_gantt(gantt_chart, title="Diagrama de Gantt"):
    """
    Genera un diagrama de Gantt con cada proceso en su propia fila.

    :param gantt_chart: lista de tuplas (pid, start, end)
                        Ej: [("P1", 0, 5), ("P2", 5, 8), ("IDLE", 8, 10)]
    :param title: título del gráfico
    """
    # Obtener lista única de procesos (excluyendo IDLE)
    procesos_unicos = [pid for pid, _, _ in gantt_chart if pid != "IDLE"]
    procesos_unicos = list(dict.fromkeys(procesos_unicos))  # Mantener orden

    # Asignar un índice Y a cada proceso
    y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

    # Colores
    colors = {}
    color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

    fig, ax = plt.subplots(figsize=(10, len(procesos_unicos) * 0.8))

    for i, (pid, start, end) in enumerate(gantt_chart):
        if pid not in colors:
            if pid == "IDLE":
                colors[pid] = "lightgray"
            else:
                colors[pid] = color_palette(len(colors))

        # Si es IDLE, lo ponemos en una fila especial o en la fila del proceso anterior
        y = y_positions.get(pid, -1)  # -1 si es IDLE

        ax.barh(y, end - start, left=start, height=0.5,
                align='center', color=colors[pid], edgecolor='black')

        # Etiqueta centrada
        ax.text((start + end) / 2, y, pid,
                ha='center', va='center', color='black', fontsize=9)

    # Configuración del eje Y
    ax.set_yticks(list(y_positions.values()))
    ax.set_yticklabels(list(y_positions.keys()))

    # Configuración del eje X: mostrar todos los ticks
    max_time = max(end for _, _, end in gantt_chart)
    ax.set_xticks(range(0, max_time + 1))
    ax.set_xlim(0, max_time)

    # Cuadrícula
    ax.grid(True, axis='x', linestyle='--', alpha=0.6)

    # Etiquetas y título
    ax.set_xlabel("Tiempo")
    ax.set_ylabel("Procesos")
    ax.set_title(title)

    # Leyenda
    legend_patches = [mpatches.Patch(color=col, label=pid) for pid, col in colors.items()]
    ax.legend(handles=legend_patches, bbox_to_anchor=(1.05, 1), loc='upper left')

    plt.tight_layout()
    plt.show()


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\historial.py

...-------------------...
import json
import os
from datetime import datetime

HISTORIAL_FILE = os.path.join(os.path.dirname(__file__), "historial.json")

def _leer_historial():
    if os.path.exists(HISTORIAL_FILE):
        with open(HISTORIAL_FILE, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return []
    return []

def _guardar_historial(data):
    with open(HISTORIAL_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def guardar_ejercicio(nombre, procesos, algoritmo, quantum=None):
    """
    Guarda un ejercicio en el historial.
    procesos: lista de dicts con {"pid":..., "arrival_time":..., "bursts": [...]}
    """
    historial = _leer_historial()
    entrada = {
        "nombre": nombre,
        "fecha": datetime.now().isoformat(timespec="seconds"),
        "algoritmo": algoritmo,
        "quantum": quantum,
        "procesos": procesos
    }
    historial.append(entrada)
    _guardar_historial(historial)

def listar_historial():
    """Devuelve una lista de (indice, nombre, fecha, algoritmo) para mostrar en la GUI."""
    historial = _leer_historial()
    return [(i, h["nombre"], h["fecha"], h["algoritmo"]) for i, h in enumerate(historial)]

def cargar_ejercicio(indice):
    """Devuelve el ejercicio guardado en la posición 'indice'."""
    historial = _leer_historial()
    if 0 <= indice < len(historial):
        return historial[indice]
    return None

# ===== FUNCIONES PARA INPUTS DE DATOS =====

INPUT_HISTORIAL_FILE = os.path.join(os.path.dirname(__file__), "input_historial.json")

def _leer_input_historial():
    """Lee el historial de inputs desde el archivo JSON."""
    if os.path.exists(INPUT_HISTORIAL_FILE):
        with open(INPUT_HISTORIAL_FILE, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return []
    return []

def _guardar_input_historial(data):
    """Guarda el historial de inputs en el archivo JSON.""" #a partir de esto se puede cargar luego.
    with open(INPUT_HISTORIAL_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def guardar_input_config(nombre, procesos_config):
    """
    Guarda una configuración de inputs en el historial.
    procesos_config: lista de dicts con {"nombre": str, "arrival": int, "bursts": [int, ...]}
    """
    historial = _leer_input_historial()
    entrada = {
        "nombre": nombre,
        "fecha": datetime.now().isoformat(timespec="seconds"),
        "procesos": procesos_config
    }
    historial.append(entrada)
    _guardar_input_historial(historial)

def listar_input_configs():
    """Devuelve una lista de (indice, nombre, fecha, num_procesos) para mostrar en la GUI."""
    historial = _leer_input_historial()
    return [(i, h["nombre"], h["fecha"], len(h["procesos"])) for i, h in enumerate(historial)]

def cargar_input_config(indice):
    """Devuelve la configuración de inputs guardada en la posición 'indice'."""
    historial = _leer_input_historial()
    if 0 <= indice < len(historial):
        return historial[indice]
    return None

def eliminar_input_config(indice):
    """Elimina una configuración de inputs del historial."""
    historial = _leer_input_historial()
    if 0 <= indice < len(historial):
        nombre_eliminado = historial[indice]["nombre"]
        del historial[indice]
        _guardar_input_historial(historial)
        return nombre_eliminado
    return None

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\input_historial.json

...-------------------...
[
    {
        "nombre": "Punto 1 GUIA 2 JAVI",
        "fecha": "2025-09-13T16:54:00",
        "procesos": [
            {
                "nombre": "P1",
                "arrival": 0,
                "bursts": [
                    2,
                    5,
                    13
                ]
            },
            {
                "nombre": "P2",
                "arrival": 0,
                "bursts": [
                    9,
                    3,
                    5,
                    5,
                    4
                ]
            },
            {
                "nombre": "P3",
                "arrival": 1,
                "bursts": [
                    5
                ]
            },
            {
                "nombre": "P4",
                "arrival": 1,
                "bursts": [
                    4,
                    6,
                    5
                ]
            },
            {
                "nombre": "P5",
                "arrival": 2,
                "bursts": [
                    5,
                    5,
                    5,
                    5,
                    5
                ]
            },
            {
                "nombre": "P6",
                "arrival": 2,
                "bursts": [
                    3
                ]
            },
            {
                "nombre": "P7",
                "arrival": 4,
                "bursts": [
                    5
                ]
            },
            {
                "nombre": "P8",
                "arrival": 6,
                "bursts": [
                    5,
                    2,
                    5
                ]
            },
            {
                "nombre": "P9",
                "arrival": 8,
                "bursts": [
                    5
                ]
            },
            {
                "nombre": "P10",
                "arrival": 8,
                "bursts": [
                    5,
                    4,
                    5
                ]
            }
        ]
    },
    {
        "nombre": "Punto 3 GUIA 2",
        "fecha": "2025-09-15T03:07:25",
        "procesos": [
            {
                "nombre": "P1",
                "arrival": 0,
                "bursts": [
                    5,
                    22,
                    5
                ]
            },
            {
                "nombre": "P2",
                "arrival": 0,
                "bursts": [
                    2,
                    10,
                    9
                ]
            },
            {
                "nombre": "P3",
                "arrival": 0,
                "bursts": [
                    6,
                    101,
                    5,
                    10,
                    1
                ]
            },
            {
                "nombre": "P4",
                "arrival": 0,
                "bursts": [
                    7,
                    61,
                    8
                ]
            },
            {
                "nombre": "P5",
                "arrival": 1,
                "bursts": [
                    13
                ]
            },
            {
                "nombre": "P6",
                "arrival": 2,
                "bursts": [
                    9,
                    252,
                    8
                ]
            }
        ]
    },
    {
        "nombre": "punto1 guianueva",
        "fecha": "2025-09-21T19:52:30",
        "procesos": [
            {
                "nombre": "A",
                "arrival": 0,
                "bursts": [
                    4,
                    2,
                    2,
                    1,
                    1
                ]
            },
            {
                "nombre": "B",
                "arrival": 0,
                "bursts": [
                    2,
                    3,
                    4,
                    2,
                    2
                ]
            },
            {
                "nombre": "C",
                "arrival": 0,
                "bursts": [
                    4,
                    1,
                    3,
                    3,
                    4
                ]
            },
            {
                "nombre": "D",
                "arrival": 2,
                "bursts": [
                    5,
                    2,
                    2,
                    1,
                    1
                ]
            },
            {
                "nombre": "E",
                "arrival": 3,
                "bursts": [
                    4,
                    3,
                    6,
                    2,
                    2
                ]
            },
            {
                "nombre": "F",
                "arrival": 5,
                "bursts": [
                    7,
                    2,
                    4,
                    4,
                    4
                ]
            },
            {
                "nombre": "G",
                "arrival": 7,
                "bursts": [
                    1,
                    2,
                    3,
                    1,
                    2
                ]
            },
            {
                "nombre": "H",
                "arrival": 7,
                "bursts": [
                    3,
                    4,
                    3,
                    4,
                    3
                ]
            },
            {
                "nombre": "I",
                "arrival": 8,
                "bursts": [
                    8,
                    4,
                    1
                ]
            }
        ]
    }
]

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\metricas.py

...-------------------...
def calcular_metricas(procesos):
    lista_metricas = []
    total_tr = 0
    total_te = 0

    for p in procesos:
        # Asegurarnos de que las métricas estén calculadas
        if p.turnaround_time is None or p.waiting_time is None:
            p.calculate_metrics()

        # Usar bursts_original si existe, si no, usar bursts actual
        bursts_fuente = getattr(p, "bursts_original", p.bursts)

        # Suma de todas las ráfagas de CPU (índices pares)
        total_cpu = sum(bursts_fuente[i] for i in range(0, len(bursts_fuente), 2))

        lista_metricas.append({
            "PID": p.pid,
            "Llegada": p.arrival_time,
            "CPU": total_cpu,
            "Finalización": p.completion_time,
            "TR": p.turnaround_time,
            "TE": p.waiting_time
        })

        total_tr += p.turnaround_time
        total_te += p.waiting_time

    trm = total_tr / len(procesos) if procesos else 0
    tem = total_te / len(procesos) if procesos else 0

    return lista_metricas, trm, tem



def imprimir_tabla_metricas(metricas, trm, tem):
    """
    Imprime la tabla de métricas en consola.
    """
    print(f"{'PID':<6}{'Llegada':<10}{'CPU':<8}{'Finalización':<14}{'TR':<8}{'TE':<8}")
    for m in metricas:
        print(f"{m['PID']:<6}{m['Llegada']:<10}{m['CPU']:<8}{m['Finalización']:<14}{m['TR']:<8}{m['TE']:<8}")
    print("\n📈 Promedios:")
    print(f"TRM (Tiempo de Respuesta Medio): {trm:.2f}")
    print(f"TEM (Tiempo de Espera Medio): {tem:.2f}")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\parsers.py

...-------------------...
# utils/parsers.py

def parse_bursts(input_str):
    """
    Convierte una cadena como '3,(2),5' en [3, 2, 5].
    Los números entre paréntesis se interpretan como bloqueos (E/S).
    """
    bursts = []
    # Eliminamos espacios y separamos por comas
    parts = input_str.replace(" ", "").split(",")
    for part in parts:
        if part.startswith("(") and part.endswith(")"):
            # Bloqueo
            val = int(part.strip("()"))
            bursts.append(val)
        else:
            # CPU
            bursts.append(int(part))
    return bursts


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\__init__.py

...-------------------...


...-------------------...
