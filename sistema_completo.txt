
...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\generar_sistema_txt.py

...-------------------...

import os

def generar_documento_txt(ruta_base: str, archivo_salida: str):
    """
    Recorre recursivamente la ruta base y, para cada archivo con extensión .py o .json,
    escribe su contenido en el archivo de salida, separando cada módulo con un separador.

    Args:
        ruta_base (str): Directorio base desde donde comenzar la búsqueda.
        archivo_salida (str): Nombre del archivo TXT a generar.
    """
    separador = "\n...-------------------...\n"
    with open(archivo_salida, "w", encoding="utf-8") as out_file:
        for root, dirs, files in os.walk(ruta_base):
            for archivo in files:
                if archivo.endswith(".py") or archivo.endswith(".json"):
                    ruta_archivo = os.path.join(root, archivo)
                    # Escribe el encabezado del archivo
                    out_file.write(separador)
                    out_file.write(f"Archivo: {ruta_archivo}\n")
                    out_file.write(separador)
                    try:
                        with open(ruta_archivo, "r", encoding="utf-8") as in_file:
                            contenido = in_file.read()
                        out_file.write(contenido)
                    except Exception as e:
                        out_file.write(f"Error al leer el archivo: {e}")
                    out_file.write("\n")
        out_file.write(separador)
    print(f"Documento generado en: {archivo_salida}")

if __name__ == "__main__":
    # Si el script se encuentra al mismo nivel que main.py,
    # establecemos la ruta base como el directorio actual.
    ruta_base = os.path.dirname(os.path.realpath(__file__))
    generar_documento_txt(ruta_base, "sistema_completo.txt")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\main.py

...-------------------...
import customtkinter as ctk
from GUI.start_screen import StartScreen
from GUI.name_input_screen import NameInputScreen
from GUI.data_input_screen import DataInputScreen
from GUI.algorithm_screen import AlgorithmScreen

# --- Funciones de navegación entre pantallas ---

def ir_a_nombres(cantidad):
    limpiar_ventana()
    name_screen = NameInputScreen(root, cantidad, ir_a_tiempos)
    name_screen.pack(fill="both", expand=True)

def ir_a_tiempos(nombres):
    limpiar_ventana()
    data_screen = DataInputScreen(root, nombres, ir_a_algoritmo)
    data_screen.pack(fill="both", expand=True)

def ir_a_algoritmo(procesos_data):
    limpiar_ventana()
    algo_screen = AlgorithmScreen(root, procesos_data, volver_inicio)
    algo_screen.pack(fill="both", expand=True)

def volver_inicio():
    limpiar_ventana()
    start_screen = StartScreen(root, ir_a_nombres)
    start_screen.pack(fill="both", expand=True)

def limpiar_ventana():
    """Elimina todos los widgets de la ventana principal."""
    for widget in root.winfo_children():
        widget.destroy()

# --- Configuración inicial de la app ---
if __name__ == "__main__":
    ctk.set_appearance_mode("dark")  # Modo oscuro
    ctk.set_default_color_theme("blue")  # Tema azul

    root = ctk.CTk()
    root.title("Simulador de Planificación de CPU")
    root.geometry("800x600")

    # Pantalla inicial
    start_screen = StartScreen(root, ir_a_nombres)
    start_screen.pack(fill="both", expand=True)

    root.mainloop()


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\fifo.py

...-------------------...
from copy import deepcopy

def fifo(process_list):
    """
    FIFO no expulsivo sin bloqueos.
    Usa Process con bursts=[CPU] y remaining_time inicializado.
    Devuelve gantt en 3-tuplas: (pid, start, end).
    """
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    time = 0  # Reloj del sistema
    gantt = []  # Lista para almacenar el diagrama de Gantt
    ready = []  # Cola de procesos listos para ejecutar
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos

    # Ordenar por llegada para consistencia (no obligatorio)
    processes.sort(key=lambda p: p.arrival_time)

    while completed < n:  # Mientras no se completen todos los procesos
        # Encolar llegadas al tiempo actual
        for p in processes:
            # Verificar si el proceso:
            # - No ha empezado a ejecutarse (start_time is None)
            # - Ya llegó al sistema (arrival_time <= time)
            # - No está ya en la cola de listos
            # - No ha terminado (completion_time is None)
            if p.start_time is None and p.arrival_time <= time and p not in ready and p.completion_time is None:
                ready.append(p)  # Agregar a la cola de listos

        if ready:  # Si hay procesos listos para ejecutar
            current = ready.pop(0)  # Tomar el primero de la cola (FIFO)
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # Marcar tiempo de inicio

            start = time  # Guardar tiempo de inicio de esta ejecución
            cpu = current.remaining_time  # Tiempo de CPU restante (equivale a bursts[0])
            time += cpu  # Avanzar el reloj del sistema
            gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

            current.completion_time = time  # Marcar tiempo de finalización
            current.calculate_metrics()  # Calcular métricas del proceso
            completed += 1  # Incrementar contador de completados
        else:
            # No hay procesos listos: avanzar 1 unidad de tiempo y reintentar
            time += 1

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\fifo_blocking.py

...-------------------...
# NO TOCAR MAS YA FUNCIONA BIEN 
from copy import deepcopy

def fifo_blocking(process_list):
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    time = 0  # Reloj del sistema
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt
    ready_queue = []  # Cola de procesos listos para ejecutar
    blocked_queue = []  # Cola de procesos bloqueados: (proceso, unblock_time)
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos

    current = None  # Proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    # Buffers de encolado para respetar la prioridad:
    # primero entran los que terminan CPU (CPU_FINISH), luego los que salen de BLOQ (UNBLOCK)
    enq_cpu = []      # procesos que entran a ready por llegada o por terminar CPU
    enq_unblock = []  # procesos que entran a ready por desbloqueo

    while completed < n:  # Mientras no se completen todos los procesos
        # 1) Llegadas - Procesar procesos que llegan en este momento
        for p in processes:
            # Verificar si el proceso:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No ha terminado (completion_time is None)
            # - No está ya en la cola de listos
            # - No está bloqueado
            # - No es el proceso actual en ejecución
            # - No está ya en los buffers de encolado
            if (
                p.arrival_time == time
                and p.completion_time is None
                and p not in ready_queue
                and all(bp is not p for bp, _ in blocked_queue)
                and p is not current
                and p not in enq_cpu  # evitar duplicado si llega y ya está en buffer
                and p not in enq_unblock
            ):
                if p.is_cpu_burst():  # Si la primera ráfaga es de CPU
                    enq_cpu.append(p)  # PRIORIDAD: llegan a ready como CPU_FINISH
                else:  # Si la primera ráfaga es de bloqueo
                    dur = p.bursts[p.current_burst_index]  # Duración del bloqueo
                    if dur > 0:  # Si el bloqueo tiene duración
                        gantt_chart.append((p.pid, time, time + dur, "BLOCK"))  # Registrar bloqueo
                        blocked_queue.append((p, time + dur))  # Agregar a cola de bloqueados
                    else:  # Si el bloqueo es de duración 0
                        p.advance_burst()  # Avanzar a la siguiente ráfaga
                        if p.current_burst_index >= len(p.bursts):  # Si terminó el proceso
                            p.completion_time = time
                            completed += 1
                        elif p.is_cpu_burst():  # Si la siguiente es CPU
                            enq_cpu.append(p)  # entra por CPU
                        else:  # Si la siguiente es otro bloqueo
                            dur2 = p.bursts[p.current_burst_index]
                            if dur2 > 0:  # Si tiene duración
                                gantt_chart.append((p.pid, time, time + dur2, "BLOCK"))
                                blocked_queue.append((p, time + dur2))
                            else:  # Si es de duración 0
                                p.advance_burst()
                                if p.current_burst_index < len(p.bursts) and p.is_cpu_burst():
                                    enq_cpu.append(p)

        # 2) Desbloqueos que vencen ahora - Procesar procesos que terminan su bloqueo
        for (bp, unblock_time) in blocked_queue[:]:  # Iterar sobre una copia de la lista
            if unblock_time == time:  # Si el bloqueo termina en este momento
                blocked_queue.remove((bp, unblock_time))  # Remover de la cola de bloqueados
                bp.advance_burst()  # Avanzar a la siguiente ráfaga
                if bp.current_burst_index >= len(bp.bursts):  # Si terminó el proceso
                    bp.completion_time = time
                    completed += 1
                else:
                    if bp.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        enq_unblock.append(bp)  # SALIDA DE BLOQ va detrás de CPU_FINISH
                    else:  # Si la siguiente ráfaga es de bloqueo
                        dur2 = bp.bursts[bp.current_burst_index]
                        if dur2 > 0:  # Si tiene duración
                            gantt_chart.append((bp.pid, time, time + dur2, "BLOCK"))
                            blocked_queue.append((bp, time + dur2))
                        else:  # Si es de duración 0
                            bp.advance_burst()
                            if bp.current_burst_index >= len(bp.bursts):  # Si terminó
                                bp.completion_time = time
                                completed += 1
                            elif bp.is_cpu_burst():  # Si la siguiente es CPU
                                enq_unblock.append(bp)

        # Mezclar en ready con la prioridad requerida: primero enq_cpu, luego enq_unblock
        if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
            ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero
            ready_queue.extend(enq_unblock)  # Luego los de desbloqueo
            enq_cpu.clear()  # Limpiar buffer de CPU
            enq_unblock.clear()  # Limpiar buffer de desbloqueo

        # 3) Selección FIFO - Elegir proceso para ejecutar
        if current is None and ready_queue:  # Si no hay proceso ejecutando y hay listos
            current = ready_queue.pop(0)  # Tomar el primero de la cola (FIFO)
            start_time = time  # Marcar inicio del bloque
            if current.start_time is None:  # Si es la primera vez que se ejecuta
                current.start_time = time  # solo la primera vez que toca CPU

        # 4) Ejecutar 1 tick de CPU o avanzar tiempo si no hay listos
        if current:  # Si hay un proceso ejecutando
            current.remaining_time -= 1  # Reducir tiempo restante
            time += 1  # Avanzar el reloj del sistema

            # ¿Terminó esta ráfaga de CPU?
            if current.remaining_time == 0:  # Si terminó la ráfaga de CPU
                # Cerrar tramo de CPU
                gantt_chart.append((current.pid, start_time, time, "CPU"))

                # Avanzar a la siguiente ráfaga
                current.advance_burst()

                # ¿Proceso terminado?
                if current.current_burst_index >= len(current.bursts):  # Si terminó el proceso
                    current.completion_time = time
                    completed += 1
                    current = None  # Liberar CPU
                else:
                    # ¿Siguiente es CPU?
                    if current.is_cpu_burst():  # Si la siguiente ráfaga es de CPU
                        # Entra a ready como "CPU_FINISH" (prioridad sobre UNBLOCK si coincide el instante)
                        enq_cpu.append(current)
                        current = None  # Liberar CPU
                    else:  # Si la siguiente ráfaga es de bloqueo
                        # Siguiente es BLOQUEO
                        dur = current.bursts[current.current_burst_index]
                        if dur > 0:  # Si tiene duración
                            gantt_chart.append((current.pid, time, time + dur, "BLOCK"))
                            blocked_queue.append((current, time + dur))
                            current = None  # Liberar CPU
                        else:  # Si es de duración 0
                            # Bloqueo de 0 → saltar
                            current.advance_burst()
                            if current.current_burst_index >= len(current.bursts):  # Si terminó
                                current.completion_time = time
                                completed += 1
                                current = None
                            elif current.is_cpu_burst():  # Si la siguiente es CPU
                                enq_cpu.append(current)
                                current = None

            # Tras terminar el tick, antes de próxima selección, volcamos buffers con prioridad
            if enq_cpu or enq_unblock:  # Si hay procesos en los buffers
                ready_queue.extend(enq_cpu)  # Agregar procesos de CPU primero
                ready_queue.extend(enq_unblock)  # Luego los de desbloqueo
                enq_cpu.clear()  # Limpiar buffer de CPU
                enq_unblock.clear()  # Limpiar buffer de desbloqueo
        else:  # No hay proceso ejecutando
            # No hay proceso ejecutando ni listo: avanzar tiempo "vacío" (no pintamos IDLE)
            time += 1

    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\roundrobin.py

...-------------------...
from copy import deepcopy
from collections import deque

def round_robin(process_list, quantum):
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    n = len(processes)  # Total de procesos
    time = 0  # Reloj del sistema
    completed = 0  # Contador de procesos completados
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt

    ready_queue = deque()  # Cola de procesos listos (FIFO con deque)
    # Ordenar por tiempo de llegada, luego por PID para consistencia
    procesos_pendientes = sorted(processes, key=lambda p: (p.arrival_time, p.pid))

    current_pid = None  # PID del proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    while completed < n:  # Mientras no se completen todos los procesos
        # Agregar procesos que llegan en este instante
        # Ordenar por PID para mantener consistencia
        procesos_que_llegan = []
        for p in procesos_pendientes:
            # Verificar si el proceso:
            # - Llega exactamente en este momento (arrival_time == time)
            # - No está ya en la cola de listos
            # - Aún tiene tiempo restante para ejecutar
            if p.arrival_time == time and p not in ready_queue and p.remaining_time > 0:
                procesos_que_llegan.append(p)
        
        # Ordenar por PID y agregar al final de la cola
        procesos_que_llegan.sort(key=lambda p: p.pid)
        for p in procesos_que_llegan:
            ready_queue.append(p)  # Agregar al final de la cola

        if ready_queue:  # Si hay procesos listos para ejecutar
            current = ready_queue.popleft()  # Tomar el primero de la cola

            # Cambio de proceso en ejecución
            if current_pid != current.pid:  # Si cambió el proceso
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = current.pid  # Actualizar PID actual
                start_time = time  # Marcar inicio del nuevo bloque
                if current.start_time is None:  # Si es la primera vez que se ejecuta
                    current.start_time = time  # Marcar tiempo de inicio del proceso

            # Ejecutar hasta quantum o hasta que termine
            exec_time = min(quantum, current.remaining_time)  # Tiempo a ejecutar
            current.remaining_time -= exec_time  # Reducir tiempo restante
            time += exec_time  # Avanzar el reloj del sistema

            # Agregar procesos que llegaron durante la ejecución
            procesos_nuevos = []
            for p in procesos_pendientes:
                # Verificar si llegó durante la ejecución del proceso actual
                if time - exec_time < p.arrival_time <= time and p.remaining_time > 0 and p not in ready_queue:
                    procesos_nuevos.append(p)
            
            # Ordenar por PID y agregar al final
            procesos_nuevos.sort(key=lambda p: p.pid)
            for p in procesos_nuevos:
                ready_queue.append(p)  # Agregar al final de la cola

            if current.remaining_time > 0:  # Si el proceso no terminó
                # Agregar el proceso actual al final si no terminó (Round Robin)
                ready_queue.append(current)
            else:  # Si el proceso terminó
                current.completion_time = time  # Marcar tiempo de finalización
                current.calculate_metrics()  # Calcular métricas del proceso
                completed += 1  # Incrementar contador de completados
        else:  # No hay procesos listos
            # CPU ociosa
            if current_pid != "IDLE":  # Si no está marcado como IDLE
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = "IDLE"  # Marcar como IDLE
                start_time = time  # Marcar inicio del período IDLE
            time += 1  # Avanzar tiempo sin ejecutar nada

    # Cerrar el último bloque
    if current_pid is not None:
        gantt_chart.append((current_pid, start_time, time))

    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\round_robin_blocking.py

...-------------------...
from copy import deepcopy
from collections import deque

def round_robin_blocking(process_list, quantum):
    """Round Robin con bloqueos, ejecución por tramos (no tick a tick)."""

    def collapse_zeros(proc, t):
        """Salta ráfagas 0 encadenadas; si termina, marca completion_time."""
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t
            return True
        return False

    def handle_post(proc, t, enq_cpu, enq_unblock, blocked, gantt):
        """
        Decide qué hacer tras cambiar de ráfaga:
        - Si terminó → True
        - Si CPU → enq_cpu
        - Si BLOQ>0 → programa (BLOCK + blocked)
        - Si BLOQ=0 → encadena recursivamente
        """
        if collapse_zeros(proc, t):
            return True
        if proc.is_cpu_burst():
            enq_cpu.append(proc)
        else:
            dur = proc.bursts[proc.current_burst_index]
            if dur > 0:
                gantt.append((proc.pid, t, t + dur, "BLOCK"))
                blocked.append((proc, t + dur))
            else:
                proc.advance_burst()
                return handle_post(proc, t, enq_cpu, enq_unblock, blocked, gantt)
        return False

    processes = deepcopy(process_list)

    # Init: conservar remaining_time como duración de la ráfaga CPU actual (lo setea Process)
    for idx, p in enumerate(processes):
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        p._seq = idx
        p.ready_since = None
        p.start_time = None
        p.completion_time = None
        if not p.bursts:
            p.current_burst_index = 0
            p.remaining_time = 0
            p.completion_time = 0

    time = 0
    gantt = []
    ready = deque()
    blocked = []                # [(proc, unblock_time)]
    completed = sum(1 for p in processes if p.completion_time is not None)
    n = len(processes)
    arrived = set()

    # Buffers con prioridad: CPU_FINISH/llegada > UNBLOCK
    enq_cpu = []
    enq_unblock = []

    def enqueue_arrivals_leq_t(t):
        """Encola llegadas hasta t (incluido)."""
        nonlocal completed
        for p in processes:
            if p.pid in arrived:
                continue
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)
                if handle_post(p, t, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

    # Llegadas iniciales
    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu); ready.extend(enq_unblock)
        enq_cpu.clear(); enq_unblock.clear()

    while completed < n:
        # Si no hay listos, saltar al siguiente evento
        if not ready:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                # Salvaguarda: marcar terminados sin completion_time
                for p in processes:
                    if p.completion_time is None and p.current_burst_index >= len(p.bursts):
                        p.completion_time = time
                        completed += 1
                break
            next_event = min(future_arrivals + future_unblocks)
            if next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            # Procesar todos los eventos en 'time'
            # Desbloqueos exactamente en 'time'
            for (bp, unb) in blocked[:]:
                if unb == time:
                    blocked.remove((bp, unb))
                    bp.advance_burst()
                    if handle_post(bp, time, enq_cpu, enq_unblock, blocked, gantt):
                        completed += 1
            # Llegadas en 'time'
            enqueue_arrivals_leq_t(time)
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu); ready.extend(enq_unblock)
                enq_cpu.clear(); enq_unblock.clear()
            if not ready:
                continue

        # Selección RR
        current = ready.popleft()
        # Sólo CPU en ready; blindaje por si acaso
        if not current.is_cpu_burst():
            if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                completed += 1
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu); ready.extend(enq_unblock)
                enq_cpu.clear(); enq_unblock.clear()
            continue

        if current.start_time is None:
            current.start_time = time
        # Sync si hiciera falta
        if current.remaining_time <= 0:
            current.remaining_time = current.bursts[current.current_burst_index]

        # Tramo a ejecutar
        exec_time = min(quantum, current.remaining_time)
        start = time
        end = time + exec_time

        # Registrar ejecuciones de otros eventos que ocurren en (time, end]
        # - Desbloqueos
        for (bp, unb) in sorted(blocked[:], key=lambda x: x[1]):
            if time < unb <= end:
                blocked.remove((bp, unb))
                # Avanza ráfaga al instante unb
                bp.advance_burst()
                # Resolver en unb (no preempra al actual, solo prepara ready)
                if handle_post(bp, unb, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
        # - Llegadas
        for p in processes:
            if p.pid in arrived:
                continue
            if time < p.arrival_time <= end and p.completion_time is None:
                arrived.add(p.pid)
                if handle_post(p, p.arrival_time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

        # Consumir CPU del actual y avanzar tiempo
        current.remaining_time -= exec_time
        time = end
        gantt.append((current.pid, start, end, "CPU"))

        # ¿Terminó ráfaga o agotó quantum?
        if current.remaining_time == 0:
            current.advance_burst()
            # Si terminó el proceso
            if current.current_burst_index >= len(current.bursts):
                current.completion_time = time
                completed += 1
            else:
                # Resolver lo que sigue en el mismo tick
                if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
        else:
            # Ráfaga no terminó → reencolar al final
            current.ready_since = time
            enq_cpu.append(current)

        # Volcar buffers con prioridad
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu); ready.extend(enq_unblock)
            enq_cpu.clear(); enq_unblock.clear()

    # Salvaguarda final
    for p in processes:
        if p.completion_time is None and p.current_burst_index >= len(p.bursts):
            p.completion_time = time

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\sjf.py

...-------------------...
from copy import deepcopy

def sjf(process_list):
    """
    SJF no expulsivo sin bloqueos.
    Usa Process con bursts=[CPU] y remaining_time inicializado.
    Devuelve gantt en 3-tuplas: (pid, start, end).
    """
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    time = 0  # Reloj del sistema
    gantt = []  # Lista para almacenar el diagrama de Gantt
    completed = 0  # Contador de procesos completados
    n = len(processes)  # Total de procesos

    # Para evitar reuso accidental
    for p in processes:
        # remaining_time ya viene de Process(bursts=[cpu])
        pass

    while completed < n:  # Mientras no se completen todos los procesos
        # Elegibles: llegaron y no completados
        elegibles = [p for p in processes if p.arrival_time <= time and p.completion_time is None]

        if not elegibles:  # Si no hay procesos elegibles
            time += 1  # Avanzar tiempo y continuar
            continue

        # Elegir el de menor remaining_time (única ráfaga de CPU)
        # SJF: Shortest Job First - el trabajo más corto primero
        current = min(elegibles, key=lambda p: p.remaining_time)

        if current.start_time is None:  # Si es la primera vez que se ejecuta
            current.start_time = time  # Marcar tiempo de inicio

        start = time  # Guardar tiempo de inicio de esta ejecución
        cpu = current.remaining_time  # Tiempo de CPU restante
        time += cpu  # Avanzar el reloj del sistema
        gantt.append((current.pid, start, time))  # Registrar en el diagrama de Gantt

        current.completion_time = time  # Marcar tiempo de finalización
        current.calculate_metrics()  # Calcular métricas del proceso
        completed += 1  # Incrementar contador de completados

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\sjf_blocking.py

...-------------------...
﻿# algoritmo/sjf_blocking.py
from copy import deepcopy

def sjf_blocking(process_list):
    processes = deepcopy(process_list)

    # --- Helper: total de CPU restante desde la posición actual ---
    def cpu_total_restante(p):
        idx = p.current_burst_index
        if idx >= len(p.bursts):
            return 0
        # si está parado en bloqueo (índice impar), la próxima CPU es idx+1
        start = idx if idx % 2 == 0 else idx + 1
        total = 0
        for i in range(start, len(p.bursts), 2):  # sólo posiciones de CPU
            # si es la CPU actual y ya se consumió parcialmente, el burst refleja lo que queda
            total += p.bursts[i]
        return total

    # Init por proceso
    for idx, p in enumerate(processes):
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        p._seq = idx
        # 'remaining_time' queda como métrica informativa; NO se usa para priorizar
        p.remaining_time = sum(b for i, b in enumerate(p.bursts) if i % 2 == 0)
        p.ready_since = None
        p.start_time = None
        p.completion_time = None

    time = 0
    gantt = []
    ready = []
    blocked = []      # [(proc, unblock_time)]
    completed = 0
    n = len(processes)
    arrived = set()   # PIDs ya encolados por llegada

    # Buffers de encolado con prioridad
    enq_cpu = []      # procesos que entran por llegada o fin de CPU
    enq_unblock = []  # procesos que entran por fin de bloqueo

    def collapse_zeros(proc, t):
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t
            return True
        return False

    def enqueue_arrivals_leq_t(t):
        nonlocal completed
        for p in processes:
            if p.pid in arrived:
                continue
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)
                if collapse_zeros(p, t):
                    completed += 1
                    continue
                if p.is_cpu_burst():
                    p.ready_since = p.arrival_time
                    enq_cpu.append(p)  # llegada → prioridad CPU_FINISH
                else:
                    dur = p.bursts[p.current_burst_index]
                    if dur > 0:
                        gantt.append((p.pid, t, t + dur, "BLOCK"))
                        blocked.append((p, t + dur))
                    else:
                        p.advance_burst()
                        if collapse_zeros(p, t):
                            completed += 1
                        elif p.is_cpu_burst():
                            p.ready_since = p.arrival_time
                            enq_cpu.append(p)

    # Inicializar con todos los procesos que llegan en tiempo 0 o antes
    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)
        ready.extend(enq_unblock)
        enq_cpu.clear()
        enq_unblock.clear()

    while completed < n:
        # 1) Procesar TODOS los desbloqueos que vencieron hasta t
        if blocked:
            blocked.sort(key=lambda x: x[1])
        for (bp, unb) in blocked[:]:
            if unb <= time:
                blocked.remove((bp, unb))
                bp.advance_burst()
                if collapse_zeros(bp, time):
                    completed += 1
                    continue
                if bp.is_cpu_burst():
                    bp.ready_since = time
                    enq_unblock.append(bp)  # fin de BLOQ → va detrás de CPU_FINISH
                else:
                    dur = bp.bursts[bp.current_burst_index]
                    if dur > 0:
                        gantt.append((bp.pid, time, time + dur, "BLOCK"))
                        blocked.append((bp, time + dur))
                    else:
                        bp.advance_burst()
                        if collapse_zeros(bp, time):
                            completed += 1
                        elif bp.is_cpu_burst():
                            bp.ready_since = time
                            enq_unblock.append(bp)

        # 2) Encolar llegadas que hayan llegado hasta este momento
        enqueue_arrivals_leq_t(time)

        # 2.1) Volcar buffers a ready con prioridad CPU_FINISH > UNBLOCK
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

        # 3) Si no hay listos, saltar al siguiente evento
        if not ready:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                break
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else None
            if next_event is None:
                time += 1
            elif next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            continue

        # 4) Selección SJF **por total de CPU restante**
        ready = [p for p in ready if p.current_burst_index < len(p.bursts)]
        ready.sort(key=lambda x: (
            cpu_total_restante(x),                 # menor CPU total restante
            (x.ready_since if x.ready_since is not None else x.arrival_time),
            x.pid
        ))

        current = ready.pop(0)
        if current.start_time is None:
            current.start_time = time

        # 5) Ejecutar ráfaga completa
        start = time
        cpu_dur = current.bursts[current.current_burst_index]
        if cpu_dur <= 0:
            if collapse_zeros(current, time):
                completed += 1
            else:
                if current.is_cpu_burst():
                    current.ready_since = time
                    enq_cpu.append(current)
            continue

        time += cpu_dur
        # 'remaining_time' se ajusta solo como dato; no afecta prioridad
        if hasattr(current, "remaining_time") and current.remaining_time is not None:
            current.remaining_time -= cpu_dur
            if current.remaining_time < 0:
                current.remaining_time = 0
        gantt.append((current.pid, start, time, "CPU"))

        # 6) Avanzar bursts y re-encolar según corresponda
        current.advance_burst()
        if collapse_zeros(current, time):
            completed += 1
            continue

        if current.is_cpu_burst():
            current.ready_since = time
            enq_cpu.append(current)
        else:
            dur = current.bursts[current.current_burst_index]
            if dur > 0:
                gantt.append((current.pid, time, time + dur, "BLOCK"))
                blocked.append((current, time + dur))
            else:
                current.advance_burst()
                if collapse_zeros(current, time):
                    completed += 1
                elif current.is_cpu_burst():
                    current.ready_since = time
                    enq_cpu.append(current)

        # 6.1) Volcar buffers a ready con prioridad
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\srtf.py

...-------------------...
from copy import deepcopy

def srtf(process_list):
    """
    Simula la planificación SRTF (Shortest Remaining Time First, expulsivo).

    :param process_list: lista de objetos Process
    :return: (gantt_chart, procesos_con_metricas)
    """
    # Crear copia profunda para no modificar la lista original
    processes = deepcopy(process_list)
    n = len(processes)  # Total de procesos
    completed = 0  # Contador de procesos completados
    time = 0  # Reloj del sistema
    gantt_chart = []  # Lista para almacenar el diagrama de Gantt

    # Para controlar cambios de proceso
    current_pid = None  # PID del proceso actualmente en ejecución
    start_time = None  # Tiempo de inicio del bloque actual en Gantt

    while completed < n:  # Mientras no se completen todos los procesos
        # Filtrar procesos listos y no completados
        ready_queue = [p for p in processes if p.arrival_time <= time and p.remaining_time > 0]

        if ready_queue:  # Si hay procesos listos para ejecutar
            # Elegir el de menor tiempo restante, con desempate por FIFO
            ready_queue.sort(key=lambda x: (
                x.remaining_time,  # SRTF: menor tiempo restante (prioridad principal)
                x.arrival_time,    # FIFO en empates (desempate por llegada)
                x.pid             # estabilidad (desempate por PID)
            ))
            current = ready_queue[0]  # Tomar el proceso con menor tiempo restante

            # Si cambia el proceso en ejecución, cerramos el bloque anterior
            if current_pid != current.pid:  # Si cambió el proceso
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = current.pid  # Actualizar PID actual
                start_time = time  # Marcar inicio del nuevo bloque
                if current.start_time is None:  # Si es la primera vez que se ejecuta
                    current.start_time = time  # Marcar tiempo de inicio del proceso

            # Ejecutar 1 unidad de tiempo (SRTF es expulsivo)
            current.remaining_time -= 1  # Reducir tiempo restante
            time += 1  # Avanzar el reloj del sistema

            # Si termina
            if current.remaining_time == 0:  # Si el proceso terminó
                current.completion_time = time  # Marcar tiempo de finalización
                current.calculate_metrics()  # Calcular métricas del proceso
                completed += 1  # Incrementar contador de completados
        else:  # No hay procesos listos
            # CPU ociosa
            if current_pid != "IDLE":  # Si no está marcado como IDLE
                if current_pid is not None:  # Si había un proceso anterior
                    gantt_chart.append((current_pid, start_time, time))  # Cerrar bloque anterior
                current_pid = "IDLE"  # Marcar como IDLE
                start_time = time  # Marcar inicio del período IDLE
            time += 1  # Avanzar tiempo sin ejecutar nada

    # Cerrar el último bloque
    if current_pid is not None:
        gantt_chart.append((current_pid, start_time, time))

    return gantt_chart, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\srtf_blocking.py

...-------------------...
from copy import deepcopy

def srtf_blocking(process_list):
    """SRTF expulsivo con soporte para bloqueos, usando get_total_cpu_remaining()."""

    def collapse_zeros(proc, t):
        while proc.current_burst_index < len(proc.bursts) and proc.bursts[proc.current_burst_index] == 0:
            proc.advance_burst()
        if proc.current_burst_index >= len(proc.bursts):
            proc.completion_time = t
            return True
        return False

    def handle_post(proc, t, destino_cpu, destino_unblock, destino_blocked, gantt):
        if collapse_zeros(proc, t):
            return True
        if proc.is_cpu_burst():
            destino_cpu.append(proc)
        else:
            dur = proc.bursts[proc.current_burst_index]
            if dur > 0:
                gantt.append((proc.pid, t, t + dur, "BLOCK"))
                destino_blocked.append((proc, t + dur))
            else:
                proc.advance_burst()
                return handle_post(proc, t, destino_cpu, destino_unblock, destino_blocked, gantt)
        return False

    processes = deepcopy(process_list)
    for idx, p in enumerate(processes):
        if not hasattr(p, "bursts_original"):
            p.bursts_original = p.bursts[:]
        p._seq = idx
        p.ready_since = None
        p.start_time = None
        p.completion_time = None

    time = 0
    gantt = []
    ready = []
    blocked = []
    completed = 0
    n = len(processes)
    arrived = set()

    enq_cpu = []
    enq_unblock = []

    def enqueue_arrivals_leq_t(t):
        nonlocal completed
        for p in processes:
            if p.pid in arrived:
                continue
            if p.arrival_time <= t and p.completion_time is None:
                arrived.add(p.pid)
                if handle_post(p, t, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1

    def process_unblocks_leq_t(t):
        nonlocal completed
        for (bp, unb) in blocked[:]:
            if unb <= t:
                blocked.remove((bp, unb))
                bp.advance_burst()
                if handle_post(bp, t, enq_unblock, enq_unblock, blocked, gantt):
                    completed += 1

    enqueue_arrivals_leq_t(time)
    if enq_cpu or enq_unblock:
        ready.extend(enq_cpu)
        ready.extend(enq_unblock)
        enq_cpu.clear()
        enq_unblock.clear()

    current = None
    seg_start = None

    while completed < n:
        process_unblocks_leq_t(time)
        enqueue_arrivals_leq_t(time)

        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

        eligibles = [p for p in ready if p.is_cpu_burst() and not p.is_finished()]
        if not eligibles:
            future_arrivals = [p.arrival_time for p in processes if p.pid not in arrived and p.completion_time is None]
            future_unblocks = [unb for _, unb in blocked]
            if not future_arrivals and not future_unblocks:
                break
            next_event = min(future_arrivals + future_unblocks) if (future_arrivals or future_unblocks) else None
            if next_event is None:
                time += 1
            elif next_event > time:
                gantt.append(("IDLE", time, next_event, "IDLE"))
                time = next_event
            else:
                time += 1
            current = None
            seg_start = None
            continue

        eligibles.sort(key=lambda x: (x.get_total_cpu_remaining(), x.ready_since or x.arrival_time, x.pid))
        candidate = eligibles[0]

        if current is not candidate:
            if current is not None and seg_start is not None and time > seg_start:
                gantt.append((current.pid, seg_start, time, "CPU"))
            current = candidate
            seg_start = time
            if current.start_time is None:
                current.start_time = time

        # Ejecutar 1 tick
        current.bursts[current.current_burst_index] -= 1
        current.remaining_time = current.get_total_cpu_remaining()
        time += 1

        # Fin de ráfaga
        if current.bursts[current.current_burst_index] == 0:
            gantt.append((current.pid, seg_start, time, "CPU"))
            current.advance_burst()
            if current.is_finished():
                current.completion_time = time
                completed += 1
                current = None
                seg_start = None
            else:
                if handle_post(current, time, enq_cpu, enq_unblock, blocked, gantt):
                    completed += 1
                current = None
                seg_start = None
            if enq_cpu or enq_unblock:
                ready.extend(enq_cpu)
                ready.extend(enq_unblock)
                enq_cpu.clear()
                enq_unblock.clear()
            continue

        # Preempción
        process_unblocks_leq_t(time)
        enqueue_arrivals_leq_t(time)
        if enq_cpu or enq_unblock:
            ready.extend(enq_cpu)
            ready.extend(enq_unblock)
            enq_cpu.clear()
            enq_unblock.clear()

        eligibles = [p for p in ready if p.is_cpu_burst() and not p.is_finished()]
        if eligibles:
            eligibles.sort(key=lambda x: (x.get_total_cpu_remaining(), x.ready_since or x.arrival_time, x.pid))
            best = eligibles[0]
            if best is not current and best.get_total_cpu_remaining() < current.get_total_cpu_remaining():
                gantt.append((current.pid, seg_start, time, "CPU"))
                current.ready_since = time
                enq_cpu.append(current)
                current = None
                seg_start = None
                ready.extend(enq_cpu)
                ready.extend(enq_unblock)
                enq_cpu.clear()
                enq_unblock.clear()

    if current is not None and seg_start is not None and time > seg_start:
        gantt.append((current.pid, seg_start, time, "CPU"))

    return gantt, processes


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\algoritmos\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\algorithm_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox, ttk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt

from models.process import Process
# Algoritmos sin bloqueos
from algoritmos.fifo import fifo
from algoritmos.sjf import sjf
from algoritmos.srtf import srtf
from algoritmos.roundrobin import round_robin
# Algoritmos con bloqueos
from algoritmos.fifo_blocking import fifo_blocking
from algoritmos.sjf_blocking import sjf_blocking
from algoritmos.srtf_blocking import srtf_blocking
from algoritmos.round_robin_blocking import round_robin_blocking

from utils.metricas import calcular_metricas


class AlgorithmScreen(ctk.CTkFrame):
    def __init__(self, master, procesos_data, volver_inicio):
        super().__init__(master)
        self.procesos_data = procesos_data
        self.volver_inicio = volver_inicio
        
        # Variables para almacenar el gráfico actual
        self.current_gantt = None
        self.current_algorithm = None
        self.current_fig = None

        # --- Selección de algoritmo ---
        self.label_title = ctk.CTkLabel(self, text="Seleccionar algoritmo", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=10)

        self.algoritmos = ["FIFO", "SJF", "SRTF", "Round Robin"]
        self.selected_algo = ctk.StringVar(value=self.algoritmos[0])
        self.option_menu = ctk.CTkOptionMenu(
            self, values=self.algoritmos, variable=self.selected_algo, command=self._on_algo_change
        )
        self.option_menu.pack(pady=5)

        # --- Botones de control ---
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)
        self.btn_run = ctk.CTkButton(btn_frame, text="Ejecutar", command=self._run_algorithm)
        self.btn_run.pack(side="left", padx=5)
        self.btn_export = ctk.CTkButton(btn_frame, text="Exportar PNG", command=self._export_png, 
                                      fg_color="green", hover_color="#006600")
        self.btn_export.pack(side="left", padx=5)
        self.btn_new = ctk.CTkButton(btn_frame, text="Nuevo ejercicio", command=self.volver_inicio)
        self.btn_new.pack(side="left", padx=5)
        self.btn_exit = ctk.CTkButton(
            btn_frame, text="Salir", fg_color="red", hover_color="#aa0000", command=self._salir
        )
        self.btn_exit.pack(side="left", padx=5)

        # --- Campo quantum (solo si RR) ---
        self.frame_quantum = ctk.CTkFrame(self)
        self.label_quantum = ctk.CTkLabel(self.frame_quantum, text="Quantum:")
        self.label_quantum.pack(side="left", padx=5)
        self.entry_quantum = ctk.CTkEntry(self.frame_quantum, placeholder_text="Ej: 2", width=60)
        self.entry_quantum.pack(side="left", padx=5)

        # --- Tabla BCP ---
        self.tree = ttk.Treeview(self, columns=("PID", "Llegada", "CPU", "TR", "TE"), show="headings", height=8)
        for col in ("PID", "Llegada", "CPU", "TR", "TE"):
            self.tree.heading(col, text=col)
            self.tree.column(col, width=80, anchor="center")
        self.tree.pack(pady=10, fill="x")

        # --- Label promedios ---
        self.label_promedios = ctk.CTkLabel(self, text="TRM: -    |    TEM: -", font=("Arial", 14))
        self.label_promedios.pack(pady=5)

        # --- Frame gráfico ---
        self.frame_gantt = ctk.CTkFrame(self)
        self.frame_gantt.pack(pady=10, fill="both", expand=True)

    def _on_algo_change(self, value):
        if value == "Round Robin":
            self.frame_quantum.pack(before=self.tree, pady=5)
        else:
            self.frame_quantum.pack_forget()

    def _run_algorithm(self):
        # Crear copias de los procesos para no modificar los originales
        from copy import deepcopy
        procesos = [Process(p["pid"], p["arrival_time"], p["bursts"]) for p in self.procesos_data]
        algo = self.selected_algo.get()

        try:
            if algo == "FIFO":
                gantt, result = fifo_blocking(procesos)
            elif algo == "SJF":
                gantt, result = sjf_blocking(procesos)
            elif algo == "SRTF":
                gantt, result = srtf_blocking(procesos)
            elif algo == "Round Robin":
                quantum = self._get_quantum()
                if quantum is None:
                    return
                # Detectar si los procesos tienen bloqueos
                tiene_bloqueos = any(len(p["bursts"]) > 1 for p in self.procesos_data)
                if tiene_bloqueos:
                    gantt, result = round_robin_blocking(procesos, quantum)
                else:
                    gantt, result = round_robin(procesos, quantum)
        except Exception as e:
            messagebox.showerror("Error", f"Ocurrió un error al ejecutar: {e}")
            return

        # Calcular métricas
        metricas, trm, tem = calcular_metricas(result)

        # Actualizar tabla
        for row in self.tree.get_children():
            self.tree.delete(row)
        for m in metricas:
            self.tree.insert("", "end", values=(m["PID"], m["Llegada"], m["CPU"], m["TR"], m["TE"]))

        # Actualizar promedios
        self.label_promedios.configure(
            text=f"TRM (Tiempo de Respuesta Medio): {trm:.2f}    |    TEM (Tiempo de Espera Medio): {tem:.2f}"
        )

        # Almacenar datos del gráfico para exportación
        self.current_gantt = gantt
        self.current_algorithm = algo
        
        # Mostrar gráfico
        self._mostrar_gantt_embebido(gantt, algo)

    def _get_quantum(self):
        try:
            quantum = int(self.entry_quantum.get())
            if quantum <= 0:
                raise ValueError
            return quantum
        except ValueError:
            messagebox.showerror("Error", "Ingrese un quantum válido (> 0)")
            return None

    def _mostrar_gantt_embebido(self, gantt_chart, algo):
        for widget in self.frame_gantt.winfo_children():
            widget.destroy()

        norm = []
        for seg in gantt_chart:
            if len(seg) == 3:
                pid, start, end = seg
                tipo = "CPU" if pid != "IDLE" else "IDLE"
                norm.append((pid, start, end, tipo))
            elif len(seg) == 4:
                norm.append(seg)

        # Ajustar el tamaño del gráfico según el número de procesos y duración total
        num_procesos = len(set(pid for pid, _, _, tipo in norm if pid != "IDLE"))
        max_time = max(end for _, _, end, _ in norm) if norm else 1
        
        # Calcular dimensiones adaptativas - más ancho para mostrar todos los ticks
        fig_width = max(15, max_time * 0.25)  # Ancho basado en duración total, más generoso
        fig_height = max(4, num_procesos * 0.8)  # Altura basada en número de procesos
        
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))
        
        procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
        procesos_unicos = list(dict.fromkeys(procesos_unicos))
        y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

        colors = {}
        color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

        for pid, start, end, tipo in norm:
            if tipo == "IDLE":
                color = "lightgray"
                hatch = None
                y = -1
                alpha = 0.7
            elif tipo == "BLOCK":
                color = "darkred"
                hatch = "///"
                y = y_positions.get(pid, 0)
                alpha = 0.8
            else:  # CPU
                if pid not in colors:
                    colors[pid] = color_palette(len(colors))
                color = colors[pid]
                hatch = None
                y = y_positions.get(pid, 0)
                alpha = 1.0

            ax.barh(y, end - start, left=start, height=0.6, color=color, 
                   edgecolor='black', hatch=hatch, alpha=alpha)
            
            if tipo != "IDLE":
                # Mostrar el PID y el tipo de ráfaga
                text = f"{pid}\n({tipo})" if tipo == "BLOCK" else str(pid)
                ax.text((start + end) / 2, y, text, ha='center', va='center',
                        fontsize=7, color="white" if tipo == "BLOCK" else "black",
                        weight="bold" if tipo == "BLOCK" else "normal")

        if procesos_unicos:
            ax.set_yticks(list(y_positions.values()))
            ax.set_yticklabels(list(y_positions.keys()))
        else:
            ax.set_yticks([])

        if norm:
            max_time = max(end for _, _, end, _ in norm)
            
            # Mostrar TODOS los ticks del 0 al tiempo máximo
            ax.set_xticks(range(0, max_time + 1))
            ax.set_xlim(0, max_time)
        ax.set_xlabel("Tiempo")
        ax.set_ylabel("Procesos")
        ax.set_title(f"Diagrama de Gantt - {algo}")
        ax.grid(True, axis='x', linestyle='--', alpha=0.6)
        
        # Agregar leyenda explicativa
        legend_elements = [
            plt.Rectangle((0,0),1,1, facecolor='lightblue', edgecolor='black', label='CPU'),
            plt.Rectangle((0,0),1,1, facecolor='darkred', edgecolor='black', hatch='///', label='Bloqueo (E/S)'),
            plt.Rectangle((0,0),1,1, facecolor='lightgray', edgecolor='black', alpha=0.7, label='IDLE')
        ]
        ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1.02, 1))

        # Ajustar el layout para mejor uso del espacio
        plt.tight_layout()
        
        canvas = FigureCanvasTkAgg(fig, master=self.frame_gantt)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Almacenar la figura para exportación
        self.current_fig = fig
        
        # Configurar scroll horizontal si es necesario
        if fig_width > 15:
            # Para gráficos muy anchos, permitir scroll horizontal
            canvas.get_tk_widget().configure(scrollregion=canvas.get_tk_widget().bbox("all"))

    def _export_png(self):
        """Exporta el gráfico actual como PNG."""
        if self.current_fig is None:
            messagebox.showwarning("Advertencia", "No hay gráfico para exportar. Ejecute un algoritmo primero.")
            return
        
        try:
            from tkinter import filedialog
            import os
            from datetime import datetime
            
            # Generar nombre de archivo con timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"gantt_{self.current_algorithm}_{timestamp}.png"
            
            # Abrir diálogo para seleccionar ubicación
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("All files", "*.*")],
                initialfile=default_filename,
                title="Guardar gráfico como PNG"
            )
            
            if file_path:
                # Exportar con alta resolución
                self.current_fig.savefig(file_path, dpi=300, bbox_inches='tight', 
                                       facecolor='white', edgecolor='none')
                messagebox.showinfo("Éxito", f"Gráfico exportado exitosamente:\n{file_path}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar el gráfico:\n{str(e)}")

    def _salir(self):
        self.master.destroy()

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\algorithm_screen_backup.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox, ttk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt

from models.process import Process
# Algoritmos sin bloqueos
from algoritmos.fifo import fifo
from algoritmos.sjf import sjf
from algoritmos.srtf import srtf
from algoritmos.roundrobin import round_robin
# Algoritmos con bloqueos
from algoritmos.fifo_blocking import fifo_blocking
from algoritmos.sjf_blocking import sjf_blocking
from algoritmos.srtf_blocking import srtf_blocking
from algoritmos.round_robin_blocking import round_robin_blocking

from utils.metricas import calcular_metricas


class AlgorithmScreen(ctk.CTkFrame):
    def __init__(self, master, procesos_data, volver_inicio):
        super().__init__(master)
        self.procesos_data = procesos_data
        self.volver_inicio = volver_inicio

        # --- Selección de algoritmo ---
        self.label_title = ctk.CTkLabel(self, text="Seleccionar algoritmo", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=10)

        self.algoritmos = ["FIFO", "SJF", "SRTF", "Round Robin"]
        self.selected_algo = ctk.StringVar(value=self.algoritmos[0])
        self.option_menu = ctk.CTkOptionMenu(
            self, values=self.algoritmos, variable=self.selected_algo, command=self._on_algo_change
        )
        self.option_menu.pack(pady=5)

        # --- Botones de control ---
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)
        self.btn_run = ctk.CTkButton(btn_frame, text="Ejecutar", command=self._run_algorithm)
        self.btn_run.pack(side="left", padx=5)
        self.btn_new = ctk.CTkButton(btn_frame, text="Nuevo ejercicio", command=self.volver_inicio)
        self.btn_new.pack(side="left", padx=5)
        self.btn_exit = ctk.CTkButton(
            btn_frame, text="Salir", fg_color="red", hover_color="#aa0000", command=self._salir
        )
        self.btn_exit.pack(side="left", padx=5)

        # --- Campo quantum (solo si RR) ---
        self.frame_quantum = ctk.CTkFrame(self)
        self.label_quantum = ctk.CTkLabel(self.frame_quantum, text="Quantum:")
        self.label_quantum.pack(side="left", padx=5)
        self.entry_quantum = ctk.CTkEntry(self.frame_quantum, placeholder_text="Ej: 2", width=60)
        self.entry_quantum.pack(side="left", padx=5)

        # --- Tabla BCP ---
        self.tree = ttk.Treeview(self, columns=("PID", "Llegada", "CPU", "TR", "TE"), show="headings", height=8)
        for col in ("PID", "Llegada", "CPU", "TR", "TE"):
            self.tree.heading(col, text=col)
            self.tree.column(col, width=80, anchor="center")
        self.tree.pack(pady=10, fill="x")

        # --- Label promedios ---
        self.label_promedios = ctk.CTkLabel(self, text="TRM: -    |    TEM: -", font=("Arial", 14))
        self.label_promedios.pack(pady=5)

        # --- Frame gráfico ---
        self.frame_gantt = ctk.CTkFrame(self)
        self.frame_gantt.pack(pady=10, fill="both", expand=True)

    def _on_algo_change(self, value):
        if value == "Round Robin":
            self.frame_quantum.pack(before=self.tree, pady=5)
        else:
            self.frame_quantum.pack_forget()

    def _run_algorithm(self):
        procesos = [Process(p["pid"], p["arrival_time"], p["bursts"]) for p in self.procesos_data]
        algo = self.selected_algo.get()

        try:
            if algo == "FIFO":
                gantt, result = fifo_blocking(procesos)
            elif algo == "SJF":
                gantt, result = sjf_blocking(procesos)
            elif algo == "SRTF":
                gantt, result = srtf_blocking(procesos)
            elif algo == "Round Robin":
                quantum = self._get_quantum()
                if quantum is None:
                    return
                gantt, result = round_robin_blocking(procesos, quantum)
        except Exception as e:
            messagebox.showerror("Error", f"Ocurrió un error al ejecutar: {e}")
            return

        # Calcular métricas
        metricas, trm, tem = calcular_metricas(result)

        # Actualizar tabla
        for row in self.tree.get_children():
            self.tree.delete(row)
        for m in metricas:
            self.tree.insert("", "end", values=(m["PID"], m["Llegada"], m["CPU"], m["TR"], m["TE"]))

        # Actualizar promedios
        self.label_promedios.configure(
            text=f"TRM (Tiempo de Respuesta Medio): {trm:.2f}    |    TEM (Tiempo de Espera Medio): {tem:.2f}"
        )

        # Mostrar gráfico
        self._mostrar_gantt_embebido(gantt, algo)

    def _get_quantum(self):
        try:
            quantum = int(self.entry_quantum.get())
            if quantum <= 0:
                raise ValueError
            return quantum
        except ValueError:
            messagebox.showerror("Error", "Ingrese un quantum válido (> 0)")
            return None

    def _mostrar_gantt_embebido(self, gantt_chart, algo):
        for widget in self.frame_gantt.winfo_children():
            widget.destroy()

        norm = []
        for seg in gantt_chart:
            if len(seg) == 3:
                pid, start, end = seg
                tipo = "CPU" if pid != "IDLE" else "IDLE"
                norm.append((pid, start, end, tipo))
            elif len(seg) == 4:
                norm.append(seg)

        fig, ax = plt.subplots(figsize=(8, 3))
        procesos_unicos = [pid for pid, _, _, tipo in norm if pid != "IDLE"]
        procesos_unicos = list(dict.fromkeys(procesos_unicos))
        y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

        colors = {}
        color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

        for pid, start, end, tipo in norm:
            if tipo == "IDLE":
                color = "lightgray"
                hatch = None
                y = -1
            elif tipo == "BLOCK":
                color = "black"
                hatch = "//"
                y = y_positions.get(pid, 0)
            else:
                if pid not in colors:
                    colors[pid] = color_palette(len(colors))
                color = colors[pid]
                hatch = None
                y = y_positions.get(pid, 0)

            ax.barh(y, end - start, left=start, height=0.5, color=color, edgecolor='black', hatch=hatch)
            if tipo != "IDLE":
                ax.text((start + end) / 2, y, str(pid), ha='center', va='center',
                        fontsize=8, color="white" if tipo == "BLOCK" else "black")

        if procesos_unicos:
            ax.set_yticks(list(y_positions.values()))
            ax.set_yticklabels(list(y_positions.keys()))
        else:
            ax.set_yticks([])

        if norm:
            max_time = max(end for _, _, end, _ in norm)
            ax.set_xticks(range(0, max_time + 1))
            ax.set_xlim(0, max_time)
        ax.set_xlabel("Tiempo")
        ax.set_ylabel("Procesos")
        ax.set_title(f"Diagrama de Gantt - {algo}")
        ax.grid(True, axis='x', linestyle='--', alpha=0.6)

        canvas = FigureCanvasTkAgg(fig, master=self.frame_gantt)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)

    def _salir(self):
        self.master.destroy()

...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\data_input_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox

class DataInputScreen(ctk.CTkFrame):
    def __init__(self, master, nombres_procesos, on_continue):
        super().__init__(master)
        self.nombres_procesos = nombres_procesos
        self.on_continue = on_continue

        # Estructura de datos para múltiples ráfagas
        self.process_data = {}  # {nombre: {"arrival": int, "bursts": [int, int, ...]}}
        
        self.label_title = ctk.CTkLabel(self, text="Ingresar datos de procesos", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=20)

        # Frame con scroll para muchos procesos
        self.scroll_frame = ctk.CTkScrollableFrame(self, height=400)
        self.scroll_frame.pack(padx=10, pady=10, fill="both", expand=True)

        self._build_rows()

        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _build_rows(self):
        for nombre in self.nombres_procesos:
            # Inicializar datos del proceso
            self.process_data[nombre] = {
                "arrival": None,
                "bursts": []
            }
            
            # Frame principal del proceso
            process_frame = ctk.CTkFrame(self.scroll_frame)
            process_frame.pack(pady=10, fill="x", padx=5)
            
            # Título del proceso
            title_frame = ctk.CTkFrame(process_frame)
            title_frame.pack(fill="x", padx=5, pady=5)
            
            ctk.CTkLabel(title_frame, text=f"Proceso: {nombre}", font=("Arial", 14, "bold")).pack(side="left")
            
            # Tiempo de llegada
            arrival_frame = ctk.CTkFrame(process_frame)
            arrival_frame.pack(fill="x", padx=5, pady=2)
            
            ctk.CTkLabel(arrival_frame, text="Tiempo de llegada:", width=120).pack(side="left", padx=5)
            arrival_entry = ctk.CTkEntry(arrival_frame, placeholder_text="Ej: 0", width=80)
            arrival_entry.pack(side="left", padx=5)
            
            # Frame para las ráfagas
            bursts_frame = ctk.CTkFrame(process_frame)
            bursts_frame.pack(fill="x", padx=5, pady=5)
            
            ctk.CTkLabel(bursts_frame, text="Secuencia de ráfagas:", font=("Arial", 12, "bold")).pack(anchor="w", padx=5, pady=2)
            
            # Frame para los controles de ráfagas
            controls_frame = ctk.CTkFrame(bursts_frame)
            controls_frame.pack(fill="x", padx=5, pady=2)
            
            # Botón para agregar ráfaga
            add_btn = ctk.CTkButton(controls_frame, text="+ Agregar ráfaga", width=120, 
                                   command=lambda n=nombre: self._add_burst(n))
            add_btn.pack(side="left", padx=5)
            
            # Frame para mostrar las ráfagas
            bursts_display_frame = ctk.CTkFrame(bursts_frame)
            bursts_display_frame.pack(fill="x", padx=5, pady=5)
            
            # Almacenar referencias para este proceso
            self.process_data[nombre]["arrival_entry"] = arrival_entry
            self.process_data[nombre]["bursts_display_frame"] = bursts_display_frame
            self.process_data[nombre]["burst_entries"] = []
            
            # Agregar primera ráfaga de CPU por defecto
            self._add_burst(nombre, burst_type="CPU")

    def _add_burst(self, process_name, burst_type=None):
        """Agrega una nueva ráfaga al proceso especificado."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        display_frame = process_info["bursts_display_frame"]
        
        # Determinar el tipo de ráfaga si no se especifica
        if burst_type is None:
            # Si no hay ráfagas, empezar con CPU
            if not burst_entries:
                burst_type = "CPU"
            else:
                # Alternar entre CPU y Bloqueo
                last_type = burst_entries[-1]["type"]
                burst_type = "Bloqueo" if last_type == "CPU" else "CPU"
        
        # Frame para esta ráfaga
        burst_frame = ctk.CTkFrame(display_frame)
        burst_frame.pack(fill="x", padx=2, pady=2)
        
        # Tipo de ráfaga
        type_label = ctk.CTkLabel(burst_frame, text=f"{burst_type}:", width=80)
        type_label.pack(side="left", padx=5)
        
        # Campo de entrada
        burst_entry = ctk.CTkEntry(burst_frame, placeholder_text=f"Duración {burst_type}", width=100)
        burst_entry.pack(side="left", padx=5)
        
        # Botón para eliminar
        remove_btn = ctk.CTkButton(burst_frame, text="✕", width=30, height=25,
                                  command=lambda: self._remove_burst(process_name, burst_frame))
        remove_btn.pack(side="left", padx=5)
        
        # Almacenar información de la ráfaga
        burst_info = {
            "frame": burst_frame,
            "entry": burst_entry,
            "type": burst_type
        }
        burst_entries.append(burst_info)
        
        # Actualizar la secuencia visual
        self._update_sequence_display(process_name)
    
    def _remove_burst(self, process_name, burst_frame):
        """Elimina una ráfaga del proceso especificado."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        
        # Encontrar y eliminar la ráfaga
        for i, burst_info in enumerate(burst_entries):
            if burst_info["frame"] == burst_frame:
                burst_entries.pop(i)
                burst_frame.destroy()
                break
        
        # Actualizar la secuencia visual
        self._update_sequence_display(process_name)
    
    def _update_sequence_display(self, process_name):
        """Actualiza la visualización de la secuencia de ráfagas."""
        process_info = self.process_data[process_name]
        burst_entries = process_info["burst_entries"]
        
        # Crear texto descriptivo de la secuencia
        if burst_entries:
            sequence_parts = []
            for i, burst_info in enumerate(burst_entries):
                sequence_parts.append(f"{burst_info['type']}{i+1}")
            sequence_text = " → ".join(sequence_parts)
        else:
            sequence_text = "Sin ráfagas"
        
        # Actualizar o crear label de secuencia
        if "sequence_label" not in process_info:
            sequence_label = ctk.CTkLabel(process_info["bursts_display_frame"], 
                                        text=f"Secuencia: {sequence_text}", 
                                        font=("Arial", 10, "italic"))
            sequence_label.pack(anchor="w", padx=5, pady=2)
            process_info["sequence_label"] = sequence_label
        else:
            process_info["sequence_label"].configure(text=f"Secuencia: {sequence_text}")

    def _continue_clicked(self):
        procesos_data = []
        try:
            for nombre in self.nombres_procesos:
                process_info = self.process_data[nombre]
                
                # Validar tiempo de llegada
                arrival_str = process_info["arrival_entry"].get().strip()
                if not arrival_str:
                    raise ValueError(f"Proceso {nombre}: Tiempo de llegada requerido")
                
                arrival_time = int(arrival_str)
                if arrival_time < 0:
                    raise ValueError(f"Proceso {nombre}: Tiempo de llegada debe ser ≥ 0")
                
                # Validar ráfagas
                burst_entries = process_info["burst_entries"]
                if not burst_entries:
                    raise ValueError(f"Proceso {nombre}: Debe tener al menos una ráfaga")
                
                bursts = []
                for burst_info in burst_entries:
                    duration_str = burst_info["entry"].get().strip()
                    if not duration_str:
                        raise ValueError(f"Proceso {nombre}: Todas las duraciones son requeridas")
                    
                    duration = int(duration_str)
                    if duration < 0:
                        raise ValueError(f"Proceso {nombre}: Las duraciones deben ser ≥ 0")
                    
                    bursts.append(duration)
                
                # Validar que termine con CPU (índice par)
                if len(bursts) % 2 == 0:
                    # Termina con CPU, está bien
                    pass
                else:
                    # Termina con bloqueo, agregar CPU de 0
                    bursts.append(0)
                
                # Validar que tenga al menos una ráfaga de CPU
                cpu_bursts = [bursts[i] for i in range(0, len(bursts), 2)]
                if not any(cpu > 0 for cpu in cpu_bursts):
                    raise ValueError(f"Proceso {nombre}: Debe tener al menos una ráfaga de CPU > 0")
                
                procesos_data.append({
                    "pid": nombre, 
                    "arrival_time": arrival_time, 
                    "bursts": bursts
                })

        except ValueError as e:
            messagebox.showerror("Error de validación", str(e))
            return
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado: {e}")
            return

        self.on_continue(procesos_data)


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\name_input_screen.py

...-------------------...
# gui/name_input_screen.py

import customtkinter as ctk
from tkinter import messagebox

class NameInputScreen(ctk.CTkFrame):
    def __init__(self, master, cantidad_procesos, on_continue):
        """
        Pantalla para ingresar los nombres de los procesos.

        :param master: ventana o frame padre
        :param cantidad_procesos: número de procesos a crear
        :param on_continue: función que recibe la lista de nombres y avanza a la siguiente pantalla
        """
        super().__init__(master)
        self.cantidad_procesos = cantidad_procesos
        self.on_continue = on_continue
        self.entries = []

        # Título
        self.label_title = ctk.CTkLabel(self, text="Asignar nombres a los procesos", font=("Arial", 18, "bold"))
        self.label_title.pack(pady=20)

        # Campos dinámicos
        for i in range(cantidad_procesos):
            frame = ctk.CTkFrame(self)
            frame.pack(pady=5, padx=10, fill="x")

            label = ctk.CTkLabel(frame, text=f"Proceso {i+1}:")
            label.pack(side="left", padx=5)

            entry = ctk.CTkEntry(frame, placeholder_text=f"P{i+1}")
            entry.pack(side="left", padx=5, fill="x", expand=True)
            self.entries.append(entry)

        # Botón continuar
        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _continue_clicked(self):
        """Valida y envía la lista de nombres."""
        nombres = []
        for i, entry in enumerate(self.entries):
            nombre = entry.get().strip()
            if not nombre:
                nombre = f"P{i+1}"  # Si está vacío, asigna nombre por defecto
            nombres.append(nombre)

        # Validar que no haya nombres repetidos
        if len(nombres) != len(set(nombres)):
            messagebox.showerror("Error", "Los nombres de los procesos deben ser únicos.")
            return

        self.on_continue(nombres)


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\start_screen.py

...-------------------...
import customtkinter as ctk
from tkinter import messagebox

class StartScreen(ctk.CTkFrame):
    def __init__(self, master, on_continue):
        """
        Pantalla inicial para ingresar la cantidad de procesos.

        :param master: ventana o frame padre
        :param on_continue: función que recibe la cantidad de procesos y avanza a la siguiente pantalla
        """
        super().__init__(master)
        self.on_continue = on_continue

        # Título
        self.label_title = ctk.CTkLabel(self, text="Planificación de CPU", font=("Arial", 20, "bold"))
        self.label_title.pack(pady=20)

        # Instrucción
        self.label_instruction = ctk.CTkLabel(self, text="Ingrese la cantidad de procesos:")
        self.label_instruction.pack(pady=10)

        # Campo de entrada
        self.entry_count = ctk.CTkEntry(self, placeholder_text="Ej: 4")
        self.entry_count.pack(pady=10)

        # Botón continuar
        self.btn_continue = ctk.CTkButton(self, text="Continuar", command=self._continue_clicked)
        self.btn_continue.pack(pady=20)

    def _continue_clicked(self):
        """Valida la entrada y llama a la función on_continue."""
        try:
            n = int(self.entry_count.get())
            if n <= 0:
                raise ValueError
            self.on_continue(n)
        except ValueError:
            messagebox.showerror("Error", "Ingrese un número válido mayor a 0")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\GUI\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\models\process.py

...-------------------...
# GanddOperativos/models/process.py
class Process:
    def __init__(self, pid, arrival_time, bursts):
        """
        Representa un proceso con ráfagas de CPU y bloqueos (E/S).

        :param pid: Identificador del proceso (str o int)
        :param arrival_time: Tiempo de llegada inicial al sistema
        :param bursts: Lista de enteros, índices pares = CPU, impares = bloqueo
                       Ej: [3, 2, 5] => CPU 3, Bloqueo 2, CPU 5
        """
        self.pid = pid
        self.arrival_time = arrival_time
        self.bursts = bursts[:]              # copia viva (puede mutar en algoritmos)
        self.bursts_original = bursts[:]     # copia inmutable para métricas
        self.current_burst_index = 0
        self.remaining_time = bursts[0] if bursts else 0

        # Métricas
        self.start_time = None
        self.completion_time = None
        self.turnaround_time = None  # TR
        self.waiting_time = None     # TE

        # Estado de planificación
        self.ready_since = None      # cuándo quedó en ready por última vez

    # ---------- Utilidades de estado ----------
    def is_cpu_burst(self):
        """True si la ráfaga actual es de CPU (índice par)."""
        return self.current_burst_index % 2 == 0

    def is_finished(self):
        """True si el proceso ha terminado todas sus ráfagas."""
        return self.current_burst_index >= len(self.bursts)

    def advance_burst(self):
        """Avanza a la siguiente ráfaga."""
        self.current_burst_index += 1
        if self.current_burst_index < len(self.bursts):
            self.remaining_time = self.bursts[self.current_burst_index]
        else:
            self.remaining_time = 0

    def get_remaining_bursts(self):
        """Retorna las ráfagas restantes del proceso (desde el índice actual)."""
        return self.bursts[self.current_burst_index:] if self.current_burst_index < len(self.bursts) else []

    def get_burst_sequence_description(self):
        """Retorna una descripción legible de la secuencia de ráfagas."""
        if not self.bursts:
            return "Sin ráfagas"
        sequence = []
        for i, duration in enumerate(self.bursts):
            burst_type = "CPU" if i % 2 == 0 else "Bloqueo"
            sequence.append(f"{burst_type}({duration})")
        return " → ".join(sequence)

    # ---------- Cálculos de prioridad / apoyo a algoritmos ----------
    def get_total_cpu_remaining(self):
        """
        Retorna el total de CPU restante desde la posición actual.
        Si está en bloqueo (índice impar), comienza desde la próxima CPU.
        Considera la lista 'bursts' viva (por si un algoritmo preemptivo descuenta).
        """
        idx = self.current_burst_index
        if idx >= len(self.bursts):
            return 0
        start = idx if idx % 2 == 0 else idx + 1
        total = 0
        for i in range(start, len(self.bursts), 2):  # sólo índices de CPU
            dur = self.bursts[i]
            if dur < 0:
                dur = 0
            total += dur
        return total

    # ---------- Métricas (siempre contra los datos originales) ----------
    def calculate_metrics(self):
        """
        Calcula TR (turnaround time) y TE (waiting time).
        TR = completion_time - arrival_time
        TE = TR - tiempo total de CPU - tiempo total de bloqueos
        Se usa 'bursts_original' para evitar sesgos si un algoritmo mutó 'bursts'.
        """
        if self.completion_time is None:
            raise ValueError(f"No se puede calcular métricas: {self.pid} no tiene completion_time asignado.")

        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts

        # Tiempo total en el sistema
        self.turnaround_time = self.completion_time - self.arrival_time

        # Suma de todas las ráfagas de CPU (índices pares)
        total_cpu = sum(source[i] for i in range(0, len(source), 2))

        # Suma de todas las ráfagas de bloqueo/E/S (índices impares)
        total_bloq = sum(source[i] for i in range(1, len(source), 2))

        # Tiempo de espera real en cola de listos
        self.waiting_time = self.turnaround_time - total_cpu - total_bloq

    # ---------- Agregados informativos ----------
    def get_total_cpu_time(self):
        """Retorna el tiempo total de CPU del proceso (sobre datos originales si están disponibles)."""
        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts
        return sum(source[i] for i in range(0, len(source), 2))

    def get_total_blocking_time(self):
        """Retorna el tiempo total de bloqueo del proceso (sobre datos originales si están disponibles)."""
        source = self.bursts_original if hasattr(self, "bursts_original") and self.bursts_original else self.bursts
        return sum(source[i] for i in range(1, len(source), 2))

    def get_burst_count(self):
        """Retorna el número total de ráfagas (CPU + bloqueos)."""
        return len(self.bursts)

    def get_cpu_burst_count(self):
        """Retorna el número de ráfagas de CPU."""
        return len([i for i in range(0, len(self.bursts), 2)])

    def get_blocking_burst_count(self):
        """Retorna el número de ráfagas de bloqueo."""
        return len([i for i in range(1, len(self.bursts), 2)])

    def __repr__(self):
        return (f"Process(pid={self.pid}, arrival={self.arrival_time}, bursts={self.bursts}, "
                f"idx={self.current_burst_index}, start={self.start_time}, completion={self.completion_time}, "
                f"TR={self.turnaround_time}, TE={self.waiting_time})")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\models\__init__.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\gantt.py

...-------------------...
# utils/gantt.py

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

def plot_gantt(gantt_chart, title="Diagrama de Gantt"):
    """
    Genera un diagrama de Gantt con cada proceso en su propia fila.

    :param gantt_chart: lista de tuplas (pid, start, end)
                        Ej: [("P1", 0, 5), ("P2", 5, 8), ("IDLE", 8, 10)]
    :param title: título del gráfico
    """
    # Obtener lista única de procesos (excluyendo IDLE)
    procesos_unicos = [pid for pid, _, _ in gantt_chart if pid != "IDLE"]
    procesos_unicos = list(dict.fromkeys(procesos_unicos))  # Mantener orden

    # Asignar un índice Y a cada proceso
    y_positions = {pid: i for i, pid in enumerate(procesos_unicos)}

    # Colores
    colors = {}
    color_palette = plt.cm.get_cmap("tab20", len(procesos_unicos) + 1)

    fig, ax = plt.subplots(figsize=(10, len(procesos_unicos) * 0.8))

    for i, (pid, start, end) in enumerate(gantt_chart):
        if pid not in colors:
            if pid == "IDLE":
                colors[pid] = "lightgray"
            else:
                colors[pid] = color_palette(len(colors))

        # Si es IDLE, lo ponemos en una fila especial o en la fila del proceso anterior
        y = y_positions.get(pid, -1)  # -1 si es IDLE

        ax.barh(y, end - start, left=start, height=0.5,
                align='center', color=colors[pid], edgecolor='black')

        # Etiqueta centrada
        ax.text((start + end) / 2, y, pid,
                ha='center', va='center', color='black', fontsize=9)

    # Configuración del eje Y
    ax.set_yticks(list(y_positions.values()))
    ax.set_yticklabels(list(y_positions.keys()))

    # Configuración del eje X: mostrar todos los ticks
    max_time = max(end for _, _, end in gantt_chart)
    ax.set_xticks(range(0, max_time + 1))
    ax.set_xlim(0, max_time)

    # Cuadrícula
    ax.grid(True, axis='x', linestyle='--', alpha=0.6)

    # Etiquetas y título
    ax.set_xlabel("Tiempo")
    ax.set_ylabel("Procesos")
    ax.set_title(title)

    # Leyenda
    legend_patches = [mpatches.Patch(color=col, label=pid) for pid, col in colors.items()]
    ax.legend(handles=legend_patches, bbox_to_anchor=(1.05, 1), loc='upper left')

    plt.tight_layout()
    plt.show()


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\input_handler.py

...-------------------...


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\metricas.py

...-------------------...
def calcular_metricas(procesos):
    lista_metricas = []
    total_tr = 0
    total_te = 0

    for p in procesos:
        # Asegurarnos de que las métricas estén calculadas
        if p.turnaround_time is None or p.waiting_time is None:
            p.calculate_metrics()

        # Usar bursts_original si existe, si no, usar bursts actual
        bursts_fuente = getattr(p, "bursts_original", p.bursts)

        # Suma de todas las ráfagas de CPU (índices pares)
        total_cpu = sum(bursts_fuente[i] for i in range(0, len(bursts_fuente), 2))

        lista_metricas.append({
            "PID": p.pid,
            "Llegada": p.arrival_time,
            "CPU": total_cpu,
            "Finalización": p.completion_time,
            "TR": p.turnaround_time,
            "TE": p.waiting_time
        })

        total_tr += p.turnaround_time
        total_te += p.waiting_time

    trm = total_tr / len(procesos) if procesos else 0
    tem = total_te / len(procesos) if procesos else 0

    return lista_metricas, trm, tem



def imprimir_tabla_metricas(metricas, trm, tem):
    """
    Imprime la tabla de métricas en consola.
    """
    print(f"{'PID':<6}{'Llegada':<10}{'CPU':<8}{'Finalización':<14}{'TR':<8}{'TE':<8}")
    for m in metricas:
        print(f"{m['PID']:<6}{m['Llegada']:<10}{m['CPU']:<8}{m['Finalización']:<14}{m['TR']:<8}{m['TE']:<8}")
    print("\n📈 Promedios:")
    print(f"TRM (Tiempo de Respuesta Medio): {trm:.2f}")
    print(f"TEM (Tiempo de Espera Medio): {tem:.2f}")


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\parsers.py

...-------------------...
# utils/parsers.py

def parse_bursts(input_str):
    """
    Convierte una cadena como '3,(2),5' en [3, 2, 5].
    Los números entre paréntesis se interpretan como bloqueos (E/S).
    """
    bursts = []
    # Eliminamos espacios y separamos por comas
    parts = input_str.replace(" ", "").split(",")
    for part in parts:
        if part.startswith("(") and part.endswith(")"):
            # Bloqueo
            val = int(part.strip("()"))
            bursts.append(val)
        else:
            # CPU
            bursts.append(int(part))
    return bursts


...-------------------...
Archivo: C:\Users\Federixco\Documents\GitHub\GanddOperativos\utils\__init__.py

...-------------------...


...-------------------...
